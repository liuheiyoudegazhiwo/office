"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
require("../../../../../adapter-vue.js");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const config = require("../../../config.js");
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  emits: ["openReadUserPanel"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const ReadStatus = config.default.getFeatureConfig("ReadStatus");
    const TYPES = TUIChatEngine.TYPES;
    const isDisplayMessageReadReceipt = Vue.ref(TUIChatEngine.TUIStore.getData(TUIChatEngine.StoreName.USER, "displayMessageReadReceipt"));
    Vue.onMounted(() => {
      TUIChatEngine.TUIStore.watch(TUIChatEngine.StoreName.USER, {
        displayMessageReadReceipt: onDisplayMessageReadReceiptUpdate
      });
    });
    Vue.onUnmounted(() => {
      TUIChatEngine.TUIStore.unwatch(TUIChatEngine.StoreName.USER, {
        displayMessageReadReceipt: onDisplayMessageReadReceiptUpdate
      });
    });
    const isShowReadStatus = Vue.computed(() => {
      if (!ReadStatus) {
        return false;
      }
      if (!isDisplayMessageReadReceipt.value) {
        return false;
      }
      const {
        ID,
        type,
        flow,
        status,
        hasRiskContent,
        conversationID,
        conversationType,
        needReadReceipt = false
      } = props.message;
      if (hasRiskContent) {
        return false;
      }
      const { groupProfile } = TUIChatEngine.TUIStore.getConversationModel(conversationID) || {};
      if ((groupProfile == null ? void 0 : groupProfile.type) === TYPES.GRP_AVCHATROOM || (groupProfile == null ? void 0 : groupProfile.type) === TYPES.GRP_COMMUNITY) {
        return false;
      }
      if (type === TYPES.MSG_CUSTOM) {
        const message = TUIChatEngine.TUIStore.getMessageModel(ID);
        if ((message == null ? void 0 : message.getSignalingInfo()) !== null) {
          return false;
        }
      }
      if (flow !== "out" || status !== "success") {
        return false;
      }
      if (conversationType === "GROUP") {
        return needReadReceipt;
      } else if (conversationType === "C2C") {
        return true;
      }
      return false;
    });
    const readState = Vue.computed(() => {
      const { conversationType, needReadReceipt = false, isPeerRead = false } = props.message;
      const { readCount = 0, unreadCount = 0, isPeerRead: isReceiptPeerRead = false } = props.message.readReceiptInfo;
      if (conversationType === "C2C") {
        if (needReadReceipt) {
          return isReceiptPeerRead ? 0 : 1;
        } else {
          return isPeerRead ? 0 : 1;
        }
      } else if (conversationType === "GROUP") {
        if (needReadReceipt) {
          if (readCount === 0) {
            return 1;
          } else if (unreadCount === 0) {
            return 2;
          } else {
            return 4;
          }
        } else {
          return 3;
        }
      }
      return 1;
    });
    const readStatusText = Vue.computed(() => {
      const { readCount = 0 } = props.message.readReceiptInfo;
      switch (readState.value) {
        case 0:
          return TUIChatEngine.TUITranslateService.t("TUIChat.已读");
        case 1:
          return TUIChatEngine.TUITranslateService.t("TUIChat.未读");
        case 2:
          return TUIChatEngine.TUITranslateService.t("TUIChat.全部已读");
        case 4:
          return `${readCount}${TUIChatEngine.TUITranslateService.t("TUIChat.人已读")}`;
        default:
          return "";
      }
    });
    const isUseUnreadStyle = Vue.computed(() => {
      const { conversationType } = props.message;
      if (conversationType === "C2C") {
        return readState.value !== 0;
      } else if (conversationType === "GROUP") {
        return readState.value !== 2;
      }
      return false;
    });
    const isHoverFingerPointer = Vue.computed(() => {
      return props.message.needReadReceipt && props.message.conversationType === "GROUP" && (readState.value === 4 || readState.value === 1);
    });
    function openReadUserPanel() {
      if (isHoverFingerPointer.value) {
        emits("openReadUserPanel");
      }
    }
    function onDisplayMessageReadReceiptUpdate(isDisplay) {
      isDisplayMessageReadReceipt.value = isDisplay;
    }
    return (_ctx, _cache) => {
      return Vue.withDirectives((Vue.openBlock(), Vue.createElementBlock("div", {
        class: Vue.normalizeClass({
          "message-label": true,
          "unread": Vue.unref(isUseUnreadStyle),
          "finger-point": Vue.unref(isHoverFingerPointer)
        }),
        onClick: openReadUserPanel
      }, [
        Vue.createElementVNode("span", null, Vue.toDisplayString(Vue.unref(readStatusText)), 1)
      ], 2)), [
        [Vue.vShow, Vue.unref(isShowReadStatus)]
      ]);
    };
  }
});
exports.default = _sfc_main;
