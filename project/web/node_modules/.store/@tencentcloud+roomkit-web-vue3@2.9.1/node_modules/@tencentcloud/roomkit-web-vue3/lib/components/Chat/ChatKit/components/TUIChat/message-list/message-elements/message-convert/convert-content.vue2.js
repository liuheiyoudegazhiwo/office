"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
require("../../../../../adapter-vue.js");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const universalApi = require("@tencentcloud/universal-api");
const convertVoiceToText = require("../../../utils/convertVoiceToText.js");
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "convert-content",
  props: {
    message: { default: () => ({}) },
    contentVisible: { type: Boolean },
    convertWrapperRef: {},
    isSingleConvert: { type: Boolean, default: false }
  },
  emits: ["toggleErrorStatus"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const convertFinished = Vue.ref(false);
    const convertText = Vue.ref("");
    const calculateHeight = Vue.ref(0);
    const calculateWidth = Vue.ref(0);
    const convertLoadingRef = Vue.ref();
    const convertContentRef = Vue.ref();
    Vue.watch(() => props.contentVisible, (newVal) => {
      if (newVal) {
        convertVoiceToText.convertor.get(props.message).then((text) => {
          convertFinished.value = true;
          convertText.value = text;
          Vue.nextTick(() => {
            const { height: originHeight, width: originWidth } = universalApi.getBoundingClientRectSync(convertLoadingRef.value);
            const { height, width } = universalApi.getBoundingClientRectSync(convertContentRef.value);
            calculateHeight.value = originHeight;
            calculateWidth.value = originWidth;
            requestAnimationFrame(() => {
              calculateHeight.value = height;
              calculateWidth.value = width;
              if (props.isSingleConvert) {
                Vue.nextTick(() => {
                  const { bottom } = universalApi.getBoundingClientRectSync(props.convertWrapperRef);
                  const { bottom: bottomWindow } = universalApi.getBoundingClientRectSync("#messageScrollList");
                  if (bottom > bottomWindow) {
                    const timer = setTimeout(() => {
                      props.convertWrapperRef.scrollIntoView({ block: "end", behavior: "smooth" });
                      clearTimeout(timer);
                    }, 150);
                  }
                });
              }
            });
          });
        }).catch((err) => {
          convertFinished.value = true;
          emits("toggleErrorStatus", true);
          const { height: originHeight } = universalApi.getBoundingClientRectSync(convertLoadingRef.value);
          calculateHeight.value = originHeight;
          convertText.value = err.message;
        });
      }
    }, {
      immediate: true
    });
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock("div", {
        class: "message-convert-container",
        style: Vue.normalizeStyle({
          height: Vue.unref(calculateHeight) > 0 ? `${Vue.unref(calculateHeight)}px` : "auto",
          width: Vue.unref(calculateWidth) > 0 ? `${Vue.unref(calculateWidth)}px` : "auto"
        })
      }, [
        Vue.unref(convertFinished) ? (Vue.openBlock(), Vue.createElementBlock("div", {
          key: 0,
          ref_key: "convertContentRef",
          ref: convertContentRef,
          class: Vue.normalizeClass({
            "convert-content": true,
            "occur": Vue.unref(calculateHeight) > 0
          })
        }, Vue.toDisplayString(Vue.unref(convertText)), 3)) : Vue.createCommentVNode("", true),
        Vue.createElementVNode("div", {
          ref_key: "convertLoadingRef",
          ref: convertLoadingRef,
          class: Vue.normalizeClass({
            "loading": true,
            "loading-end": Vue.unref(convertFinished)
          })
        }, Vue.toDisplayString(Vue.unref(TUIChatEngine.TUITranslateService).t("TUIChat.转换中")) + "... ", 3)
      ], 4);
    };
  }
});
exports.default = _sfc_main;
