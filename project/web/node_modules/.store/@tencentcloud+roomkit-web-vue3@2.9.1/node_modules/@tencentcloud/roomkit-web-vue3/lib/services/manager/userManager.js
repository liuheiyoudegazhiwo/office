"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const TUIRoomEngine = require("@tencentcloud/tuiroom-engine-js");
const environment = require("../../utils/environment.js");
const utils = require("../../utils/utils.js");
class UserManager {
  constructor(service) {
    __publicField(this, "service");
    __publicField(this, "userListCompareFunction");
    __publicField(this, "streamListCompareFunction");
    __publicField(this, "onUserVideoStateChanged", (eventInfo) => {
      const { userId, streamType, hasVideo } = eventInfo;
      let userInfo = this.service.roomStore.userInfoObj[userId];
      if (!userInfo && hasVideo) {
        this.service.roomStore.addUserInfo({ userId, isInRoom: true });
      }
      userInfo = this.service.roomStore.userInfoObj[userId];
      if (!userInfo) {
        return;
      }
      const updateInfo = streamType === TUIRoomEngine.TUIVideoStreamType.kScreenStream ? { hasScreenStream: hasVideo } : { hasVideoStream: hasVideo };
      this.service.roomStore.updateUserInfo({ userId, ...updateInfo });
      if (streamType === TUIRoomEngine.TUIVideoStreamType.kCameraStream || streamType === TUIRoomEngine.TUIVideoStreamType.kScreenStream && hasVideo) {
        const streamInfo = this.service.roomStore.streamInfoObj[`${userId}_${streamType}`];
        if (!streamInfo) {
          this.service.roomStore.addStreamInfo(userId, streamType);
        }
        this.service.roomStore.updateStreamInfo({
          userId,
          streamType,
          hasVideoStream: hasVideo
        });
      } else if (streamType === TUIRoomEngine.TUIVideoStreamType.kScreenStream && !hasVideo) {
        this.service.roomStore.removeStreamInfo(userId, streamType);
      }
    });
    __publicField(this, "handleUserVoiceVolumeThrottle", utils.throttle(
      this.handleUserVoiceVolume,
      1e3
    ));
    this.service = service;
    this.userListCompareFunction = null;
    this.streamListCompareFunction = null;
    this.onRemoteUserEnterRoom = this.onRemoteUserEnterRoom.bind(this);
    this.onRemoteUserLeaveRoom = this.onRemoteUserLeaveRoom.bind(this);
    this.onSeatListChanged = this.onSeatListChanged.bind(this);
    this.onUserVideoStateChanged = this.onUserVideoStateChanged.bind(this);
    this.onUserAudioStateChanged = this.onUserAudioStateChanged.bind(this);
    this.onUserVoiceVolumeChanged = this.onUserVoiceVolumeChanged.bind(this);
    this.bindRoomEngineEvents();
  }
  async setSelfInfo(options) {
    const { avatarUrl, userName } = await TUIRoomEngine.getSelfInfo();
    const info = {
      userName: options.userName || userName,
      avatarUrl: options.avatarUrl || avatarUrl
    };
    this.service.basicStore.setBasicInfo(info);
    return TUIRoomEngine.setSelfInfo(info);
  }
  async setCustomInfoForUser(options) {
    const roomEngine = this.service.roomEngine.instance;
    return roomEngine == null ? void 0 : roomEngine.setCustomInfoForUser(options);
  }
  getDisplayName(options) {
    const { nameCard, userName, userId } = options;
    return nameCard || userName || userId;
  }
  setLocalUser(userInfo) {
    this.service.roomStore.addUserInfo(userInfo);
    this.service.roomStore.addStreamInfo(
      userInfo.userId,
      TUIRoomEngine.TUIVideoStreamType.kCameraStream
    );
  }
  setUserListSortComparator(comparator) {
    this.userListCompareFunction = comparator;
  }
  getUserListSortComparator() {
    const defaultUserListCompareFunction = utils.combineComparators(
      utils.createComparator(
        (userInfo) => Boolean(userInfo.userId === this.service.basicStore.userId)
      ),
      utils.createComparator(
        (userInfo) => Boolean(userInfo.userRole === TUIRoomEngine.TUIRole.kRoomOwner)
      ),
      utils.createComparator(
        (userInfo) => Boolean(userInfo.userRole === TUIRoomEngine.TUIRole.kAdministrator)
      ),
      utils.createComparator(
        (userInfo) => Boolean(userInfo.hasScreenStream)
      ),
      utils.createComparator(
        (userInfo) => Boolean(userInfo.hasVideoStream && userInfo.hasAudioStream)
      ),
      utils.createComparator(
        (userInfo) => Boolean(userInfo.hasVideoStream)
      ),
      utils.createComparator(
        (userInfo) => Boolean(userInfo.hasAudioStream)
      ),
      utils.createComparator((userInfo) => Boolean(userInfo.onSeat)),
      utils.createComparator(
        (userInfoA, userInfoB) => Boolean(Number(userInfoA.timestamp) < Number(userInfoB.timestamp))
      )
    );
    return this.userListCompareFunction || defaultUserListCompareFunction;
  }
  setStreamListSortComparator(comparator) {
    this.streamListCompareFunction = comparator;
  }
  getStreamListSortComparator() {
    const defaultUserListCompareFunction = utils.combineComparators(
      utils.createComparator(
        (streamInfo) => Boolean(streamInfo.streamType === TUIRoomEngine.TUIVideoStreamType.kScreenStream)
      ),
      utils.createComparator(
        (streamInfo) => Boolean(streamInfo.userId === this.service.roomStore.masterUserId)
      ),
      utils.createComparator(
        (streamInfo) => Boolean(streamInfo.userId === this.service.basicStore.userId)
      ),
      utils.createComparator(
        (streamInfoA) => Boolean(streamInfoA.hasAudioStream && streamInfoA.hasVideoStream)
      ),
      utils.createComparator(
        (streamInfoA) => Boolean(streamInfoA.hasVideoStream)
      ),
      utils.createComparator(
        (streamInfoA) => Boolean(streamInfoA.hasAudioStream)
      ),
      utils.createComparator(
        (streamInfoA, streamInfoB) => Boolean(Number(streamInfoA.timestamp) - Number(streamInfoB.timestamp))
      )
    );
    return this.streamListCompareFunction || defaultUserListCompareFunction;
  }
  onRemoteUserEnterRoom(eventInfo) {
    const { userInfo } = eventInfo;
    this.service.roomStore.addUserInfo(
      Object.assign(userInfo, { isInRoom: true, timestamp: Date.now() })
    );
    if (this.service.roomStore.isFreeSpeakMode) {
      this.service.roomStore.addStreamInfo(
        userInfo.userId,
        TUIRoomEngine.TUIVideoStreamType.kCameraStream
      );
    }
  }
  onRemoteUserLeaveRoom(eventInfo) {
    const { userId } = eventInfo.userInfo;
    this.service.roomStore.removeUserInfo(userId);
    this.service.roomStore.removeStreamInfo(
      userId,
      TUIRoomEngine.TUIVideoStreamType.kCameraStream
    );
    this.service.roomStore.removeStreamInfo(
      userId,
      TUIRoomEngine.TUIVideoStreamType.kScreenStream
    );
  }
  onSeatListChanged(eventInfo) {
    const { seatedList, leftList } = eventInfo;
    seatedList.forEach((seat) => {
      const { userId } = seat;
      const user = this.service.roomStore.userInfoObj[userId];
      if (user) {
        this.service.roomStore.updateUserInfo({ userId, onSeat: true });
      } else {
        this.service.roomStore.addUserInfo({
          userId,
          onSeat: true,
          isInRoom: true
        });
      }
      this.service.roomStore.addStreamInfo(
        userId,
        TUIRoomEngine.TUIVideoStreamType.kCameraStream
      );
    });
    leftList == null ? void 0 : leftList.forEach((seat) => {
      const { userId } = seat;
      if (userId === this.service.roomStore.localUser.userId) {
        this.service.basicStore.setIsOpenMic(false);
      }
      const user = this.service.roomStore.userInfoObj[userId];
      if (user) {
        this.service.roomStore.updateUserInfo({ userId, onSeat: false });
      }
      this.service.roomStore.removeStreamInfo(
        userId,
        TUIRoomEngine.TUIVideoStreamType.kCameraStream
      );
      this.service.roomStore.removeStreamInfo(
        userId,
        TUIRoomEngine.TUIVideoStreamType.kScreenStream
      );
    });
  }
  onUserAudioStateChanged(eventInfo) {
    const { userId, hasAudio } = eventInfo;
    let userInfo = this.service.roomStore.userInfoObj[userId];
    if (!userInfo && hasAudio) {
      this.service.roomStore.addUserInfo({ userId, isInRoom: true });
    }
    userInfo = this.service.roomStore.userInfoObj[userId];
    if (!userInfo) {
      return;
    }
    this.service.roomStore.updateUserInfo({ userId, hasAudioStream: hasAudio });
    const streamInfo = this.service.roomStore.streamInfoObj[`${userId}_${TUIRoomEngine.TUIVideoStreamType.kCameraStream}`];
    if (!streamInfo) {
      this.service.roomStore.addStreamInfo(
        userId,
        TUIRoomEngine.TUIVideoStreamType.kCameraStream
      );
    }
    this.service.roomStore.updateStreamInfo({
      userId,
      streamType: TUIRoomEngine.TUIVideoStreamType.kCameraStream,
      hasAudioStream: hasAudio
    });
  }
  // Calculate the userId of the loudest speaker in the room
  // Calculate the userId of the remote user who speaks the loudest in the current room.
  handleUserVoiceVolume(userVolumeList) {
    const localUserVolume = {
      userId: this.service.basicStore.userId,
      volume: 0
    };
    const largestRemoteUserVolume = {
      userId: "",
      volume: 0
    };
    userVolumeList.forEach((item) => {
      var _a, _b;
      if (item.userId === this.service.basicStore.userId && ((_a = this.service.roomStore.localStream) == null ? void 0 : _a.hasAudioStream)) {
        localUserVolume.volume = item.volume;
      } else if (item.userId !== this.service.basicStore.userId && ((_b = this.service.roomStore.userInfoObj[item.userId]) == null ? void 0 : _b.hasAudioStream)) {
        const { userId, volume } = item;
        if (volume > largestRemoteUserVolume.volume) {
          largestRemoteUserVolume.userId = userId;
          largestRemoteUserVolume.volume = volume;
        }
      }
    });
    const largestUserVolume = localUserVolume.volume > largestRemoteUserVolume.volume ? localUserVolume : largestRemoteUserVolume;
    if (this.service.roomStore.currentSpeakerInfo.remoteSpeakerUserId) {
      const lastRemoteSpeakerUserVolumeInfo = userVolumeList.find(
        (item) => item.userId === this.service.roomStore.currentSpeakerInfo.remoteSpeakerUserId
      );
      if (!lastRemoteSpeakerUserVolumeInfo || (lastRemoteSpeakerUserVolumeInfo == null ? void 0 : lastRemoteSpeakerUserVolumeInfo.volume) === 0 && largestRemoteUserVolume.volume > 0) {
        this.service.roomStore.setCurrentSpeakerInfo({
          remoteSpeakerUserId: largestRemoteUserVolume.userId
        });
      }
    } else {
      if (largestRemoteUserVolume.volume > 0) {
        this.service.roomStore.setCurrentSpeakerInfo({
          remoteSpeakerUserId: largestRemoteUserVolume.userId
        });
      }
    }
    if (this.service.roomStore.currentSpeakerInfo.speakerUserId) {
      const lastSpeakerUserVolumeInfo = userVolumeList.find(
        (item) => item.userId === this.service.roomStore.currentSpeakerInfo.speakerUserId
      );
      if (!lastSpeakerUserVolumeInfo || lastSpeakerUserVolumeInfo.volume === 0 && largestUserVolume.volume > 0) {
        this.service.roomStore.setCurrentSpeakerInfo({
          speakerUserId: largestUserVolume.userId
        });
      }
    } else {
      if (largestUserVolume.volume > 0) {
        this.service.roomStore.setCurrentSpeakerInfo({
          speakerUserId: largestUserVolume.userId
        });
      }
    }
  }
  onUserVoiceVolumeChanged(eventInfo) {
    const { userVolumeList } = eventInfo;
    this.service.roomStore.setAudioVolume(userVolumeList);
    if (environment.isMobile) {
      this.handleUserVoiceVolumeThrottle(userVolumeList);
    }
  }
  bindRoomEngineEvents() {
    TUIRoomEngine.once("ready", () => {
      var _a, _b, _c, _d, _e, _f;
      (_a = this.service.roomEngine.instance) == null ? void 0 : _a.on(
        TUIRoomEngine.TUIRoomEvents.onRemoteUserEnterRoom,
        this.onRemoteUserEnterRoom
      );
      (_b = this.service.roomEngine.instance) == null ? void 0 : _b.on(
        TUIRoomEngine.TUIRoomEvents.onRemoteUserLeaveRoom,
        this.onRemoteUserLeaveRoom
      );
      (_c = this.service.roomEngine.instance) == null ? void 0 : _c.on(
        TUIRoomEngine.TUIRoomEvents.onSeatListChanged,
        this.onSeatListChanged
      );
      (_d = this.service.roomEngine.instance) == null ? void 0 : _d.on(
        TUIRoomEngine.TUIRoomEvents.onUserVideoStateChanged,
        this.onUserVideoStateChanged
      );
      (_e = this.service.roomEngine.instance) == null ? void 0 : _e.on(
        TUIRoomEngine.TUIRoomEvents.onUserAudioStateChanged,
        this.onUserAudioStateChanged
      );
      (_f = this.service.roomEngine.instance) == null ? void 0 : _f.on(
        TUIRoomEngine.TUIRoomEvents.onUserVoiceVolumeChanged,
        this.onUserVoiceVolumeChanged
      );
    });
  }
  unbindRoomEngineEvents() {
    var _a, _b, _c, _d, _e, _f;
    (_a = this.service.roomEngine.instance) == null ? void 0 : _a.off(
      TUIRoomEngine.TUIRoomEvents.onRemoteUserEnterRoom,
      this.onRemoteUserEnterRoom
    );
    (_b = this.service.roomEngine.instance) == null ? void 0 : _b.off(
      TUIRoomEngine.TUIRoomEvents.onRemoteUserLeaveRoom,
      this.onRemoteUserLeaveRoom
    );
    (_c = this.service.roomEngine.instance) == null ? void 0 : _c.off(
      TUIRoomEngine.TUIRoomEvents.onSeatListChanged,
      this.onSeatListChanged
    );
    (_d = this.service.roomEngine.instance) == null ? void 0 : _d.off(
      TUIRoomEngine.TUIRoomEvents.onUserVideoStateChanged,
      this.onUserVideoStateChanged
    );
    (_e = this.service.roomEngine.instance) == null ? void 0 : _e.off(
      TUIRoomEngine.TUIRoomEvents.onUserAudioStateChanged,
      this.onUserAudioStateChanged
    );
    (_f = this.service.roomEngine.instance) == null ? void 0 : _f.off(
      TUIRoomEngine.TUIRoomEvents.onUserVoiceVolumeChanged,
      this.onUserVoiceVolumeChanged
    );
  }
}
exports.UserManager = UserManager;
