"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const _Translator = class _Translator {
  constructor() {
    __publicField(this, "isUseCache", true);
    __publicField(this, "translationCache", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    if (!_Translator.instance) {
      _Translator.instance = new _Translator();
    }
    return _Translator.instance;
  }
  async get(message) {
    if (this.isUseCache) {
      const cache = this.translationCache.get(message.ID);
      if (cache !== void 0) {
        return cache;
      }
    }
    const currentMessage = TUIChatEngine.TUIStore.getMessageModel(message.ID);
    if (!currentMessage) {
      return [];
    }
    const { text } = currentMessage.getMessageContent() || {};
    const textList = [];
    const splittingList = await this.getNickList(currentMessage);
    for (let i = 0; i < text.length; ++i) {
      const item = text[i];
      if (item.name === "img") {
        textList.push({ type: "face", value: item.src });
        continue;
      }
      const { transSplitingList, atNickList } = this.getSplitResult(item.text, splittingList);
      for (let j = 0; j < transSplitingList.length; ++j) {
        textList.push({ type: "text", value: transSplitingList[j] });
        if (j < atNickList.length) {
          textList.push({ type: "mention", value: atNickList[j] });
        }
      }
    }
    const needTranslateTextIndex = [];
    const needTranslateText = textList.filter((item, index) => {
      if (item.type === "text" && item.value.trim() !== "") {
        needTranslateTextIndex.push(index);
        return true;
      }
      return false;
    }).map((item) => item.value);
    if (needTranslateText.length === 0) {
      this.translationCache.set(currentMessage.ID, textList);
      return textList;
    }
    const translationResult = await this.getTranslationStandard(needTranslateText);
    translationResult.forEach((item, index) => {
      textList[needTranslateTextIndex[index]].value = item;
    });
    this.translationCache.set(currentMessage.ID, textList);
    return textList;
  }
  /**
   * Clears the translation cache.
   */
  clear() {
    this.translationCache.clear();
  }
  disableCache() {
    this.isUseCache = false;
  }
  enableCache() {
    this.isUseCache = true;
  }
  getTranslationStandard(originTextList) {
    return new Promise((resolve, reject) => {
      TUIChatEngine.TUIChatService.translateText({
        sourceTextList: originTextList,
        sourceLanguage: "auto"
      }).then((response) => {
        const {
          data: { translatedTextList }
        } = response;
        resolve(translatedTextList);
      }).catch((error) => {
        reject(error);
      });
    });
  }
  /**
   * the nick list is used to split the text by @ + {nick or userID}
   * @param message
   * @returns e.g. ['@james', '@john']
   */
  async getNickList(message) {
    const splittingList = [];
    const { atUserList = [] } = message;
    const atAllID = TUIChatEngine.TYPES.MSG_AT_ALL;
    if (atUserList.includes(atAllID)) {
      splittingList.push(`@${TUIChatEngine.TUITranslateService.t("TUIChat.所有人")}`);
    }
    if (atUserList.length > 0) {
      const { data: userProfileList } = await TUIChatEngine.TUIUserService.getUserProfile({ userIDList: atUserList });
      userProfileList.forEach((user) => {
        const atNick = `@${user.nick || user.userID}`;
        splittingList.push(atNick);
      });
    }
    return [...new Set(splittingList)];
  }
  /**
   * Splits the given text into substrings based on the provided splitString array.
   *
   * @param {string} text - The text to be split.
   * @param {string[]} splitString - The array of strings to split the text by.
   * @return {{ transSplitingList: string[]; atNickList: string[] }} - An object containing two arrays:
   *   - transSplitingList: An array of substrings extracted from the text.
   *   - atNickList: An array of split strings that were found in the text.
   */
  getSplitResult(text, splitString) {
    let searchStartPos = 0;
    const transSplitingList = [];
    const atNickList = [];
    while (searchStartPos < text.length) {
      const nextAtCharPos = text.indexOf("@", searchStartPos);
      if (nextAtCharPos === -1) {
        transSplitingList.push(text.substring(searchStartPos));
        break;
      }
      let found = false;
      for (let i = 0; i < splitString.length; ++i) {
        const pos = text.indexOf(splitString[i], nextAtCharPos);
        if (pos !== -1 && pos === nextAtCharPos) {
          transSplitingList.push(text.substring(searchStartPos, pos));
          atNickList.push(splitString[i]);
          searchStartPos = pos + splitString[i].length;
          found = true;
          break;
        }
      }
      if (!found) {
        transSplitingList.push(text.substring(searchStartPos));
        break;
      }
    }
    return {
      transSplitingList,
      atNickList
    };
  }
};
__publicField(_Translator, "instance");
let Translator = _Translator;
const translator = Translator.getInstance();
exports.translator = translator;
