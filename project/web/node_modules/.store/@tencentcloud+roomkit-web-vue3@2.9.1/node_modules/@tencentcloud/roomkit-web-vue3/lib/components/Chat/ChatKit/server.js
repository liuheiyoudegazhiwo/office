"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const TUICore = require("@tencentcloud/tui-core");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const universalApi = require("@tencentcloud/universal-api");
const typeCheck = require("./utils/type-check.js");
require("./utils/env.js");
const index = require("./locales/index.js");
const _TUIChatKit = class _TUIChatKit {
  constructor() {
    __publicField(this, "chat");
    __publicField(this, "SDKAppID");
    __publicField(this, "TUICore");
    __publicField(this, "TUIChatEngine");
    __publicField(this, "TUIGlobal");
    __publicField(this, "TUIComponents", {});
    __publicField(this, "TUIPlugins", {});
    this.TUICore = TUICore;
    this.TUIChatEngine = TUIChatEngine;
    this.TUIGlobal = universalApi.TUIGlobal;
    this.SDKAppID = 0;
    this.TUIGlobal._isTIMCallKit = true;
    TUICore.registerEvent(TUICore.TUIConstants.TUILogin.EVENT.LOGIN_STATE_CHANGED, TUICore.TUIConstants.TUILogin.EVENT_SUB_KEY.USER_LOGIN_SUCCESS, this);
    TUICore.registerEvent(TUICore.TUIConstants.TUITranslate.EVENT.LANGUAGE_CHANGED, TUICore.TUIConstants.TUITranslate.EVENT_SUB_KEY.CHANGE_SUCCESS, this);
    TUICore.registerService(TUICore.TUIConstants.TUITranslatePlugin.SERVICE.NAME, 1);
    TUICore.registerService(TUICore.TUIConstants.TUIVoiceToTextPlugin.SERVICE.NAME, 1);
  }
  /**
   * Listen for the success notification of TUILogin.login
   */
  onNotifyEvent(eventName, subKey, params) {
    if (eventName === TUICore.TUIConstants.TUILogin.EVENT.LOGIN_STATE_CHANGED) {
      switch (subKey) {
        case TUICore.TUIConstants.TUILogin.EVENT_SUB_KEY.USER_LOGIN_SUCCESS:
          this.login();
          break;
      }
    }
    if (eventName === TUICore.TUIConstants.TUITranslate.EVENT.LANGUAGE_CHANGED) {
      switch (subKey) {
        case TUICore.TUIConstants.TUITranslate.EVENT_SUB_KEY.CHANGE_SUCCESS:
          if (params == null ? void 0 : params.language) {
            TUIChatEngine.TUITranslateService.changeLanguage(params.language);
          }
          break;
      }
    }
  }
  /**
   * init
   */
  init() {
    if (_TUIChatKit.isInitialized) {
      return;
    }
    _TUIChatKit.isInitialized = true;
    TUIChatEngine.TUITranslateService.provideLanguages({ ...index.default });
    TUIChatEngine.TUITranslateService.useI18n();
    universalApi.TUIGlobal.TUIComponents = this.TUIComponents;
    universalApi.TUIGlobal.TUIPlugins = this.TUIPlugins;
    console.warn("[TUIChatKit]: init success.");
  }
  /**
   * login
   */
  login() {
    const { chat, SDKAppID, userID, userSig } = TUICore.TUILogin.getContext();
    this.SDKAppID = SDKAppID;
    this.TUIChatEngine.login({
      chat,
      SDKAppID,
      userID,
      userSig
    });
    this.chat = chat;
    return this.TUIChatEngine;
  }
  /**
   * Single component mounting
   *
   * @param {string} componentName
   * @param {any} component
   * @param {any=} env
   * @returns {TUICore} mounted instance
   */
  component(componentName, component, env) {
    var _a, _b;
    if ((_a = this == null ? void 0 : this.TUIComponents) == null ? void 0 : _a.componentName) {
      console.warn(
        `[TUIChatKit]: ${(_b = this == null ? void 0 : this.TUIComponents) == null ? void 0 : _b.componentName} component has already been applied to target TUIChatEngine.`
      );
    } else {
      this.TUIComponents[componentName] = component;
      env == null ? void 0 : env.component(componentName, component);
    }
    if (env) {
      !universalApi.TUIGlobal.Vue && (universalApi.TUIGlobal.Vue = env);
    }
    return this.TUIChatEngine;
  }
  /**
   * Component list mount
   *
   * @param {object} components
   * @param {any=} env: Vue2/Vue3 environment
   * @returns {TUICore} mounted instance
   */
  components(components, env) {
    var _a;
    if (!components || !typeCheck.isObject(components)) {
      console.warn("[TUIChatKit]: components is empty or not object.");
    } else {
      (_a = Object == null ? void 0 : Object.keys(components)) == null ? void 0 : _a.forEach((key) => {
        this.component(key, components[key], env);
      });
    }
    return this.TUIChatEngine;
  }
  /**
   * Plugin Injection
   *
   * @param {any} TUIPlugin
   * @param {any} options
   * @returns {TUICore} mounted instance
   */
  use(TUIPluginName, TUIPlugin, options) {
    if (!this.TUICore) {
      console.warn(
        `[TUIChatKit]: Plugin ${this.TUIPlugins[TUIPluginName]} can't be used before init.`
      );
      return;
    }
    if (this.TUIPlugins[TUIPluginName]) {
      console.warn(
        `[TUIChatKit]: Plugin ${this.TUIPlugins[TUIPluginName]} has already been applied to target TUIChatEngine.`
      );
    } else if (TUIPlugin && typeCheck.isFunction(TUIPlugin == null ? void 0 : TUIPlugin.plugin)) {
      this.TUIPlugins[TUIPluginName] = TUIPlugin;
      TUIPlugin == null ? void 0 : TUIPlugin.plugin(this, options);
    } else if (typeCheck.isFunction(TUIPlugin)) {
      this.TUIPlugins[TUIPluginName] = TUIPlugin;
      TUIPlugin(this, options);
    } else {
      console.warn(
        '[TUIChatKit]: A plugin must either be a function or an object with an "plugin" function.' + this.TUIPlugins[TUIPluginName] + "does not comply with the above rules."
      );
    }
    return this.TUIChatEngine;
  }
};
__publicField(_TUIChatKit, "isInitialized");
let TUIChatKit = _TUIChatKit;
exports.default = TUIChatKit;
