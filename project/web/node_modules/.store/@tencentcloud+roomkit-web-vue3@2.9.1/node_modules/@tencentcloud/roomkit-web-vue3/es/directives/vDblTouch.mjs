var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const touchEventMap = /* @__PURE__ */ new Map();
const clickEventMap = /* @__PURE__ */ new Map();
const TIME_OUT = 300;
class DblTouch {
  constructor(el, binding) {
    __publicField(this, "dom");
    __publicField(this, "callback");
    this.dom = el;
    this.callback = binding.value;
    el == null ? void 0 : el.addEventListener("click", (event) => {
      if (binding.modifiers.stop) {
        event.stopPropagation();
      }
      this.click(event);
    });
    el == null ? void 0 : el.addEventListener("touchend", (event) => {
      if (binding.modifiers.stop) {
        event.stopPropagation();
      }
      this.touchend(event);
    });
  }
  executeCallback(event) {
    clickEventMap.delete(this.dom);
    touchEventMap.delete(this.dom);
    this.callback && this.callback(event);
  }
  click(event) {
    const lastEvent = clickEventMap.get(this.dom);
    if (lastEvent) {
      this.executeCallback(event);
    } else {
      clickEventMap.set(this.dom, event);
      setTimeout(() => {
        clickEventMap.delete(this.dom);
      }, TIME_OUT);
    }
  }
  touchend(event) {
    const lastEvent = touchEventMap.get(this.dom);
    if (lastEvent) {
      this.executeCallback(event);
    } else {
      touchEventMap.set(this.dom, event);
      setTimeout(() => {
        touchEventMap.delete(this.dom);
      }, TIME_OUT);
    }
  }
}
const vDblTouch = {
  mounted(el, binding) {
    return new DblTouch(el, binding);
  }
};
export {
  vDblTouch as default
};
