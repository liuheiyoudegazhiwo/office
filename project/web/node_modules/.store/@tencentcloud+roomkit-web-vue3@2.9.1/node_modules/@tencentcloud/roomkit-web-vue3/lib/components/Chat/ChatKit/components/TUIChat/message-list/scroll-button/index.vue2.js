"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
require("../../../../adapter-vue.js");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const Icon = require("../../../common/Icon.vue.js");
const doubleArrow = require("../../../../assets/icon/double-arrow.svg.js");
const universalApi = require("@tencentcloud/universal-api");
const typeCheck = require("../../../../utils/type-check.js");
const _hoisted_1 = { class: "scroll-button-text" };
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "index",
  emits: ["scrollToLatestMessage"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    const messageList = Vue.ref([]);
    const currentConversationID = Vue.ref("");
    const currentLastMessageTime = Vue.ref(0);
    const newMessageCount = Vue.ref(0);
    const isScrollOverOneScreen = Vue.ref(false);
    const isExistLastMessage = Vue.ref(false);
    const isScrollButtonVisible = Vue.ref(false);
    const scrollButtonContent = Vue.computed(
      () => newMessageCount.value ? `${newMessageCount.value}${TUIChatEngine.TUITranslateService.t("TUIChat.条新消息")}` : TUIChatEngine.TUITranslateService.t("TUIChat.回到最新位置")
    );
    Vue.watch(
      () => [isScrollOverOneScreen.value, isExistLastMessage.value],
      () => {
        isScrollButtonVisible.value = isScrollOverOneScreen.value || isExistLastMessage.value;
        if (!isScrollButtonVisible.value) {
          resetNewMessageCount();
        }
      },
      { immediate: true }
    );
    Vue.onMounted(() => {
      TUIChatEngine.TUIStore.watch(TUIChatEngine.StoreName.CHAT, {
        messageList: onMessageListUpdated,
        newMessageList: onNewMessageListUpdated
      });
      TUIChatEngine.TUIStore.watch(TUIChatEngine.StoreName.CONV, {
        currentConversation: onCurrentConversationUpdated
      });
    });
    Vue.onUnmounted(() => {
      TUIChatEngine.TUIStore.unwatch(TUIChatEngine.StoreName.CHAT, {
        messageList: onMessageListUpdated,
        newMessageList: onNewMessageListUpdated
      });
      TUIChatEngine.TUIStore.unwatch(TUIChatEngine.StoreName.CONV, {
        currentConversation: onCurrentConversationUpdated
      });
    });
    function isTypingMessage(message) {
      var _a, _b;
      return ((_b = typeCheck.JSONToObject((_a = message.payload) == null ? void 0 : _a.data)) == null ? void 0 : _b.businessID) === "user_typing_status";
    }
    function onMessageListUpdated(newMessageList) {
      var _a, _b;
      messageList.value = newMessageList || [];
      const lastMessage = (_b = messageList.value) == null ? void 0 : _b[((_a = messageList.value) == null ? void 0 : _a.length) - 1];
      isExistLastMessage.value = !!(lastMessage && (lastMessage == null ? void 0 : lastMessage.time) < (currentLastMessageTime == null ? void 0 : currentLastMessageTime.value));
    }
    function onNewMessageListUpdated(newMessageList) {
      if (Array.isArray(newMessageList) && isScrollButtonVisible.value) {
        newMessageList.forEach((message) => {
          if (message && message.conversationID === currentConversationID.value && !message.isDeleted && !message.isRevoked && !isTypingMessage(message)) {
            newMessageCount.value += 1;
          }
        });
      }
    }
    function onCurrentConversationUpdated(conversation) {
      var _a;
      if ((conversation == null ? void 0 : conversation.conversationID) !== currentConversationID.value) {
        resetNewMessageCount();
      }
      currentConversationID.value = (conversation == null ? void 0 : conversation.conversationID) || "";
      currentLastMessageTime.value = ((_a = conversation == null ? void 0 : conversation.lastMessage) == null ? void 0 : _a.lastTime) || 0;
    }
    async function judgeScrollOverOneScreen(e) {
      var _a, _b, _c, _d, _e;
      if (e.target) {
        try {
          const { height } = await universalApi.getBoundingClientRect(`#${(_a = e.target) == null ? void 0 : _a.id}`, "messageList") || {};
          const scrollHeight = ((_b = e.target) == null ? void 0 : _b.scrollHeight) || ((_c = e.detail) == null ? void 0 : _c.scrollHeight);
          const scrollTop = ((_d = e.target) == null ? void 0 : _d.scrollTop) || ((_e = e.detail) == null ? void 0 : _e.scrollTop) || 0;
          if (scrollHeight - scrollTop > 2 * height) {
            isScrollOverOneScreen.value = true;
            return;
          }
          isScrollOverOneScreen.value = false;
        } catch (error) {
          isScrollOverOneScreen.value = false;
        }
      }
    }
    function resetMessageSource() {
      if (TUIChatEngine.TUIStore.getData(TUIChatEngine.StoreName.CHAT, "messageSource") !== void 0) {
        TUIChatEngine.TUIStore.update(TUIChatEngine.StoreName.CHAT, "messageSource", void 0);
      }
    }
    function resetNewMessageCount() {
      newMessageCount.value = 0;
    }
    function scrollToMessageListBottom() {
      resetMessageSource();
      resetNewMessageCount();
      emits("scrollToLatestMessage");
    }
    __expose({
      judgeScrollOverOneScreen,
      isScrollButtonVisible
    });
    return (_ctx, _cache) => {
      return Vue.unref(isScrollButtonVisible) ? (Vue.openBlock(), Vue.createElementBlock("div", {
        key: 0,
        class: "scroll-button",
        onClick: scrollToMessageListBottom
      }, [
        Vue.createVNode(Icon.default, {
          width: "10px",
          height: "10px",
          file: Vue.unref(doubleArrow.default)
        }, null, 8, ["file"]),
        Vue.createElementVNode("div", _hoisted_1, Vue.toDisplayString(Vue.unref(scrollButtonContent)), 1)
      ])) : Vue.createCommentVNode("", true);
    };
  }
});
exports.default = _sfc_main;
