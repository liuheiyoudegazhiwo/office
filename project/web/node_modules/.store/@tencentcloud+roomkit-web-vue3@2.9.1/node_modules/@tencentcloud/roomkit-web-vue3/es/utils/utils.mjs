import { isWeChat } from "./environment.mjs";
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    if (timer > 0) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = -1;
    }, delay);
  };
}
function throttle(fn, delay) {
  let previousTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - previousTime > delay) {
      fn.apply(this, args);
      previousTime = now;
    }
  };
}
function setFullScreen(element) {
  const fullScreenElement = element;
  if (fullScreenElement == null ? void 0 : fullScreenElement.requestFullscreen) {
    fullScreenElement == null ? void 0 : fullScreenElement.requestFullscreen();
  } else if (fullScreenElement == null ? void 0 : fullScreenElement.mozRequestFullScreen) {
    fullScreenElement == null ? void 0 : fullScreenElement.mozRequestFullScreen();
  } else if (fullScreenElement == null ? void 0 : fullScreenElement.webkitRequestFullScreen) {
    fullScreenElement == null ? void 0 : fullScreenElement.webkitRequestFullScreen();
  } else if (fullScreenElement == null ? void 0 : fullScreenElement.msRequestFullscreen) {
    fullScreenElement == null ? void 0 : fullScreenElement.msRequestFullscreen();
  }
}
function exitFullScreen() {
  if (!(document == null ? void 0 : document.fullscreenElement) && !(document == null ? void 0 : document.webkitFullscreenElement) && !(document == null ? void 0 : document.mozFullScreenElement)) {
    return;
  }
  const exitFullScreenDocument = document;
  if (exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.exitFullscreen) {
    exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.exitFullscreen();
  } else if (exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.msExitFullscreen) {
    exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.msExitFullscreen();
  } else if (exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.mozCancelFullScreen) {
    exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.mozCancelFullScreen();
  } else if (exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.webkitExitFullscreen) {
    exitFullScreenDocument == null ? void 0 : exitFullScreenDocument.webkitExitFullscreen();
  }
}
function getUrlParam(key) {
  const url = window == null ? void 0 : window.location.href.replace(/^[^?]*\?/, "");
  const regexp = new RegExp(`(^|&)${key}=([^&#]*)(&|$|)`, "i");
  const paramMatch = url == null ? void 0 : url.match(regexp);
  return paramMatch ? paramMatch[2] : null;
}
function deepClone(data) {
  let res = null;
  const reference = [Date, RegExp, Set, WeakSet, Map, WeakMap, Error];
  if (reference.includes(data == null ? void 0 : data.constructor)) {
    res = new data.constructor(data);
  } else if (Array.isArray(data)) {
    res = [];
    data.forEach((e, i) => {
      res[i] = deepClone(e);
    });
  } else if (typeof data === "object" && data !== null) {
    res = {};
    Object.keys(data).forEach((key) => {
      if (Object.hasOwnProperty.call(data, key)) {
        res[key] = deepClone(data[key]);
      }
    });
  } else {
    res = data;
  }
  return res;
}
const isUndefined = (value) => typeof value === "undefined";
const isNumber = (value) => typeof value === "number";
const isStringNumber = (value) => typeof value === "string" && !isNaN(Number(value));
const isFunction = (value) => typeof value === "function";
function addSuffix(value, suffix = "px") {
  if (isNumber(value) || isStringNumber(value)) {
    return value + suffix;
  }
  return value;
}
function getUrlWithRoomId(roomId) {
  if (isWeChat) return "";
  const currentUrl = window.location.href;
  const urlObj = new URL(currentUrl);
  const params = new URLSearchParams(urlObj.search);
  if (params.has("roomId")) {
    params.delete("roomId");
  }
  params.append("roomId", roomId);
  return `${`${urlObj.origin + urlObj.pathname}#/home?${params.toString()}`}`;
}
function calculateByteLength(str) {
  let byteLength = 0;
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    if (code <= 127) {
      byteLength += 1;
    } else if (code <= 2047) {
      byteLength += 2;
    } else if (code <= 65535) {
      byteLength += 3;
    } else {
      byteLength += 4;
    }
  }
  return byteLength;
}
function objectMerge(...args) {
  return args.reduce((acc, cur) => {
    Object.keys(cur).forEach((key) => {
      if (acc[key] && typeof acc[key] === "object") {
        acc[key] = objectMerge(acc[key], cur[key]);
      } else {
        acc[key] = cur[key];
      }
    });
    return acc;
  }, {});
}
function convertSecondsToHMS(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const remainingSeconds = seconds % 60;
  return {
    hours,
    minutes,
    seconds: remainingSeconds
  };
}
function getNanoId(size = 21) {
  const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  let id = "";
  let i = size;
  while (i) {
    id += urlAlphabet[Math.random() * 64 | 0];
    i = i - 1;
  }
  return id;
}
function findLastIndex(array, predicate, thisArg) {
  const len = array.length >>> 0;
  let k = len - 1;
  while (k >= 0) {
    const kValue = array[k];
    if (predicate.call(thisArg, kValue, k, array)) {
      return k;
    }
    k = k - 1;
  }
  return -1;
}
function formatTimestampToTime(timestamp, format = "MM-DD HH:mm") {
  const date = new Date(timestamp);
  const padStart = (value, length = 2) => value.toString().padStart(length, "0");
  const replacements = {
    YYYY: date.getFullYear().toString(),
    YY: (date.getFullYear() % 100).toString().padStart(2, "0"),
    MM: padStart(date.getMonth() + 1),
    DD: padStart(date.getDate()),
    HH: padStart(date.getHours()),
    hh: padStart(date.getHours() % 12),
    mm: padStart(date.getMinutes()),
    ss: padStart(date.getSeconds()),
    A: date.getHours() >= 12 ? "PM" : "AM"
  };
  return format.replace(
    /YYYY|YY|MM|DD|HH|hh|mm|ss|A/g,
    (match) => replacements[match]
  );
}
const combineComparators = (...comparators) => {
  return (a, b) => {
    for (const comparator of comparators) {
      const result = comparator(a, b);
      if (result !== 0) return result;
    }
    return 0;
  };
};
const createComparator = (compareRules) => {
  return (a, b) => {
    if (compareRules(a, b) && compareRules(b, a)) {
      return 0;
    }
    if (compareRules(a, b)) {
      return -1;
    }
    if (compareRules(b, a)) {
      return 1;
    }
    return 0;
  };
};
function arrayIsEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (let i = 0; i < arr1.length; i++) {
    if (typeof arr1[i] === "object" && typeof arr2[i] === "object" && arr1[i] !== null && arr2[i] !== null) {
      if (!arrayIsEqual(arr1[i], arr2[i])) {
        return false;
      }
    } else {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
  }
  return true;
}
export {
  addSuffix,
  arrayIsEqual,
  calculateByteLength,
  combineComparators,
  convertSecondsToHMS,
  createComparator,
  debounce,
  deepClone,
  exitFullScreen,
  findLastIndex,
  formatTimestampToTime,
  getNanoId,
  getUrlParam,
  getUrlWithRoomId,
  isFunction,
  isNumber,
  isStringNumber,
  isUndefined,
  objectMerge,
  setFullScreen,
  throttle
};
