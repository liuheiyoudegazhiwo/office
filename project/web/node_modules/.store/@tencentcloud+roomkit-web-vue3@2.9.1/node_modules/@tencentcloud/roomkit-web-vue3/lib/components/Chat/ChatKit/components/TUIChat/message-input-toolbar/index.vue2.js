"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
require("../../../adapter-vue.js");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const TUICore = require("@tencentcloud/tui-core");
const index = require("./emoji-picker/index.vue.js");
const index$1 = require("./image-upload/index.vue.js");
const index$2 = require("./file-upload/index.vue.js");
const index$3 = require("./video-upload/index.vue.js");
const index$4 = require("./evaluate/index.vue.js");
const index$5 = require("./words/index.vue.js");
const index$6 = require("./toolbar-item-container/index.vue.js");
const index_vue_vue_type_script_setup_true_lang = require("./user-selector/index.vue.js");
const env = require("../../../utils/env.js");
const config = require("../config.js");
const enableSampleTaskStatus = require("../../../utils/enableSampleTaskStatus.js");
const _hoisted_1 = {
  key: 0,
  class: /* @__PURE__ */ Vue.normalizeClass(["message-input-toolbar-list-end"])
};
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "index",
  props: {
    displayType: { default: "none" }
  },
  emits: ["scrollToLatestMessage", "changeToolbarDisplayType", "insertEmoji"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const h5Dialog = Vue.ref();
    const currentConversation = Vue.ref();
    const isGroup = Vue.ref(false);
    const selectorShowType = Vue.ref("");
    const userSelectorRef = Vue.ref();
    const emojiPickerRef = Vue.ref();
    const currentUserSelectorExtension = Vue.ref();
    const currentExtensionList = Vue.ref([]);
    const featureConfig = config.default.getFeatureConfig();
    const isRenderedEmojiPicker = Vue.ref(true);
    isRenderedEmojiPicker.value = featureConfig.InputEmoji || featureConfig.InputStickers;
    Vue.onMounted(() => {
      TUIChatEngine.TUIStore.watch(TUIChatEngine.StoreName.CUSTOM, {
        activeConversation: onActiveConversationUpdate
      });
    });
    Vue.onUnmounted(() => {
      TUIChatEngine.TUIStore.unwatch(TUIChatEngine.StoreName.CUSTOM, {
        activeConversation: onActiveConversationUpdate
      });
    });
    Vue.watch(() => props.displayType, (newValue) => {
      var _a;
      if (newValue === "none") {
        (_a = emojiPickerRef.value) == null ? void 0 : _a.closeEmojiPicker();
      } else {
        emits("scrollToLatestMessage");
      }
    });
    const onActiveConversationUpdate = (conversationID) => {
      var _a;
      if (!conversationID) {
        return;
      }
      if (conversationID !== ((_a = currentConversation.value) == null ? void 0 : _a.conversationID)) {
        getExtensionList();
        currentConversation.value = TUIChatEngine.TUIStore.getData(TUIChatEngine.StoreName.CONV, "currentConversation");
        isGroup.value = conversationID.startsWith(TUIChatEngine.TYPES.CONV_GROUP);
      }
    };
    const getExtensionList = () => {
      const chatType = config.default.getChatType();
      const params = { chatType };
      if (chatType === TUICore.TUIConstants.TUIChat.TYPE.CUSTOMER_SERVICE) {
        params.filterVoice = true;
        params.filterVideo = true;
        enableSampleTaskStatus.enableSampleTaskStatus("customerService");
      }
      currentExtensionList.value = [
        ...TUICore.getExtensionList(TUICore.TUIConstants.TUIChat.EXTENSION.INPUT_MORE.EXT_ID, params)
      ].filter((extension) => {
        var _a;
        if (((_a = extension == null ? void 0 : extension.data) == null ? void 0 : _a.name) === "search") {
          return featureConfig.MessageSearch;
        }
        return true;
      });
    };
    const extensionListShowInStart = Vue.computed(() => {
      if (env.isPC) {
        const extensionList = currentExtensionList.value.filter((extension) => {
          var _a;
          return ((_a = extension == null ? void 0 : extension.data) == null ? void 0 : _a.name) !== "search";
        });
        return extensionList;
      }
      return currentExtensionList.value;
    });
    const extensionListShowInEnd = Vue.computed(() => {
      if (env.isPC) {
        const searchExtension = currentExtensionList.value.find((extension) => {
          var _a;
          return ((_a = extension == null ? void 0 : extension.data) == null ? void 0 : _a.name) === "search";
        });
        return searchExtension ? [searchExtension] : [];
      }
      return [];
    });
    const onExtensionClick = (extension) => {
      var _a, _b, _c;
      switch ((_a = extension == null ? void 0 : extension.data) == null ? void 0 : _a.name) {
        case "voiceCall":
          onCallExtensionClicked(extension, 1);
          break;
        case "videoCall":
          onCallExtensionClicked(extension, 2);
          break;
        default:
          (_c = extension == null ? void 0 : extension.listener) == null ? void 0 : _c.onClicked((_b = currentConversation.value) == null ? void 0 : _b._conversation);
          break;
      }
    };
    const onCallExtensionClicked = (extension, callType) => {
      var _a, _b, _c, _d, _e, _f, _g;
      selectorShowType.value = (_a = extension == null ? void 0 : extension.data) == null ? void 0 : _a.name;
      if (((_b = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _b.type) === TUIChatEngine.TYPES.CONV_C2C) {
        (_f = (_c = extension.listener) == null ? void 0 : _c.onClicked) == null ? void 0 : _f.call(_c, {
          userIDList: [(_e = (_d = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _d.conversationID) == null ? void 0 : _e.slice(3)],
          type: callType
        });
      } else if (isGroup.value) {
        currentUserSelectorExtension.value = extension;
        ((_g = userSelectorRef == null ? void 0 : userSelectorRef.value) == null ? void 0 : _g.toggleShow) && userSelectorRef.value.toggleShow(true);
      }
    };
    const genExtensionIcon = (extension) => {
      return extension == null ? void 0 : extension.icon;
    };
    const genExtensionText = (extension) => {
      return extension == null ? void 0 : extension.text;
    };
    const onUserSelectorSubmit = (selectedInfo) => {
      var _a, _b, _c;
      (_c = (_b = (_a = currentUserSelectorExtension.value) == null ? void 0 : _a.listener) == null ? void 0 : _b.onClicked) == null ? void 0 : _c.call(_b, selectedInfo);
      currentUserSelectorExtension.value = void 0;
    };
    const onUserSelectorCancel = () => {
      currentUserSelectorExtension.value = void 0;
    };
    const insertEmoji = (emojiObj) => {
      emits("insertEmoji", emojiObj);
    };
    const dialogShowInH5 = (dialogDom) => {
      var _a, _b;
      if (!env.isH5) {
        return;
      }
      ((_a = h5Dialog.value) == null ? void 0 : _a.appendChild) && ((_b = h5Dialog.value) == null ? void 0 : _b.appendChild(dialogDom));
    };
    const dialogCloseInH5 = (dialogDom) => {
      var _a, _b;
      if (!env.isH5) {
        return;
      }
      if (dialogDom) {
        ((_a = h5Dialog.value) == null ? void 0 : _a.removeChild) && ((_b = h5Dialog.value) == null ? void 0 : _b.removeChild(dialogDom));
      }
    };
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock("div", {
        class: Vue.normalizeClass([
          "message-input-toolbar",
          !Vue.unref(env.isPC) && "message-input-toolbar-h5",
          Vue.unref(env.isUniFrameWork) && "message-input-toolbar-uni"
        ])
      }, [
        Vue.createElementVNode("div", {
          class: Vue.normalizeClass([
            "message-input-toolbar-list",
            !Vue.unref(env.isPC) && "message-input-toolbar-h5-list",
            Vue.unref(env.isUniFrameWork) && "message-input-toolbar-uni-list"
          ])
        }, [
          Vue.unref(isRenderedEmojiPicker) ? (Vue.openBlock(), Vue.createBlock(index.default, {
            key: 0,
            ref_key: "emojiPickerRef",
            ref: emojiPickerRef,
            onInsertEmoji: insertEmoji,
            onDialogShowInH5: dialogShowInH5,
            onDialogCloseInH5: dialogCloseInH5,
            onChangeToolbarDisplayType: _cache[0] || (_cache[0] = (type) => emits("changeToolbarDisplayType", type))
          }, null, 512)) : Vue.createCommentVNode("", true),
          Vue.unref(featureConfig).InputImage ? (Vue.openBlock(), Vue.createBlock(index$1.default, {
            key: 1,
            imageSourceType: "album"
          })) : Vue.createCommentVNode("", true),
          Vue.unref(featureConfig).InputFile ? (Vue.openBlock(), Vue.createBlock(index$2.default, { key: 2 })) : Vue.createCommentVNode("", true),
          Vue.unref(featureConfig).InputVideo ? (Vue.openBlock(), Vue.createBlock(index$3.default, {
            key: 3,
            videoSourceType: "album"
          })) : Vue.createCommentVNode("", true),
          Vue.unref(featureConfig).InputEvaluation ? (Vue.openBlock(), Vue.createBlock(index$4.default, { key: 4 })) : Vue.createCommentVNode("", true),
          Vue.unref(featureConfig).InputQuickReplies ? (Vue.openBlock(), Vue.createBlock(index$5.default, { key: 5 })) : Vue.createCommentVNode("", true),
          Vue.unref(extensionListShowInStart)[0] ? (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, { key: 6 }, Vue.renderList(Vue.unref(extensionListShowInStart), (extension) => {
            return Vue.openBlock(), Vue.createBlock(index$6.default, {
              key: extension.id,
              iconFile: genExtensionIcon(extension),
              title: genExtensionText(extension),
              iconWidth: Vue.unref(env.isUniFrameWork) ? "25px" : "20px",
              iconHeight: Vue.unref(env.isUniFrameWork) ? "25px" : "20px",
              needDialog: false,
              onOnIconClick: ($event) => onExtensionClick(extension)
            }, null, 8, ["iconFile", "title", "iconWidth", "iconHeight", "onOnIconClick"]);
          }), 128)) : Vue.createCommentVNode("", true)
        ], 2),
        Vue.unref(extensionListShowInEnd)[0] && Vue.unref(env.isPC) ? (Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1, [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(extensionListShowInEnd), (extension, index2) => {
            return Vue.openBlock(), Vue.createBlock(index$6.default, {
              key: index2,
              iconFile: genExtensionIcon(extension),
              title: genExtensionText(extension),
              iconWidth: Vue.unref(env.isUniFrameWork) ? "25px" : "20px",
              iconHeight: Vue.unref(env.isUniFrameWork) ? "25px" : "20px",
              needDialog: false,
              onOnIconClick: ($event) => onExtensionClick(extension)
            }, null, 8, ["iconFile", "title", "iconWidth", "iconHeight", "onOnIconClick"]);
          }), 128))
        ])) : Vue.createCommentVNode("", true),
        Vue.createVNode(index_vue_vue_type_script_setup_true_lang.default, {
          ref_key: "userSelectorRef",
          ref: userSelectorRef,
          type: Vue.unref(selectorShowType),
          currentConversation: Vue.unref(currentConversation),
          isGroup: Vue.unref(isGroup),
          onSubmit: onUserSelectorSubmit,
          onCancel: onUserSelectorCancel
        }, null, 8, ["type", "currentConversation", "isGroup"]),
        Vue.unref(env.isH5) ? (Vue.openBlock(), Vue.createElementBlock("div", {
          key: 1,
          ref_key: "h5Dialog",
          ref: h5Dialog,
          class: Vue.normalizeClass(["message-input-toolbar-h5-dialog"])
        }, null, 512)) : Vue.createCommentVNode("", true)
      ], 2);
    };
  }
});
exports.default = _sfc_main;
