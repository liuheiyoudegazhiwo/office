import {
  C,
  ChatConfig,
  E,
  Emoji,
  Emoji2,
  JSONToObject,
  Jt,
  O,
  P,
  Qt,
  R,
  T,
  Wt,
  Xt,
  Zt,
  _export_sfc,
  es,
  f,
  g,
  i,
  isApp,
  isH5,
  isMobile,
  isPC,
  isUniFrameWork,
  isUrl,
  isWeChat,
  o,
  qt
} from "./chunk-XGGGNUJG.js";
import {
  __export,
  __reExport
} from "./chunk-ANIWD3T6.js";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/index.vue2.mjs
import { defineComponent as defineComponent64, ref as ref51, onMounted as onMounted22, onUnmounted as onUnmounted17, computed as computed23, createElementBlock as createElementBlock57, openBlock as openBlock63, createElementVNode as createElementVNode45, normalizeClass as normalizeClass45, unref as unref62, createCommentVNode as createCommentVNode43, renderSlot as renderSlot13, createVNode as createVNode32, createBlock as createBlock24, toDisplayString as toDisplayString41, Fragment as Fragment21 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/adapter-vue.mjs
var adapter_vue_exports = {};
__export(adapter_vue_exports, {
  createVNode: () => createVNode2,
  framework: () => framework,
  render: () => render2,
  vueVersion: () => vueVersion
});
__reExport(adapter_vue_exports, vue_star);
import * as Vue from "vue";
import * as vue_star from "vue";
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var vueVersion;
var framework = "vue2";
var createVNode2 = (arg1, arg2) => {
  return {};
};
var render2 = (arg1, arg2) => {
  return;
};
try {
  if (((_a = Vue == null ? void 0 : Vue.default) == null ? void 0 : _a.version) && ((_c = (_b = Vue == null ? void 0 : Vue.default) == null ? void 0 : _b.version) == null ? void 0 : _c.startsWith("2.7."))) {
    vueVersion = 2.7;
  } else if (((_d = Vue == null ? void 0 : Vue.default) == null ? void 0 : _d.version) && ((_f = (_e = Vue == null ? void 0 : Vue.default) == null ? void 0 : _e.version) == null ? void 0 : _f.startsWith("2."))) {
    vueVersion = 2;
  } else {
    vueVersion = 3;
    framework = "vue3";
    createVNode2 = Vue == null ? void 0 : Vue.createVNode;
    render2 = Vue == null ? void 0 : Vue.render;
  }
} catch (error) {
  vueVersion = 3;
  framework = "vue3";
  createVNode2 = Vue == null ? void 0 : Vue.createVNode;
  render2 = Vue == null ? void 0 : Vue.render;
}
console.warn(`[adapter-vue]: vue version is ${vueVersion}`);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/chat-header/index.vue2.mjs
import { defineComponent as defineComponent2, ref, onMounted, onUnmounted, createElementBlock as createElementBlock2, openBlock as openBlock2, normalizeClass as normalizeClass2, unref as unref2, createCommentVNode, createElementVNode, createVNode as createVNode3, toDisplayString, Fragment, renderList, withModifiers } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Icon.vue2.mjs
import { defineComponent, computed, createElementBlock, openBlock, normalizeStyle, normalizeClass, unref } from "vue";
var _hoisted_1 = ["src"];
var _hoisted_2 = ["src"];
var _sfc_main = defineComponent({
  __name: "Icon",
  props: {
    file: { default: "" },
    size: {},
    width: { default: "20px" },
    height: { default: "20px" },
    hotAreaSize: {}
  },
  emits: ["onClick"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const iconHotAreaSize = computed(() => {
      if (!props.hotAreaSize) {
        return void 0;
      }
      if (isNaN(Number(props.hotAreaSize))) {
        return String(props.hotAreaSize);
      }
      return `${props.hotAreaSize}px`;
    });
    const iconWidth = computed(() => {
      return props.size ? props.size : props.width;
    });
    const iconHeight = computed(() => {
      return props.size ? props.size : props.height;
    });
    const handleImgClick = (e) => {
      emits("onClick", e);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["common-icon-container", !unref(isPC) && "common-icon-container-mobile"]),
        style: normalizeStyle({
          padding: unref(iconHotAreaSize)
        }),
        onClick: handleImgClick
      }, [
        unref(isApp) ? (openBlock(), createElementBlock("image", {
          key: 0,
          class: "common-icon",
          src: props.file,
          style: normalizeStyle({ width: unref(iconWidth), height: unref(iconHeight) })
        }, null, 12, _hoisted_1)) : (openBlock(), createElementBlock("img", {
          key: 1,
          class: "common-icon",
          src: props.file,
          style: normalizeStyle({ width: unref(iconWidth), height: unref(iconHeight) })
        }, null, 12, _hoisted_2))
      ], 6);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Icon.vue.mjs
var Icon = _export_sfc(_sfc_main, [["__scopeId", "data-v-1da8a3b2"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/back.svg.mjs
var backIcon = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='48px'%20height='48px'%20viewBox='0%200%2048%2048'%20version='1.1'%3e%3ctitle%3eic_back_white%3c/title%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='02.-查看信息-示例好友'%20transform='translate(-32.000000,%20-200.000000)'%3e%3cg%20id='编组-6'%20transform='translate(0.000000,%20176.000000)'%3e%3cg%20id='ic_back_white'%20transform='translate(32.000000,%2024.000000)'%3e%3cg%20id='ic_back_black'%20fill='%23444444'%20fill-rule='nonzero'%3e%3cpath%20d='M9.51231071,24%20L23.5198286,38.7290411%20C23.785378,39.0082689%2023.7753168,39.4496082%2023.4973187,39.7164448%20L21.6255915,41.5130226%20C21.3466827,41.7807332%2020.9035602,41.7716553%2020.6358496,41.4927466%20C20.6351032,41.491969%2020.6343586,41.4911896%2020.6336157,41.4904085%20L4.45876399,24.4823948%20C4.2017544,24.2121467%204.2017544,23.7878533%204.45876399,23.5176052%20L20.6336157,6.50959152%20C20.900035,6.22944906%2021.3431109,6.21832422%2021.6232533,6.48474351%20C21.6240344,6.48548634%2021.6248138,6.48623097%2021.6255915,6.48697741%20L23.4973187,8.28355524%20C23.7753168,8.55039175%2023.785378,8.99173114%2023.5198286,9.27095893%20L9.51231071,24%20L9.51231071,24%20Z'%20id='Path-2'%3e%3c/path%3e%3c/g%3e%3crect%20id='矩形'%20x='0'%20y='0'%20width='48'%20height='48'%3e%3c/rect%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/chat-header/index.vue2.mjs
var _hoisted_12 = { class: "chat-header-container" };
var _hoisted_22 = ["onClick"];
var _sfc_main2 = defineComponent2({
  __name: "index",
  props: {
    headerExtensionList: { default: () => [] }
  },
  emits: ["closeChat"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const currentConversation = ref();
    const currentConversationName = ref("");
    const typingStatus = ref(false);
    const groupID = ref("");
    const isNotRoomChat = ref(ChatConfig.getChatType() !== E.TUIChat.TYPE.ROOM);
    onMounted(() => {
      Jt.watch(o.CONV, {
        currentConversation: onCurrentConversationUpdated
      });
      Jt.watch(o.CHAT, {
        typingStatus: onTypingStatusUpdated
      });
    });
    onUnmounted(() => {
      Jt.unwatch(o.CONV, {
        currentConversation: onCurrentConversationUpdated
      });
      Jt.unwatch(o.CHAT, {
        typingStatus: onTypingStatusUpdated
      });
    });
    const closeChat = (conversationID) => {
      emits("closeChat", conversationID);
    };
    const handleExtensions = (item) => {
      var _a3, _b3;
      (_b3 = (_a3 = item.listener).onClicked) == null ? void 0 : _b3.call(_a3, { groupID: groupID.value });
    };
    function onCurrentConversationUpdated(conversation) {
      var _a3, _b3, _c2;
      currentConversation.value = conversation;
      groupID.value = (_b3 = (_a3 = currentConversation.value) == null ? void 0 : _a3.groupProfile) == null ? void 0 : _b3.groupID;
      currentConversationName.value = (_c2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c2.getShowName();
    }
    function onTypingStatusUpdated(status) {
      var _a3;
      typingStatus.value = status;
      if (typingStatus.value) {
        currentConversationName.value = Wt.t("TUIChat.对方正在输入");
      } else {
        currentConversationName.value = ((_a3 = currentConversation.value) == null ? void 0 : _a3.getShowName()) || "";
      }
    }
    return (_ctx, _cache) => {
      return openBlock2(), createElementBlock2("div", {
        class: normalizeClass2(["chat-header", !unref2(isPC) && "chat-header-h5"])
      }, [
        !unref2(isPC) && unref2(isNotRoomChat) ? (openBlock2(), createElementBlock2("div", {
          key: 0,
          class: normalizeClass2(["chat-header-back", !unref2(isPC) && "chat-header-h5-back"]),
          onClick: _cache[0] || (_cache[0] = ($event) => closeChat(unref2(currentConversation).conversationID))
        }, [
          createVNode3(Icon, { file: unref2(backIcon) }, null, 8, ["file"])
        ], 2)) : createCommentVNode("", true),
        createElementVNode("div", _hoisted_12, [
          unref2(isNotRoomChat) ? (openBlock2(), createElementBlock2("div", {
            key: 0,
            class: normalizeClass2(["chat-header-content", !unref2(isPC) && "chat-header-h5-content"])
          }, toDisplayString(unref2(currentConversationName)), 3)) : createCommentVNode("", true),
          _cache[1] || (_cache[1] = createElementVNode("div", null, null, -1))
        ]),
        createElementVNode("div", {
          class: normalizeClass2(["chat-header-setting", !unref2(isPC) && "chat-header-h5-setting"])
        }, [
          (openBlock2(true), createElementBlock2(Fragment, null, renderList(props.headerExtensionList, (item, index3) => {
            return openBlock2(), createElementBlock2("div", {
              key: index3,
              onClick: withModifiers(($event) => handleExtensions(item), ["stop"])
            }, [
              createVNode3(Icon, {
                file: item.icon
              }, null, 8, ["file"])
            ], 8, _hoisted_22);
          }), 128))
        ], 2)
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/chat-header/index.vue.mjs
var ChatHeader = _export_sfc(_sfc_main2, [["__scopeId", "data-v-14f4476c"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/index.vue2.mjs
import { defineComponent as defineComponent44, ref as ref31, computed as computed16, onMounted as onMounted16, onUnmounted as onUnmounted11, nextTick as nextTick5, watch as watch14, resolveComponent, createElementBlock as createElementBlock42, openBlock as openBlock43, normalizeClass as normalizeClass28, unref as unref42, createElementVNode as createElementVNode30, createCommentVNode as createCommentVNode29, createBlock as createBlock9, createVNode as createVNode22, toDisplayString as toDisplayString30, Fragment as Fragment13, renderList as renderList11, withModifiers as withModifiers10, withCtx as withCtx9 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/link/index.mjs
var Link = {
  product: {
    label: "产品文档",
    url: "https://cloud.tencent.com/document/product/269/1499#.E7.BE.A4.E7.BB.84.E5.8A.9F.E8.83.BD"
  },
  customMessage: {
    label: "自定义消息",
    url: "https://web.sdk.qcloud.com/im/doc/zh-cn/SDK.html#createCustomMessage"
  },
  complaint: {
    label: "点此投诉",
    url: "https://cloud.tencent.com/apply/p/xc3oaubi98g"
  },
  implement: {
    label: "集成TUICallKit",
    url: "https://cloud.tencent.com/document/product/269/79861"
  },
  purchase: {
    label: "开通腾讯实时音视频服务",
    url: "https://cloud.tencent.com/document/product/1640/79968"
  }
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-group-application/index.vue2.mjs
import { defineComponent as defineComponent6, ref as ref5, watch as watch3, onMounted as onMounted2, onUnmounted as onUnmounted2, createElementBlock as createElementBlock6, openBlock as openBlock6, createCommentVNode as createCommentVNode5, createVNode as createVNode4, unref as unref6, createElementVNode as createElementVNode4, toDisplayString as toDisplayString2, withCtx as withCtx2, normalizeClass as normalizeClass6, createBlock as createBlock2, Fragment as Fragment3, renderList as renderList2 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Avatar/index.vue2.mjs
import { defineComponent as defineComponent3, ref as ref2, toRefs, createElementBlock as createElementBlock3, openBlock as openBlock3, normalizeStyle as normalizeStyle2, unref as unref3, createCommentVNode as createCommentVNode2, Fragment as Fragment2, normalizeClass as normalizeClass3 } from "vue";
var _hoisted_13 = ["src"];
var _hoisted_23 = ["src"];
var _hoisted_3 = ["src"];
var _sfc_main3 = defineComponent3({
  __name: "index",
  props: {
    url: { default: "https://web.sdk.qcloud.com/component/TUIKit/assets/avatar_21.png" },
    size: { default: "36px" },
    borderRadius: { default: "5px" },
    useSkeletonAnimation: { type: Boolean, default: false }
  },
  emits: ["onLoad", "onError"],
  setup(__props, { emit: __emit }) {
    const defaultAvatarUrl = ref2("https://web.sdk.qcloud.com/component/TUIKit/assets/avatar_21.png");
    const emits = __emit;
    const props = __props;
    const {
      size: avatarSize,
      url: avatarImageUrl,
      borderRadius: avatarBorderRadius,
      useSkeletonAnimation: useAvatarSkeletonAnimation
    } = toRefs(props);
    let reloadAvatarTime = 0;
    const isImgLoaded = ref2(false);
    const loadErrorInUniapp = ref2(false);
    function avatarLoadSuccess(e) {
      isImgLoaded.value = true;
      emits("onLoad", e);
    }
    function avatarLoadFailed(e) {
      reloadAvatarTime += 1;
      if (reloadAvatarTime > 3) {
        return;
      }
      if (isUniFrameWork) {
        loadErrorInUniapp.value = true;
      } else {
        e.currentTarget.src = defaultAvatarUrl.value;
      }
      emits("onError", e);
    }
    return (_ctx, _cache) => {
      return openBlock3(), createElementBlock3("div", {
        class: "avatar-container",
        style: normalizeStyle2({
          width: unref3(avatarSize),
          height: unref3(avatarSize),
          borderRadius: unref3(avatarBorderRadius)
        })
      }, [
        unref3(isUniFrameWork) ? (openBlock3(), createElementBlock3(Fragment2, { key: 0 }, [
          !unref3(loadErrorInUniapp) ? (openBlock3(), createElementBlock3("image", {
            key: 0,
            class: "avatar-image",
            src: unref3(avatarImageUrl) || unref3(defaultAvatarUrl),
            onLoad: avatarLoadSuccess,
            onError: avatarLoadFailed
          }, null, 40, _hoisted_13)) : (openBlock3(), createElementBlock3("image", {
            key: 1,
            class: "avatar-image",
            src: unref3(defaultAvatarUrl),
            onLoad: avatarLoadSuccess,
            onError: avatarLoadFailed
          }, null, 40, _hoisted_23))
        ], 64)) : (openBlock3(), createElementBlock3("img", {
          key: 1,
          class: "avatar-image",
          src: unref3(avatarImageUrl) || unref3(defaultAvatarUrl),
          onLoad: avatarLoadSuccess,
          onError: avatarLoadFailed
        }, null, 40, _hoisted_3)),
        unref3(useAvatarSkeletonAnimation) && !unref3(isImgLoaded) ? (openBlock3(), createElementBlock3("div", {
          key: 2,
          class: normalizeClass3({
            placeholder: true,
            hidden: unref3(isImgLoaded),
            "skeleton-animation": unref3(useAvatarSkeletonAnimation)
          })
        }, null, 2)) : createCommentVNode2("", true)
      ], 4);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Avatar/index.vue.mjs
var Avatar = _export_sfc(_sfc_main3, [["__scopeId", "data-v-44d9a08c"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Drawer/index.vue2.mjs
import { defineComponent as defineComponent5, ref as ref4, watch as watch2, createBlock, openBlock as openBlock5, withCtx, createElementBlock as createElementBlock5, createCommentVNode as createCommentVNode4, unref as unref5, normalizeStyle as normalizeStyle4, normalizeClass as normalizeClass5, createElementVNode as createElementVNode3, renderSlot as renderSlot2 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Overlay/index.vue2.mjs
import { defineComponent as defineComponent4, ref as ref3, watch, createElementBlock as createElementBlock4, createCommentVNode as createCommentVNode3, unref as unref4, openBlock as openBlock4, normalizeStyle as normalizeStyle3, createElementVNode as createElementVNode2, withModifiers as withModifiers2, normalizeClass as normalizeClass4, renderSlot } from "vue";
var _sfc_main4 = defineComponent4({
  __name: "index",
  props: {
    visible: { type: Boolean, default: true },
    zIndex: { default: 9999 },
    useMask: { type: Boolean, default: true },
    maskColor: { default: "rgba(0, 0, 0, 0.6)" },
    isFullScreen: { type: Boolean, default: true },
    width: { default: "auto" },
    height: { default: "auto" }
  },
  emits: ["onOverlayClick"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const overlayDomRef = ref3();
    const isOverlayShow = ref3(props.visible);
    watch(() => props.visible, (visible) => {
      if (visible) {
        isOverlayShow.value = true;
      } else {
        setTimeout(() => {
          isOverlayShow.value = false;
        }, 150);
      }
    }, {
      immediate: true
    });
    function onOverlayClick() {
      emits("onOverlayClick");
    }
    __expose({
      overlayDomRef
    });
    return (_ctx, _cache) => {
      return unref4(isOverlayShow) ? (openBlock4(), createElementBlock4("div", {
        key: 0,
        ref_key: "overlayDomRef",
        ref: overlayDomRef,
        class: "overlay-container",
        style: normalizeStyle3({
          position: props.isFullScreen ? "fixed" : "absolute",
          zIndex: props.zIndex
        })
      }, [
        props.useMask ? (openBlock4(), createElementBlock4("div", {
          key: 0,
          class: normalizeClass4({
            "overlay-mask": true,
            "fade-in": props.visible
          }),
          style: normalizeStyle3({
            backgroundColor: props.maskColor
          }),
          onClick: onOverlayClick,
          onTouchstart: withModifiers2(onOverlayClick, ["prevent", "stop"])
        }, null, 38)) : createCommentVNode3("", true),
        createElementVNode2("div", {
          class: normalizeClass4({
            "overlay-content": true,
            "full-screen": props.isFullScreen
          })
        }, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ], 2)
      ], 4)) : createCommentVNode3("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Overlay/index.vue.mjs
var Overlay = _export_sfc(_sfc_main4, [["__scopeId", "data-v-7c386a69"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Drawer/index.vue2.mjs
var _hoisted_14 = { class: "drawer-container" };
var _sfc_main5 = defineComponent5({
  __name: "index",
  props: {
    visible: { type: Boolean, default: true },
    popDirection: { default: "bottom" },
    useMask: { type: Boolean, default: true },
    isFullScreen: { type: Boolean, default: true },
    overlayColor: {},
    drawerStyle: { default: () => ({}) }
  },
  emits: ["onOverlayClick"],
  setup(__props, { expose: __expose, emit: __emit }) {
    var _a3;
    const emits = __emit;
    const props = __props;
    const drawerDomRef = ref4();
    const overlayDomInstanceRef = ref4();
    const isDrawerShow = ref4(false);
    const styles = ref4(props.drawerStyle[props.popDirection] || {});
    watch2(() => props.visible, (visible) => {
      if (visible) {
        isDrawerShow.value = true;
      } else {
        setTimeout(() => {
          isDrawerShow.value = false;
        }, 150);
      }
    }, {
      immediate: true
    });
    function onOverlayClick(e) {
      emits("onOverlayClick", e);
    }
    __expose({
      drawerDomRef,
      overlayDomRef: (_a3 = overlayDomInstanceRef.value) == null ? void 0 : _a3.overlayDomRef
    });
    return (_ctx, _cache) => {
      return openBlock5(), createBlock(Overlay, {
        ref_key: "overlayDomInstanceRef",
        ref: overlayDomInstanceRef,
        visible: props.visible,
        useMask: props.useMask,
        maskColor: props.overlayColor,
        isFullScreen: props.isFullScreen,
        onOnOverlayClick: onOverlayClick
      }, {
        default: withCtx(() => [
          unref5(isDrawerShow) ? (openBlock5(), createElementBlock5("div", {
            key: 0,
            ref_key: "drawerDomRef",
            ref: drawerDomRef,
            class: normalizeClass5({
              "drawer": true,
              "origin-bottom": props.popDirection === "bottom",
              "origin-right": props.popDirection === "right",
              "slide-bottom": _ctx.visible && props.popDirection === "bottom",
              "slide-right": _ctx.visible && props.popDirection === "right"
            }),
            style: normalizeStyle4({
              minHeight: unref5(styles).minHeight,
              maxHeight: unref5(styles).maxHeight,
              borderRadius: unref5(styles).borderRadius,
              boxShadow: unref5(styles).boxShadow,
              width: unref5(styles).width
            })
          }, [
            createElementVNode3("div", _hoisted_14, [
              renderSlot2(_ctx.$slots, "default", {}, void 0, true)
            ])
          ], 6)) : createCommentVNode4("", true)
        ]),
        _: 3
      }, 8, ["visible", "useMask", "maskColor", "isFullScreen"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Drawer/index.vue.mjs
var Drawer = _export_sfc(_sfc_main5, [["__scopeId", "data-v-69f0b47f"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/close-dark.svg.mjs
var closeIcon = "data:image/svg+xml,%3csvg%20width='12'%20height='12'%20viewBox='0%200%2012%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M6.92904%206L11.815%201.11198C12.0617%200.86524%2012.0617%200.458461%2011.815%200.211725L11.7884%200.185051C11.5417%20-0.0616838%2011.1351%20-0.0616838%2010.8885%200.185051L6.0025%205.07974L1.11651%200.185051C0.869879%20-0.0616838%200.463269%20-0.0616838%200.216637%200.185051L0.189974%200.211725C-0.0633245%200.458461%20-0.0633245%200.86524%200.189974%201.11198L5.07596%206L0.189974%2010.888C-0.0566588%2011.1348%20-0.0566588%2011.5415%200.189974%2011.7883L0.216637%2011.8149C0.463269%2012.0617%200.869879%2012.0617%201.11651%2011.8149L6.0025%206.92692L10.8885%2011.8149C11.1351%2012.0617%2011.5417%2012.0617%2011.7884%2011.8149L11.815%2011.7883C12.0617%2011.5415%2012.0617%2011.1348%2011.815%2010.888L6.92904%206Z'%20fill='%238F959E'%20style='fill:%238F959E;fill:color(display-p3%200.5608%200.5843%200.6196);fill-opacity:1;'/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-group-application/index.vue2.mjs
var _hoisted_15 = {
  key: 0,
  class: "application-tips"
};
var _hoisted_24 = {
  class: normalizeClass6({
    "application-contaienr": true
  })
};
var _hoisted_32 = { class: "application-header" };
var _hoisted_4 = { key: 1 };
var _hoisted_5 = { class: "application-item-info" };
var _hoisted_6 = { class: "application-item-nick" };
var _hoisted_7 = { class: "application-item-note" };
var _hoisted_8 = { class: "application-item-operation" };
var _hoisted_9 = ["onClick"];
var _hoisted_10 = ["onClick"];
var _sfc_main6 = defineComponent6({
  __name: "index",
  props: {
    groupID: { default: "" }
  },
  setup(__props) {
    const props = __props;
    const drawerDomInstanceRef = ref5();
    const groupApplicationCount = ref5(0);
    const isGroupApplicationDrawerShow = ref5(false);
    const customGroupApplicationList = ref5([]);
    watch3(isGroupApplicationDrawerShow, (newVal) => {
      if (newVal) {
        generateCustomGroupApplicationList().then((list) => {
          customGroupApplicationList.value = list;
          groupApplicationCount.value = list.length;
        });
      }
    });
    watch3(() => customGroupApplicationList.value.length, (newVal, oldVal) => {
      if (oldVal > 0 && newVal === 0) {
        isGroupApplicationDrawerShow.value = false;
      }
    });
    async function getCurrentGroupApplicationList() {
      const result = await es.getGroupApplicationList();
      const currentGroupApplicationList = result.data.applicationList.filter((application) => application.groupID === props.groupID);
      return currentGroupApplicationList;
    }
    function toggleGroupApplicationDrawerShow() {
      isGroupApplicationDrawerShow.value = !isGroupApplicationDrawerShow.value;
    }
    async function generateCustomGroupApplicationList() {
      const applicationList = await getCurrentGroupApplicationList();
      if (applicationList.length === 0) {
        return [];
      }
      const userIDList = applicationList.map((application) => application.applicationType === 0 ? application.applicant : application.userID);
      const { data: userProfileList } = await Zt.getUserProfile({ userIDList });
      const mappingFromUserID2Profile = {};
      userProfileList.forEach((profile) => {
        mappingFromUserID2Profile[profile.userID] = profile;
      });
      const groupApplicationList = applicationList.map((application) => {
        const profile = mappingFromUserID2Profile[application.applicationType === 0 ? application.applicant : application.userID];
        return {
          nick: profile.nick || profile.userID || "anonymous",
          avatar: profile.avatar || "",
          isRemoved: false,
          application
        };
      });
      return groupApplicationList;
    }
    function handleApplication(customApplication, action, index3) {
      es.handleGroupApplication({
        handleAction: action,
        application: customApplication.application
      }).then(() => {
        customGroupApplicationList.value[index3].isRemoved = true;
        setTimeout(() => {
          customGroupApplicationList.value.splice(index3, 1);
          groupApplicationCount.value -= 1;
        }, 150);
      }).catch(() => {
      });
    }
    onMounted2(() => {
      getCurrentGroupApplicationList().then((applicationList) => {
        groupApplicationCount.value = applicationList.length;
      });
      Jt.watch(o.GRP, {
        groupSystemNoticeList: onGroupSystemNoticeListUpdated
      });
    });
    onUnmounted2(() => {
      Jt.unwatch(o.GRP, {
        groupSystemNoticeList: onGroupSystemNoticeListUpdated
      });
    });
    function onGroupSystemNoticeListUpdated() {
      generateCustomGroupApplicationList().then((list) => {
        customGroupApplicationList.value = list;
        groupApplicationCount.value = list.length;
      });
    }
    return (_ctx, _cache) => {
      return openBlock6(), createElementBlock6("div", null, [
        unref6(groupApplicationCount) > 0 ? (openBlock6(), createElementBlock6("div", _hoisted_15, [
          createElementVNode4("div", null, toDisplayString2(unref6(groupApplicationCount)) + toDisplayString2(unref6(Wt).t("TUIChat.条入群申请")), 1),
          createElementVNode4("div", {
            class: "application-tips-btn",
            onClick: toggleGroupApplicationDrawerShow
          }, toDisplayString2(unref6(Wt).t("TUIChat.点击处理")), 1)
        ])) : createCommentVNode5("", true),
        createVNode4(Drawer, {
          ref_key: "drawerDomInstanceRef",
          ref: drawerDomInstanceRef,
          visible: unref6(isGroupApplicationDrawerShow),
          zIndex: 998,
          popDirection: unref6(isMobile) ? "bottom" : "right",
          isFullScreen: unref6(isMobile),
          overlayColor: unref6(isMobile) ? void 0 : "transparent",
          drawerStyle: {
            bottom: {
              minHeight: "60vh",
              maxHeight: "80vh",
              borderRadius: "12px 12px 0 0"
            },
            right: {
              width: "360px",
              borderRadius: "12px 0 0 12px",
              boxShadow: "0 0 10px 0 #d0d0d0"
            }
          },
          onOnOverlayClick: toggleGroupApplicationDrawerShow
        }, {
          default: withCtx2(() => [
            createElementVNode4("div", _hoisted_24, [
              createElementVNode4("header", _hoisted_32, [
                createElementVNode4("div", { onClick: toggleGroupApplicationDrawerShow }, [
                  unref6(isPC) ? (openBlock6(), createBlock2(Icon, {
                    key: 0,
                    file: unref6(closeIcon),
                    size: "16px"
                  }, null, 8, ["file"])) : (openBlock6(), createElementBlock6("div", _hoisted_4, toDisplayString2(unref6(Wt).t("关闭")), 1))
                ])
              ]),
              createElementVNode4("main", null, [
                (openBlock6(true), createElementBlock6(Fragment3, null, renderList2(unref6(customGroupApplicationList), (item, index3) => {
                  return openBlock6(), createElementBlock6("div", {
                    key: item.nick,
                    class: normalizeClass6({
                      "application-item": true,
                      "removed": item.isRemoved
                    })
                  }, [
                    createVNode4(Avatar, {
                      style: {
                        flex: "0 0 auto"
                      },
                      url: item.avatar,
                      useSkeletonAnimation: true
                    }, null, 8, ["url"]),
                    createElementVNode4("div", _hoisted_5, [
                      createElementVNode4("div", _hoisted_6, toDisplayString2(item.nick), 1),
                      createElementVNode4("div", _hoisted_7, toDisplayString2(unref6(Wt).t("TUIChat.申请加入")), 1)
                    ]),
                    createElementVNode4("div", _hoisted_8, [
                      createElementVNode4("div", {
                        class: "agree",
                        onClick: ($event) => handleApplication(item, "Agree", index3)
                      }, toDisplayString2(unref6(Wt).t("TUIChat.同意")), 9, _hoisted_9),
                      createElementVNode4("div", {
                        class: "reject",
                        onClick: ($event) => handleApplication(item, "Reject", index3)
                      }, toDisplayString2(unref6(Wt).t("TUIChat.拒绝")), 9, _hoisted_10)
                    ])
                  ], 2);
                }), 128))
              ])
            ])
          ]),
          _: 1
        }, 8, ["visible", "popDirection", "isFullScreen", "overlayColor"])
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-group-application/index.vue.mjs
var MessageGroupApplication = _export_sfc(_sfc_main6, [["__scopeId", "data-v-f7281441"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-text.vue2.mjs
import { defineComponent as defineComponent7, ref as ref6, watchEffect, createElementBlock as createElementBlock7, openBlock as openBlock7, normalizeClass as normalizeClass7, unref as unref7, Fragment as Fragment4, renderList as renderList3, toDisplayString as toDisplayString3 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/emoji-config/custom-emoji.mjs
var CUSTOM_BIG_EMOJI_URL = "";
var CUSTOM_BIG_EMOJI_GROUP_LIST = [];

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/constant.mjs
var CHAT_MSG_CUSTOM_TYPE = {
  SERVICE: "consultion",
  EVALUATE: "evaluation",
  LINK: "text_link",
  CALL: 1,
  ORDER: "order"
};
var EMOJI_TYPE = {
  BASIC: "basic",
  BIG: "big",
  CUSTOM: "CUSTOM"
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/emoji-config/default-emoji.mjs
var _a2;
var _b2;
var DEFAULT_BASIC_EMOJI_URL = "https://web.sdk.qcloud.com/im/assets/emoji-plugin/";
var DEFAULT_BIG_EMOJI_URL = "https://web.sdk.qcloud.com/im/assets/face-elem/";
var DEFAULT_BASIC_EMOJI_URL_MAPPING = {
  "[TUIEmoji_Expect]": "emoji_0@2x.png",
  "[TUIEmoji_Blink]": "emoji_1@2x.png",
  "[TUIEmoji_Guffaw]": "emoji_2@2x.png",
  "[TUIEmoji_KindSmile]": "emoji_3@2x.png",
  "[TUIEmoji_Haha]": "emoji_4@2x.png",
  "[TUIEmoji_Cheerful]": "emoji_5@2x.png",
  "[TUIEmoji_Smile]": "emoji_6@2x.png",
  "[TUIEmoji_Sorrow]": "emoji_7@2x.png",
  "[TUIEmoji_Speechless]": "emoji_8@2x.png",
  "[TUIEmoji_Amazed]": "emoji_9@2x.png",
  "[TUIEmoji_Complacent]": "emoji_10@2x.png",
  "[TUIEmoji_Lustful]": "emoji_11@2x.png",
  "[TUIEmoji_Stareyes]": "emoji_12@2x.png",
  "[TUIEmoji_Giggle]": "emoji_13@2x.png",
  "[TUIEmoji_Daemon]": "emoji_14@2x.png",
  "[TUIEmoji_Rage]": "emoji_15@2x.png",
  "[TUIEmoji_Yawn]": "emoji_16@2x.png",
  "[TUIEmoji_TearsLaugh]": "emoji_17@2x.png",
  "[TUIEmoji_Silly]": "emoji_18@2x.png",
  "[TUIEmoji_Wail]": "emoji_19@2x.png",
  "[TUIEmoji_Kiss]": "emoji_20@2x.png",
  "[TUIEmoji_Trapped]": "emoji_21@2x.png",
  "[TUIEmoji_Fear]": "emoji_22@2x.png",
  "[TUIEmoji_BareTeeth]": "emoji_23@2x.png",
  "[TUIEmoji_FlareUp]": "emoji_24@2x.png",
  "[TUIEmoji_Tact]": "emoji_25@2x.png",
  "[TUIEmoji_Shit]": "emoji_26@2x.png",
  "[TUIEmoji_ShutUp]": "emoji_27@2x.png",
  "[TUIEmoji_Sigh]": "emoji_28@2x.png",
  "[TUIEmoji_Hehe]": "emoji_29@2x.png",
  "[TUIEmoji_Silent]": "emoji_30@2x.png",
  "[TUIEmoji_Skull]": "emoji_31@2x.png",
  "[TUIEmoji_Mask]": "emoji_32@2x.png",
  "[TUIEmoji_Beer]": "emoji_33@2x.png",
  "[TUIEmoji_Cake]": "emoji_34@2x.png",
  "[TUIEmoji_RedPacket]": "emoji_35@2x.png",
  "[TUIEmoji_Bombs]": "emoji_36@2x.png",
  "[TUIEmoji_Ai]": "emoji_37@2x.png",
  "[TUIEmoji_Celebrate]": "emoji_38@2x.png",
  "[TUIEmoji_Bless]": "emoji_39@2x.png",
  "[TUIEmoji_Flower]": "emoji_40@2x.png",
  "[TUIEmoji_Watermelon]": "emoji_41@2x.png",
  "[TUIEmoji_Cow]": "emoji_42@2x.png",
  "[TUIEmoji_Fool]": "emoji_43@2x.png",
  "[TUIEmoji_Surprised]": "emoji_44@2x.png",
  "[TUIEmoji_Askance]": "emoji_45@2x.png",
  "[TUIEmoji_Monster]": "emoji_46@2x.png",
  "[TUIEmoji_Pig]": "emoji_47@2x.png",
  "[TUIEmoji_Coffee]": "emoji_48@2x.png",
  "[TUIEmoji_Ok]": "emoji_49@2x.png",
  "[TUIEmoji_Heart]": "emoji_50@2x.png",
  "[TUIEmoji_Sun]": "emoji_51@2x.png",
  "[TUIEmoji_Moon]": "emoji_52@2x.png",
  "[TUIEmoji_Star]": "emoji_53@2x.png",
  "[TUIEmoji_Rich]": "emoji_54@2x.png",
  "[TUIEmoji_Fortune]": "emoji_55@2x.png",
  "[TUIEmoji_857]": "emoji_56@2x.png",
  "[TUIEmoji_666]": "emoji_57@2x.png",
  "[TUIEmoji_Prohibit]": "emoji_58@2x.png",
  "[TUIEmoji_Convinced]": "emoji_59@2x.png",
  "[TUIEmoji_Knife]": "emoji_60@2x.png",
  "[TUIEmoji_Like]": "emoji_61@2x.png"
};
var BIG_EMOJI_GROUP_LIST = [
  {
    emojiGroupID: 1,
    type: EMOJI_TYPE.BIG,
    url: DEFAULT_BIG_EMOJI_URL,
    list: [
      "yz00",
      "yz01",
      "yz02",
      "yz03",
      "yz04",
      "yz05",
      "yz06",
      "yz07",
      "yz08",
      "yz09",
      "yz10",
      "yz11",
      "yz12",
      "yz13",
      "yz14",
      "yz15",
      "yz16",
      "yz17"
    ]
  },
  {
    emojiGroupID: 2,
    type: EMOJI_TYPE.BIG,
    url: DEFAULT_BIG_EMOJI_URL,
    list: [
      "ys00",
      "ys01",
      "ys02",
      "ys03",
      "ys04",
      "ys05",
      "ys06",
      "ys07",
      "ys08",
      "ys09",
      "ys10",
      "ys11",
      "ys12",
      "ys13",
      "ys14",
      "ys15"
    ]
  },
  {
    emojiGroupID: 3,
    type: EMOJI_TYPE.BIG,
    url: DEFAULT_BIG_EMOJI_URL,
    list: [
      "gcs00",
      "gcs01",
      "gcs02",
      "gcs03",
      "gcs04",
      "gcs05",
      "gcs06",
      "gcs07",
      "gcs08",
      "gcs09",
      "gcs10",
      "gcs11",
      "gcs12",
      "gcs13",
      "gcs14",
      "gcs15",
      "gcs16"
    ]
  }
];
var BASIC_EMOJI_NAME_TO_KEY_MAPPING = {
  ...Object.fromEntries(
    (_a2 = Object.entries(Emoji2)) == null ? void 0 : _a2.map(([key, val]) => [val, key])
  ),
  ...Object.fromEntries(
    (_b2 = Object.entries(Emoji)) == null ? void 0 : _b2.map(([key, val]) => [val, key])
  )
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/emoji-config/index.mjs
var BASIC_EMOJI_URL = DEFAULT_BASIC_EMOJI_URL;
var BASIC_EMOJI_URL_MAPPING = DEFAULT_BASIC_EMOJI_URL_MAPPING;
var EMOJI_GROUP_LIST = [
  {
    emojiGroupID: 0,
    type: EMOJI_TYPE.BASIC,
    url: BASIC_EMOJI_URL,
    list: Object.keys(BASIC_EMOJI_URL_MAPPING)
  },
  ...BIG_EMOJI_GROUP_LIST,
  ...CUSTOM_BIG_EMOJI_GROUP_LIST
];
var convertKeyToEmojiName = (key) => {
  return isWeChat ? Emoji2[key] : Wt.t(`Emoji.${key}`);
};
var transformTextWithKeysToEmojiNames = (text) => {
  if (!text) {
    return "";
  }
  const reg = /(\[.+?\])/g;
  let txt = text;
  if (reg.test(text)) {
    txt = text.replace(reg, (match) => BASIC_EMOJI_URL_MAPPING[match] ? convertKeyToEmojiName(match) : match);
  }
  return txt;
};
var transformTextWithEmojiNamesToKeys = (text) => {
  if (!text) {
    return "";
  }
  const reg = /(\[.+?\])/g;
  let txt = text;
  if (reg.test(text)) {
    txt = text.replace(reg, (match) => BASIC_EMOJI_NAME_TO_KEY_MAPPING[match] || match);
  }
  return txt;
};
var emojiConfig = {
  emojiBaseUrl: BASIC_EMOJI_URL,
  emojiUrlMapping: BASIC_EMOJI_URL_MAPPING,
  emojiNameMapping: {
    ...Emoji2
  }
};
var parseTextToRenderArray = (text) => {
  const emojiRegex = /\[([^\]]+)\]/g;
  const result = [];
  let match;
  let lastIndex = 0;
  while ((match = emojiRegex.exec(text)) !== null) {
    const startIndex = match.index;
    const endIndex = emojiRegex.lastIndex;
    const emojiKey = match[0];
    if (startIndex > lastIndex) {
      result.push({ type: "text", content: text.substring(lastIndex, startIndex) });
    }
    const emojiUrl = BASIC_EMOJI_URL + BASIC_EMOJI_URL_MAPPING[emojiKey];
    if (emojiUrl) {
      result.push({ type: "image", content: emojiUrl, emojiKey });
    } else {
      result.push({ type: "text", content: emojiKey });
    }
    lastIndex = endIndex;
    emojiRegex.lastIndex = lastIndex;
  }
  if (lastIndex < text.length) {
    result.push({ type: "text", content: text.substring(lastIndex) });
  }
  return result;
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-text.vue2.mjs
var _hoisted_16 = {
  key: 0,
  class: "text"
};
var _hoisted_25 = ["src", "alt"];
var _sfc_main7 = defineComponent7({
  __name: "message-text",
  props: {
    content: { default: () => ({}) }
  },
  setup(__props) {
    const props = __props;
    const data = ref6();
    watchEffect(() => {
      var _a3;
      data.value = props.content;
      (_a3 = data.value.text) == null ? void 0 : _a3.forEach((item) => {
        if (item.name === "img" && (item == null ? void 0 : item.type) === "custom") {
          {
            console.warn("CUSTOM_BASIC_EMOJI_URL is required for custom emoji, please check your CUSTOM_BASIC_EMOJI_URL.");
          }
        }
      });
    });
    return (_ctx, _cache) => {
      return openBlock7(), createElementBlock7("div", {
        class: normalizeClass7(["message-text-container", unref7(isPC) && "text-select"])
      }, [
        (openBlock7(true), createElementBlock7(Fragment4, null, renderList3(unref7(data).text, (item, index3) => {
          return openBlock7(), createElementBlock7("span", { key: index3 }, [
            item.name === "text" ? (openBlock7(), createElementBlock7("span", _hoisted_16, toDisplayString3(item.text), 1)) : (openBlock7(), createElementBlock7("img", {
              key: 1,
              class: "emoji",
              src: item.src,
              alt: item.emojiKey
            }, null, 8, _hoisted_25))
          ]);
        }), 128))
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-text.vue.mjs
var MessageText = _export_sfc(_sfc_main7, [["__scopeId", "data-v-e3c6fedb"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-image.vue2.mjs
import { defineComponent as defineComponent8, ref as ref7, onMounted as onMounted3, watch as watch4, createElementBlock as createElementBlock8, openBlock as openBlock8, withModifiers as withModifiers3, createElementVNode as createElementVNode5, normalizeClass as normalizeClass8, unref as unref8 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/utils.mjs
function deepCopy(data, hash = /* @__PURE__ */ new WeakMap()) {
  if (typeof data !== "object" || data === null || data === void 0) {
    return data;
  }
  if (hash.has(data)) {
    return hash.get(data);
  }
  const newData = Object.create(Object.getPrototypeOf(data));
  const dataKeys = Object.keys(data);
  dataKeys.forEach((value) => {
    const currentDataValue = data[value];
    if (typeof currentDataValue !== "object" || currentDataValue === null) {
      newData[value] = currentDataValue;
    } else if (Array.isArray(currentDataValue)) {
      newData[value] = [...currentDataValue];
    } else if (currentDataValue instanceof Set) {
      newData[value] = /* @__PURE__ */ new Set([...currentDataValue]);
    } else if (currentDataValue instanceof Map) {
      newData[value] = new Map([...currentDataValue]);
    } else {
      hash.set(data, data);
      newData[value] = deepCopy(currentDataValue, hash);
    }
  });
  return newData;
}
var handleSkeletonSize = (width, height, maxWidth, maxHeight) => {
  const widthToHeight = width / height;
  const maxWidthToHeight = maxWidth / maxHeight;
  if (width <= maxWidth && height <= maxHeight) {
    return { width, height };
  }
  if (width <= maxWidth && height > maxHeight || width > maxWidth && height > maxHeight && widthToHeight <= maxWidthToHeight) {
    return { width: width * (maxHeight / height), height: maxHeight };
  }
  return { width: maxWidth, height: height * (maxWidth / width) };
};
var isCreateGroupCustomMessage = (message) => {
  var _a3;
  return message.type === qt.TYPES.MSG_CUSTOM && ((_a3 = message == null ? void 0 : message.getMessageContent()) == null ? void 0 : _a3.businessID) === "group_create";
};
function isEnabledMessageReadReceiptGlobal() {
  return Jt.getData(o.USER, "displayMessageReadReceipt") && Jt.getData(o.APP, "enabledMessageReadReceipt");
}
function shallowCopyMessage(message) {
  return Object.assign({}, message);
}
function calculateTimestamp(timestamp) {
  const todayZero = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
  const thisYear = new Date(
    (/* @__PURE__ */ new Date()).getFullYear(),
    0,
    1,
    0,
    0,
    0,
    0
  ).getTime();
  const target = new Date(timestamp);
  const oneDay = 24 * 60 * 60 * 1e3;
  const oneWeek = 7 * oneDay;
  const diff = todayZero - target.getTime();
  function formatNum(num) {
    return num < 10 ? "0" + num : num.toString();
  }
  if (diff <= 0) {
    return `${formatNum(target.getHours())}:${formatNum(target.getMinutes())}`;
  } else if (diff <= oneDay) {
    return `${Wt.t("time.昨天")} ${formatNum(
      target.getHours()
    )}:${formatNum(target.getMinutes())}`;
  } else if (diff <= oneWeek - oneDay) {
    const weekdays = [
      "星期日",
      "星期一",
      "星期二",
      "星期三",
      "星期四",
      "星期五",
      "星期六"
    ];
    const weekday = weekdays[target.getDay()];
    return `${Wt.t("time." + weekday)} ${formatNum(
      target.getHours()
    )}:${formatNum(target.getMinutes())}`;
  } else if (target.getTime() >= thisYear) {
    return `${target.getMonth() + 1}/${target.getDate()} ${formatNum(
      target.getHours()
    )}:${formatNum(target.getMinutes())}`;
  } else {
    return `${target.getFullYear()}/${target.getMonth() + 1}/${target.getDate()} ${formatNum(target.getHours())}:${formatNum(
      target.getMinutes()
    )}`;
  }
}

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-image.vue2.mjs
var _hoisted_17 = ["src", "width", "height"];
var _sfc_main8 = defineComponent8({
  __name: "message-image",
  props: {
    content: { default: () => ({}) },
    messageItem: { default: () => ({}) }
  },
  emits: ["previewImage"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const skeletonDomRef = ref7();
    onMounted3(() => {
      var _a3, _b3, _c2;
      if (((_a3 = props.messageItem) == null ? void 0 : _a3.status) === "success" || ((_b3 = props.messageItem) == null ? void 0 : _b3.status) === "fail" || ((_c2 = props.messageItem) == null ? void 0 : _c2.progress) === 1) {
        autoFixSkeletonSize();
      }
    });
    watch4(
      () => props.content.height,
      (newVal, oldVal) => {
        if (newVal > oldVal) {
          autoFixSkeletonSize();
        }
      }
    );
    function autoFixSkeletonSize() {
      var _a3, _b3, _c2;
      const { width = 0, height = 0 } = props.content;
      if (width === 0 || height === 0)
        return;
      const containerWidth = ((_a3 = document.getElementById("app")) == null ? void 0 : _a3.clientWidth) || 0;
      const max = !isPC ? Math.min(containerWidth - 180, 300) : 300;
      const size = handleSkeletonSize(width, height, max, max);
      ((_b3 = skeletonDomRef == null ? void 0 : skeletonDomRef.value) == null ? void 0 : _b3.style) && (skeletonDomRef.value.style.width = `${size.width}px`);
      ((_c2 = skeletonDomRef == null ? void 0 : skeletonDomRef.value) == null ? void 0 : _c2.style) && (skeletonDomRef.value.style.height = `${size.height}px`);
    }
    function toggleShow() {
      var _a3, _b3;
      if (((_a3 = props.messageItem) == null ? void 0 : _a3.status) === "success" || ((_b3 = props.messageItem) == null ? void 0 : _b3.progress) === 1) {
        emits("previewImage", props.messageItem);
      }
    }
    return (_ctx, _cache) => {
      return openBlock8(), createElementBlock8("div", {
        ref_key: "skeletonDomRef",
        ref: skeletonDomRef,
        class: "image-container",
        onClick: withModifiers3(toggleShow, ["self"])
      }, [
        createElementVNode5("img", {
          class: normalizeClass8(["message-image", !unref8(isPC) && "message-image-h5"]),
          src: props.content.url,
          width: props.content.width,
          height: props.content.height
        }, null, 10, _hoisted_17)
      ], 512);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-image.vue.mjs
var MessageImage = _export_sfc(_sfc_main8, [["__scopeId", "data-v-42bbcaf4"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-audio.vue2.mjs
import { defineComponent as defineComponent9, ref as ref8, onMounted as onMounted4, onUnmounted as onUnmounted3, watchEffect as watchEffect2, createElementBlock as createElementBlock9, openBlock as openBlock9, withModifiers as withModifiers4, normalizeClass as normalizeClass9, unref as unref9, createElementVNode as createElementVNode6, createVNode as createVNode5, normalizeStyle as normalizeStyle5, toDisplayString as toDisplayString4 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/msg-audio.svg.mjs
var audioIcon = "data:image/svg+xml,%3csvg%20width='62'%20height='78'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23prefix__clip0_1_7)'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M28%2039.5c0-6.638-2.558-12.755-7-17l5-5.5c5.936%205.662%209%2013.637%209%2022.5%200%208.604-3.364%2016.373-9%2022L21%2056c4.225-4.22%207-10.048%207-16.5zm18.025%2038.502L41%2073c8.457-8.442%2013.25-20.631%2013.25-33.54C54.25%2026.147%2048.925%2013.493%2040%205l5.084-5C55.503%209.91%2062%2023.924%2062%2039.46c0%2015.062-6.108%2028.694-15.975%2038.542zM7.75%2047.23c4.28%200%207.75-3.479%207.75-7.77%200-4.29-3.47-7.77-7.75-7.77-4.28%200-7.75%203.48-7.75%207.77%200%204.291%203.47%207.77%207.75%207.77z'%20fill='%23444'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='prefix__clip0_1_7'%3e%3cpath%20fill='%23fff'%20d='M0%200h62v78H0z'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-audio.vue2.mjs
var _hoisted_18 = { class: "audio-icon-container" };
var _hoisted_26 = ["src"];
var _sfc_main9 = defineComponent9({
  __name: "message-audio",
  props: {
    content: {
      type: Object,
      default: () => ({})
    },
    messageItem: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["setAudioPlayed"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const data = ref8();
    const message = ref8();
    const isAudioPlaying = ref8();
    const audioRef = ref8();
    onMounted4(() => {
      if (audioRef.value) {
        audioRef.value.addEventListener("ended", onAudioEnded);
        audioRef.value.addEventListener("pause", onAudioPaused);
      }
    });
    onUnmounted3(() => {
      if (audioRef.value) {
        audioRef.value.removeEventListener("ended", onAudioEnded);
        audioRef.value.removeEventListener("pause", onAudioPaused);
      }
    });
    watchEffect2(() => {
      message.value = props.messageItem;
      data.value = props.content;
    });
    function play() {
      if (message.value.hasRiskContent || !audioRef.value) {
        return;
      }
      if (!audioRef.value.paused) {
        audioRef.value.pause();
        audioRef.value.currentTime = 0;
        isAudioPlaying.value = false;
        return;
      }
      const audios = document.getElementsByTagName("audio");
      Array.from(audios).forEach((audio) => {
        if (!audio.paused) {
          audio.pause();
          audio.currentTime = 0;
        }
      });
      audioRef.value.play();
      isAudioPlaying.value = true;
      if (message.value.flow === "in") {
        emits("setAudioPlayed", message.value.ID);
      }
    }
    function onAudioEnded() {
      isAudioPlaying.value = false;
    }
    function onAudioPaused() {
      isAudioPlaying.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock9(), createElementBlock9("div", {
        class: normalizeClass9(["message-audio", [
          unref9(isMobile) && "message-audio-h5",
          unref9(message).flow === "out" && "reserve",
          unref9(message).hasRiskContent && "disable"
        ]]),
        onClick: withModifiers4(play, ["stop"])
      }, [
        createElementVNode6("div", _hoisted_18, [
          createElementVNode6("div", {
            class: normalizeClass9({ "mask": true, "play": unref9(isAudioPlaying) })
          }, null, 2),
          createVNode5(Icon, {
            class: "icon",
            width: "16px",
            height: "20px",
            file: unref9(audioIcon)
          }, null, 8, ["file"])
        ]),
        createElementVNode6("span", {
          class: "time",
          style: normalizeStyle5({ width: `${unref9(data).second * 10 + 20}px` })
        }, toDisplayString4(unref9(data).second || 1) + ' " ', 5),
        createElementVNode6("audio", {
          ref_key: "audioRef",
          ref: audioRef,
          src: unref9(data).url
        }, null, 8, _hoisted_26)
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-audio.vue.mjs
var MessageAudio = _export_sfc(_sfc_main9, [["__scopeId", "data-v-7c9f5c5e"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-record/index.vue2.mjs
import { defineComponent as defineComponent12, ref as ref10, createElementBlock as createElementBlock12, openBlock as openBlock12, createElementVNode as createElementVNode9, createBlock as createBlock3, createCommentVNode as createCommentVNode7, toDisplayString as toDisplayString7, Fragment as Fragment6, renderList as renderList5, unref as unref12, withCtx as withCtx4, createVNode as createVNode8 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/simple-message-list/index.vue2.mjs
import { defineComponent as defineComponent11, ref as ref9, watch as watch5, computed as computed3, createElementBlock as createElementBlock11, openBlock as openBlock11, normalizeClass as normalizeClass11, unref as unref11, createElementVNode as createElementVNode8, createCommentVNode as createCommentVNode6, createVNode as createVNode7, toDisplayString as toDisplayString6, Fragment as Fragment5, renderList as renderList4, withCtx as withCtx3 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/video-play.png.mjs
var playIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAABGCAYAAABxLuKEAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUY5QURCQ0E0RkI2MTFFNTk3QThDMzJBNTE2MDVFNEQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUY5QURCQzk0RkI2MTFFNTk3QThDMzJBNTE2MDVFNEQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkYzNEJFNkIxQTc0QjExRTM4NDk4RDBGMTA0RjRBQzUxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkYzNEJFNkIyQTc0QjExRTM4NDk4RDBGMTA0RjRBQzUxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+QQDPWgAABYNJREFUeNrknF9MW1Ucx09LBenkXyPsYSvZRib2weI6dNLNuSbGxZg+EsAlYHgxGBU0vvDmg4GgxmDUBx8IGpMRnkwQTcBEsrkKzD+VGdcRw2YdaERTnJNSSdf6/a3nLk0t/UN7zz339pt8sizd7r399vz5nnPPOSYmTiZwADSD/aAR7AM1oBJY+b8Lgy1wA6yBX8AqWAY/g7ioh1VTVeAEaAUuUFvg9f4CfvA18IG/9WQMXfNh4AXHgEWlZ4+CRfAJuFjsklRMY8rA4+AMsDOxug7Ogs/BLZmMoarSz9sOLUVt0dvgG62NqQfPgVNMLp0D74E/Cin+u9VJ8Dq4j8kn6v2eBL+CoChj7gLPgz5QzuRVOS/JFAe+AzE1jaGbjIDHmH7k4FGBuvd/1TCG2pNRcJjpTw3gOLjAA2TRjKnnrf0+pl/V8LB5PhdzcjGm1gCmJCfxNjAHIoUYQ6n1TdDEjKNq0AJmMjXI2Yyh3udRZjzVc4MWd2PMSd4lG1X3g2s75Zydku+94AOwhxlbm6AXrKd+YM5QhYxuCuPf8eV0H6Qz5iGdBbhCdYxnnIzGUNV6gZWenk31ItUYj5pzKfF4/NTU1JSjrq6uTDJj7Py7pzWGSssZtZ/A6/XuXVpaavV4PFWSmfN0cmeUbAxNRx4S8vPY7ZWzs7NHhoaG7CaTSRZjDnEP/mfMaZFPYbFYzIODg00+n8/Z2Ngoy/TF6VRj9qRrmUWora3N5vf7W9vb220SGHNciSnmpJSr2a9ms9nKJycnnWNjY00VFRVa1q1y7sUdY9xa/1TU1vT29tpRelxOp7NSw0dxK8YQD8rSAjocjqr5+fmj/f39ezV6hCPkCZlyENwjU79ptVoto6OjDo0yD7UxB8mYZlnjqIaZp9ksKrsUmHlcgjPP7RIj/ZQlMo9JcObZT8Y06GWkp2Sejo4OtTNPAxlTy3QkyjwTExNqZ54aMuZuvc0RCMg8lWSMVa+TKDzztKqQeaxmZgwVvUrRe6OwXktNIBC42dXVdRlZZ6vIlw5TiYnozZB4PM7Gx8evu1wuvwqmkLaoxNCCP5teTNnY2Nju6+u7gtF4SMXb3CBj1mVPv4oWFhZCnZ2dV4LB4LbKt1qnqrQmuyHRaDQ+MjKy4na7LwkwhbRKJeaqzKasrq5udXd3X56bm7sp8LbXyJhlWU2Znp7+vaen56dQKBQVfOtlqkr0YntTJkPC4fCtgYGBgNfrDWhgyqZSYmiNCC1DP2HwbJKryIuYkny/KoFskqtue6EYQ+vStrV6EsomKCWXMDBciUQiMQ1N2eZe3NkAQfWKlnt6DJxNcpFPaW+TB5EzorPJ8PCwyGySi2aSB5GKLvJMo3oK1iibZNNV7gFLLTG03+esiGzS0tLyrWSmMP7d4zvNY9DfP2Ti9xtpLdrv9AxLWt6aOlFFjr3LSk/vs5Q1v+lm8KienSshUxZ5b8SyGUOiTVDhEjCFvuNb6T4oy/Af/mTGXBWerDfAD/kYQ1phiZdxhw1qymfgo50+zLaSgPY300bQeoOZEgCvsgI2WcR4w0Qj72qDmEI7bV/J1obmsvaE3iJc4OZU6dyU38BLIOtEeq6LcsjdL8EjLLFTTK8hjvYN5LTlOJ/VSjTq/AI8wHS0QoLrR159cn7lku8yLtqFSscE0NI0h05M+Ri8lm8u2836thhPi0HeY8m695pK+DCYZHnuuU43iMxXVKXoCAPZtvGc5+l9fbcXKNYqAdrj9CKT49CLd1jSvIrWxijV8gnQxbQ5JmUCzDLJjklJvSZ1608xMQfrfAoWmMQH66RTNR+IHmWJFdfFOIrpe5Y4H4Zyla6OYsp0rwMsseDazlEO76Luv4KXAnqn9A//c41XE0Lo4V3/CTAAFPSPXCEbSD0AAAAASUVORK5CYII=";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/simple-message-list/message-container.vue2.mjs
import { defineComponent as defineComponent10, computed as computed2, createElementBlock as createElementBlock10, openBlock as openBlock10, createElementVNode as createElementVNode7, createVNode as createVNode6, toDisplayString as toDisplayString5, normalizeClass as normalizeClass10, unref as unref10, renderSlot as renderSlot3 } from "vue";
var _hoisted_19 = { class: "simple-message-container" };
var _hoisted_27 = { class: "simple-message-avatar" };
var _hoisted_33 = { class: "simple-message-sender" };
var _hoisted_42 = { class: "simple-message-body" };
var _hoisted_52 = { class: "timestamp" };
var _sfc_main10 = defineComponent10({
  __name: "message-container",
  props: {
    sender: { default: "" },
    avatar: { default: "" },
    type: {},
    time: {}
  },
  setup(__props) {
    const props = __props;
    const TYPES = qt.TYPES;
    const isNoPadding = computed2(() => {
      return [TYPES.MSG_IMAGE, TYPES.MSG_VIDEO, TYPES.MSG_MERGER].includes(props.type);
    });
    return (_ctx, _cache) => {
      return openBlock10(), createElementBlock10("div", _hoisted_19, [
        createElementVNode7("div", _hoisted_27, [
          createVNode6(Avatar, {
            url: props.avatar
          }, null, 8, ["url"])
        ]),
        createElementVNode7("div", null, [
          createElementVNode7("div", _hoisted_33, toDisplayString5(props.sender), 1),
          createElementVNode7("div", _hoisted_42, [
            createElementVNode7("div", {
              class: normalizeClass10({
                "simple-message-content": true,
                "no-padding": unref10(isNoPadding)
              })
            }, [
              renderSlot3(_ctx.$slots, "default", {}, void 0, true)
            ], 2),
            createElementVNode7("div", _hoisted_52, toDisplayString5(unref10(calculateTimestamp)(props.time * 1e3)), 1)
          ])
        ])
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/simple-message-list/message-container.vue.mjs
var MessageContainer = _export_sfc(_sfc_main10, [["__scopeId", "data-v-af167129"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/simple-message-list/index.vue2.mjs
var _hoisted_110 = { class: "header-container" };
var _hoisted_28 = { key: 0 };
var _hoisted_34 = { key: 1 };
var _hoisted_43 = { class: "title" };
var _hoisted_53 = { key: 0 };
var _hoisted_62 = {
  key: 0,
  class: "message-text"
};
var _hoisted_72 = {
  key: 0,
  class: "text"
};
var _hoisted_82 = ["src"];
var _hoisted_92 = {
  key: 1,
  class: "message-image"
};
var _hoisted_102 = ["src"];
var _hoisted_11 = {
  key: 2,
  class: "message-video"
};
var _hoisted_122 = ["onClick"];
var _hoisted_132 = ["src"];
var _hoisted_142 = ["poster"];
var _hoisted_152 = ["src"];
var _hoisted_162 = {
  key: 3,
  class: "message-audio"
};
var _hoisted_172 = {
  key: 4,
  class: "message-face"
};
var _hoisted_182 = ["src"];
var _hoisted_192 = {
  key: 5,
  class: "message-file"
};
var _hoisted_20 = { key: 6 };
var _hoisted_21 = ["onClickCapture"];
var _hoisted_222 = { key: 8 };
var _sfc_main11 = defineComponent11({
  __name: "index",
  props: {
    messageID: { default: "" },
    isMounted: { type: Boolean, default: false }
  },
  emits: ["closeOverlay"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const TYPES = qt.TYPES;
    const isDownloadOccurError = ref9(false);
    const messageListStack = ref9([]);
    const currentMergeMessageInfo = ref9({
      title: "",
      messageList: []
    });
    const simpleMessageListRef = ref9();
    watch5(() => messageListStack.value.length, async (newValue) => {
      isDownloadOccurError.value = false;
      if (newValue < 1) {
        return;
      }
      const stackTopMessageInfo = messageListStack.value[messageListStack.value.length - 1];
      if (stackTopMessageInfo.downloadKey && stackTopMessageInfo.messageList.length === 0) {
        try {
          const res = await Qt.downloadMergedMessages({
            payload: stackTopMessageInfo,
            type: qt.TYPES.MSG_MERGER
          });
          messageListStack.value[messageListStack.value.length - 1] = res.payload;
        } catch (error) {
          isDownloadOccurError.value = true;
        }
      }
      currentMergeMessageInfo.value = messageListStack.value[messageListStack.value.length - 1];
    });
    watch5(() => props.isMounted, (newValue) => {
      if (newValue) {
        if (!props.messageID) {
          throw new Error("messageID is required when first render of simple-message-list.");
        }
        const sdkMessagePayload = Jt.getMessageModel(props.messageID).getMessage().payload;
        messageListStack.value = [sdkMessagePayload];
      } else {
        messageListStack.value = [];
      }
    }, {
      immediate: true
    });
    const isReturn = computed3(() => {
      return messageListStack.value.length > 1;
    });
    const isMergeMessageInfoLoaded = computed3(() => {
      var _a3;
      return ((_a3 = currentMergeMessageInfo.value) == null ? void 0 : _a3.messageList) ? currentMergeMessageInfo.value.messageList.length > 0 : false;
    });
    function entryNextLevel(e, sdkMessage) {
      messageListStack.value.push(sdkMessage.messageBody[0].payload);
      e.stopPropagation();
    }
    function backPreviousLevel() {
      messageListStack.value.pop();
      if (messageListStack.value.length < 1) {
        emits("closeOverlay");
      }
    }
    function previewVideoInUniapp(url) {
      if (isUniFrameWork) {
        const encodedUrl = encodeURIComponent(url);
        uni.navigateTo({
          url: `/TUIKit/components/TUIChat/video-play?videoUrl=${encodedUrl}`
        });
      }
    }
    function resolveBigFaceUrl(bigFaceKey) {
      let url = "";
      if (bigFaceKey.indexOf("@custom") > -1) {
        url = CUSTOM_BIG_EMOJI_URL + bigFaceKey;
      } else {
        url = DEFAULT_BIG_EMOJI_URL + bigFaceKey;
        if (url.indexOf("@2x") === -1) {
          url += "@2x.png";
        } else {
          url += ".png";
        }
      }
      return url;
    }
    return (_ctx, _cache) => {
      return openBlock11(), createElementBlock11("div", {
        class: normalizeClass11({
          "simple-message-list-container": true,
          "simple-message-list-container-mobile": unref11(isMobile)
        })
      }, [
        createElementVNode8("div", _hoisted_110, [
          createElementVNode8("span", {
            class: "back",
            onClick: backPreviousLevel
          }, [
            createVNode7(Icon, {
              class: "close-icon",
              file: unref11(backIcon),
              size: "18px"
            }, null, 8, ["file"]),
            unref11(isReturn) ? (openBlock11(), createElementBlock11("span", _hoisted_28, toDisplayString6(unref11(Wt).t("TUIChat.返回")), 1)) : (openBlock11(), createElementBlock11("span", _hoisted_34, toDisplayString6(unref11(Wt).t("TUIChat.关闭")), 1))
          ]),
          createElementVNode8("span", _hoisted_43, toDisplayString6(unref11(currentMergeMessageInfo).title), 1)
        ]),
        unref11(isDownloadOccurError) ? (openBlock11(), createElementBlock11("div", _hoisted_53, " Load Merge Message Error ")) : unref11(isMergeMessageInfoLoaded) ? (openBlock11(), createElementBlock11("div", {
          key: 1,
          ref_key: "simpleMessageListRef",
          ref: simpleMessageListRef,
          class: "message-list"
        }, [
          (openBlock11(true), createElementBlock11(Fragment5, null, renderList4(unref11(currentMergeMessageInfo).messageList, (item) => {
            return openBlock11(), createElementBlock11("div", {
              key: item.ID,
              class: normalizeClass11({
                "message-item": true
              })
            }, [
              createVNode7(MessageContainer, {
                sender: item.nick,
                avatar: item.avatar,
                type: item.messageBody[0].type,
                time: item.time
              }, {
                default: withCtx3(() => [
                  item.messageBody[0].type === unref11(TYPES).MSG_TEXT ? (openBlock11(), createElementBlock11("div", _hoisted_62, [
                    (openBlock11(true), createElementBlock11(Fragment5, null, renderList4(unref11(parseTextToRenderArray)(item.messageBody[0].payload["text"]), (textInfo, index3) => {
                      return openBlock11(), createElementBlock11("span", {
                        key: index3,
                        class: "message-text-container"
                      }, [
                        textInfo.type === "text" ? (openBlock11(), createElementBlock11("span", _hoisted_72, toDisplayString6(textInfo.content), 1)) : (openBlock11(), createElementBlock11("img", {
                          key: 1,
                          class: "simple-emoji",
                          src: textInfo.content,
                          alt: "small-face"
                        }, null, 8, _hoisted_82))
                      ]);
                    }), 128))
                  ])) : item.messageBody[0].type === unref11(TYPES).MSG_IMAGE ? (openBlock11(), createElementBlock11("div", _hoisted_92, [
                    createElementVNode8("img", {
                      class: "image",
                      src: item.messageBody[0].payload["imageInfoArray"][2]["url"],
                      mode: "widthFix",
                      alt: "image"
                    }, null, 8, _hoisted_102)
                  ])) : item.messageBody[0].type === unref11(TYPES).MSG_VIDEO ? (openBlock11(), createElementBlock11("div", _hoisted_11, [
                    unref11(isUniFrameWork) ? (openBlock11(), createElementBlock11("div", {
                      key: 0,
                      onClick: ($event) => previewVideoInUniapp(item.messageBody[0].payload["remoteVideoUrl"])
                    }, [
                      createElementVNode8("image", {
                        class: "image",
                        src: item.messageBody[0].payload["thumbUrl"],
                        mode: "widthFix",
                        alt: "image"
                      }, null, 8, _hoisted_132),
                      createVNode7(Icon, {
                        class: "video-play-icon",
                        file: unref11(playIcon)
                      }, null, 8, ["file"])
                    ], 8, _hoisted_122)) : (openBlock11(), createElementBlock11("video", {
                      key: 1,
                      class: "video",
                      controls: "",
                      poster: item.messageBody[0].payload["thumbUrl"]
                    }, [
                      createElementVNode8("source", {
                        src: item.messageBody[0].payload["remoteVideoUrl"],
                        type: "video/mp4"
                      }, null, 8, _hoisted_152)
                    ], 8, _hoisted_142))
                  ])) : item.messageBody[0].type === unref11(TYPES).MSG_AUDIO ? (openBlock11(), createElementBlock11("div", _hoisted_162, [
                    createElementVNode8("span", null, toDisplayString6(unref11(Wt).t("TUIChat.语音")) + " ", 1),
                    createElementVNode8("span", null, toDisplayString6(item.messageBody[0].payload.second) + "s", 1)
                  ])) : item.messageBody[0].type === unref11(TYPES).MSG_FACE ? (openBlock11(), createElementBlock11("div", _hoisted_172, [
                    createElementVNode8("img", {
                      class: "image",
                      src: resolveBigFaceUrl(item.messageBody[0].payload.data),
                      alt: "face"
                    }, null, 8, _hoisted_182)
                  ])) : item.messageBody[0].type === unref11(TYPES).MSG_FILE ? (openBlock11(), createElementBlock11("div", _hoisted_192, toDisplayString6(unref11(Wt).t("TUIChat.[文件]")), 1)) : item.messageBody[0].type === unref11(TYPES).MSG_LOCATION ? (openBlock11(), createElementBlock11("div", _hoisted_20, toDisplayString6(unref11(Wt).t("TUIChat.[地理位置]")), 1)) : item.messageBody[0].type === unref11(TYPES).MSG_MERGER ? (openBlock11(), createElementBlock11("div", {
                    key: 7,
                    class: "message-merger",
                    onClickCapture: ($event) => entryNextLevel($event, item)
                  }, [
                    createVNode7(MessageRecord, {
                      disabled: "",
                      renderData: item.messageBody[0].payload
                    }, null, 8, ["renderData"])
                  ], 40, _hoisted_21)) : item.messageBody[0].type === unref11(TYPES).MSG_CUSTOM ? (openBlock11(), createElementBlock11("div", _hoisted_222, toDisplayString6(unref11(Wt).t("TUIChat.[自定义消息]")), 1)) : createCommentVNode6("", true)
                ]),
                _: 2
              }, 1032, ["sender", "avatar", "type", "time"])
            ]);
          }), 128))
        ], 512)) : createCommentVNode6("", true)
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/simple-message-list/index.vue.mjs
var SimpleMessageList = _export_sfc(_sfc_main11, [["__scopeId", "data-v-b1da437a"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-record/index.vue2.mjs
var _hoisted_111 = { class: "record-title" };
var _hoisted_29 = { class: "record-abstract-container" };
var _hoisted_35 = { class: "record-footer" };
var _sfc_main12 = defineComponent12({
  __name: "index",
  props: {
    renderData: {},
    disabled: { type: Boolean, default: false },
    messageItem: { default: () => ({}) }
  },
  emits: ["assignMessageIDInUniapp"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const isMessageListVisible = ref10(false);
    function openMergeDetail() {
      if (props.disabled) {
        return;
      }
      if (!isUniFrameWork) {
        isMessageListVisible.value = true;
      } else {
        emits("assignMessageIDInUniapp", props.messageItem.ID);
      }
    }
    function closeMergeDetail() {
      isMessageListVisible.value = false;
    }
    return (_ctx, _cache) => {
      return openBlock12(), createElementBlock12("div", null, [
        createElementVNode9("div", {
          class: "message-record-container",
          onClick: openMergeDetail
        }, [
          createElementVNode9("div", _hoisted_111, toDisplayString7(props.renderData.title), 1),
          createElementVNode9("div", _hoisted_29, [
            (openBlock12(true), createElementBlock12(Fragment6, null, renderList5(props.renderData.abstractList.slice(0, 7), (item, index3) => {
              return openBlock12(), createElementBlock12("div", {
                key: index3,
                class: "record-abstract-item"
              }, toDisplayString7(unref12(transformTextWithKeysToEmojiNames)(item)), 1);
            }), 128))
          ]),
          createElementVNode9("div", _hoisted_35, toDisplayString7(unref12(Wt).t("TUIChat.聊天记录")), 1)
        ]),
        !props.disabled && unref12(isPC) ? (openBlock12(), createBlock3(Overlay, {
          key: 0,
          visible: unref12(isMessageListVisible),
          onOnOverlayClick: _cache[0] || (_cache[0] = ($event) => isMessageListVisible.value = false)
        }, {
          default: withCtx4(() => [
            createVNode8(SimpleMessageList, {
              isMounted: unref12(isMessageListVisible),
              renderData: props.renderData,
              messageID: props.messageItem.ID,
              onCloseOverlay: closeMergeDetail
            }, null, 8, ["isMounted", "renderData", "messageID"])
          ]),
          _: 1
        }, 8, ["visible"])) : !props.disabled && unref12(isH5) && !unref12(isUniFrameWork) ? (openBlock12(), createBlock3(Drawer, {
          key: 1,
          visible: unref12(isMessageListVisible),
          isFullScreen: true,
          overlayColor: "transparent",
          popDirection: "right"
        }, {
          default: withCtx4(() => [
            createVNode8(SimpleMessageList, {
              isMounted: unref12(isMessageListVisible),
              renderData: props.renderData,
              messageID: props.messageItem.ID,
              onCloseOverlay: closeMergeDetail
            }, null, 8, ["isMounted", "renderData", "messageID"])
          ]),
          _: 1
        }, 8, ["visible"])) : createCommentVNode7("", true)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-record/index.vue.mjs
var MessageRecord = _export_sfc(_sfc_main12, [["__scopeId", "data-v-fed3549f"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-file.vue2.mjs
import { defineComponent as defineComponent13, createElementBlock as createElementBlock13, openBlock as openBlock13, unref as unref13, createVNode as createVNode9, createElementVNode as createElementVNode10, toDisplayString as toDisplayString8 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/file-light.svg.mjs
var fileIconLight = "data:image/svg+xml,%3csvg%20width='16'%20height='14'%20viewBox='0%200%2016%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%202'%20opacity='0.795169'%3e%3cpath%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20d='M0.5%202.25C0.5%201.2835%201.2835%200.5%202.25%200.5H6.54211C6.62301%200.5%206.70271%200.519631%206.77435%200.557208L8.63621%201.53374C8.85115%201.64647%209.09023%201.70536%209.33293%201.70536H13.75C14.7165%201.70536%2015.5%202.48886%2015.5%203.45536V11.75C15.5%2012.7165%2014.7165%2013.5%2013.75%2013.5H2.25C1.2835%2013.5%200.5%2012.7165%200.5%2011.75V2.25Z'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'%20/%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;_2'%20x='0.5'%20y='3.5'%20width='15'%20height='10'%20rx='1.75'%20stroke='%23232832'%20style='fill-opacity:1;stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'%20/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-file.vue2.mjs
var _hoisted_112 = ["title"];
var _sfc_main13 = defineComponent13({
  __name: "message-file",
  props: {
    content: { default: () => ({}) },
    messageItem: { default: () => ({}) }
  },
  setup(__props) {
    const props = __props;
    const download = () => {
      if (props.messageItem.hasRiskContent) {
        return;
      }
      const option = {
        mode: "cors",
        headers: new Headers({
          "Content-Type": "application/x-www-form-urlencoded"
        })
      };
      if (window == null ? void 0 : window.fetch) {
        fetch(props.content.url, option).then((res) => res.blob()).then((blob) => {
          const a = document.createElement("a");
          const url = window.URL.createObjectURL(blob);
          a.href = url;
          a.download = props.content.name;
          a.click();
        });
      } else {
        const a = document.createElement("a");
        a.href = props.content.url;
        a.target = "_blank";
        a.download = props.content.name;
        a.click();
      }
    };
    return (_ctx, _cache) => {
      return openBlock13(), createElementBlock13("div", {
        class: "file-message-montainer",
        title: unref13(Wt).t("TUIChat.单击下载"),
        onClick: download
      }, [
        createVNode9(Icon, {
          file: unref13(fileIconLight),
          class: "file-icon"
        }, null, 8, ["file"]),
        createElementVNode10("div", null, [
          createElementVNode10("div", null, toDisplayString8(props.content.name), 1),
          createElementVNode10("div", null, toDisplayString8(props.content.size), 1)
        ])
      ], 8, _hoisted_112);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-file.vue.mjs
var MessageFile = _export_sfc(_sfc_main13, [["__scopeId", "data-v-8cc5dd38"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-face.vue2.mjs
import { defineComponent as defineComponent14, ref as ref11, onMounted as onMounted5, createElementBlock as createElementBlock14, openBlock as openBlock14, createElementVNode as createElementVNode11, unref as unref14 } from "vue";
var _hoisted_113 = { class: "message-image" };
var _hoisted_210 = ["src"];
var _sfc_main14 = defineComponent14({
  __name: "message-face",
  props: {
    content: {
      type: Object,
      default: () => ({})
    }
  },
  setup(__props) {
    const props = __props;
    const url = ref11(props.content.url);
    onMounted5(() => {
      if (props.content.type === "custom") {
        {
          console.warn("CUSTOM_BIG_EMOJI_URL is required for custom emoji, please check your CUSTOM_BIG_EMOJI_URL.");
        }
      }
    });
    return (_ctx, _cache) => {
      return openBlock14(), createElementBlock14("div", _hoisted_113, [
        createElementVNode11("img", {
          mode: "aspectFit",
          class: "message-image",
          src: unref14(url)
        }, null, 8, _hoisted_210)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-face.vue.mjs
var MessageFace = _export_sfc(_sfc_main14, [["__scopeId", "data-v-35bb4072"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-custom.vue2.mjs
import { defineComponent as defineComponent15, ref as ref12, watchEffect as watchEffect3, createElementBlock as createElementBlock15, openBlock as openBlock15, unref as unref15, createElementVNode as createElementVNode12, createCommentVNode as createCommentVNode8, toDisplayString as toDisplayString9, Fragment as Fragment7, renderList as renderList6, createVNode as createVNode10 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/star-light.png.mjs
var starLightIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAABMCAYAAADHl1ErAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABaRSURBVHgBzVxrkB3FdT5n7t2rXbSrB3ojJCRAQgaKygsnEUVCYrvsJNgERSxQlBMIFafioMovJ3FVkv+p/IgrP5xKJY6xhCmVgaRsQmFXYlI28SNV2DwMBoIrMQ/JgLSS9qF9zUyfnO4+p/vM7BVaCbTrgdbMnenp6f76O9853T2zCMu4ERHyzqeCU0f2hZwLWTjVnJxJhIgEy7QVsEybAasjaYDTCqje+ksoX3wDymfeAHfsL8I5gB5kQFHuXZatC8u3WXb1QnJjd0H51J9B9VLMMXDdn0PvZ05DseGz5p4KIuuWZVsWhrXY5ZnlARuC+uSnoHoRoiXyVj7HRjj+KYDJjfBTwrLlMkkLmGf5ILgTd0L1g0tzFg8aS9b8D1ZBNXsXLDTNZdmW/MGGGf7ZHiwPhAfsT6B6hWF0OXnQaj4H4/eAZ2Bko2resrBsOXpqoTm6sdugfHYrBOdnEkqqfrSV84xCBHcAsldd8m1JATOMUFOMntGduA/q/4Fm9GBS9QLvTh+AbJZdaIYfS7YtB8PUpHyjPbv2Q/n0VqAWSGiOaZZBe/4SqE/dABE0BaxYarNcasAsw4RdY/dB+TKESIHquG8fe/Cq5/ncqT+GJss6sMQsWxLAPAuECao9hl0vb03ApFTBgnM040G7HuDUXmia5ZKybCkZpoBFsHyq3/q9GHdVwqgKMlh9QKs4LqsWsGxJtWwZATt5A5Sv7AF3CjJAHrgqH7dBCyx77nqox26AHJOFuGypWLZUgNkgNWpXPXsgeD8SvWKgyKcAWpl+gyYFtXyGf0/0ZdlSgHZBATPaZdnFDT25F0rWI3cyAJSBimCl31DG64l9HthpPv2sZ5nXskYgC0tgmhcUMJmGaWsXs2vmbpj9DgOjplhC2yRRWIZgWIY1RS17mn+P3wfNQHZJrOWCMwzanrEa38njw18nZlcKH0jNsGSQS4os8yDqvlImcg8oy56xWqZMu+BmuRS9ouyK2oXT99HstxkYzxYj8rInVyIISED9knrM7/uA1kf/FrAL7jEvGGCGXcYcT++AueduCdpFNRtslUEThiVgXClmKUlMFlG1jD1m/cPrg7dtBbIXkmUXBLA+Qi+zqeMHaO5bXovUC2L2ggY0UHMUDTNsiw6hjvo3/x0GbXY/9GHZhQLtPQfMgGVDCQ/WTpr37DrRDFIVIGqZZ/KYZTM2oxzUBh2snr+Fy74csgNogPZeA3degNmKyHGhCbLI60zqIITG8GzD3H+FBjNrKIm91yMXTRColaBtqgKWGWdSyWNMnD4gz+lB0zx16FRonW2C89i67wSKDwtaBTeODZv0mtWtaIZh4m/8Cpp/9haoT8RGOu/tjLmF5PiZfmaCwEcj/G/4Lxal82NyiOjXjsIe3atc5Ku3QGfNX/OjKlMXRVWmbsOme5I2kv0dbpQ2n2llqqvgtM6jAKLHFpB2KvqApQsb3Ounr4Bq6tMw+2TQHdThjjU/jLokq2iKCR8UjIgARqb+GB+BSqDy24jdyw4AzT3MwD0t7ZqXAmsDlsvo900KohKlAZoHEcWM+gEB0HTTnT4gCTgTl0E9dw2bynbu+W3c7dvYE14D9bFLyY8Vqx8DzftBNnu+IObz3Bs5kg/ezzMsESKW7gEhBgdRgnkciFgUPT43wDkHeN8jKPi4cx1n28x5Nvp8P4Ri0zgDy2OvzmtcyAvQ6b4GsPp1aLLOmeMzgegMcM4DNtBiBhpwzLm5NcyU7VBU13IFruEyVvOE3l5yx1ehK1fx3q/wcHWOQRhQU3tArQI+D1Hky8C2JmDaBsMkBYxTBMhXlxODBNgLIPI5psUAk9KfE/nye9zAiRWhWMdphI9531n5AuCq15m9L0CBDCIwiAMshKvGDSOpBWZKHrCLYrf5NMugcKxUuGvB0fbIlNlrwE1t46h6FdXHI9PrMb51koubW1Bm0CHwplcboDwgJT+qxABS8oxmSBRmVus4hx/5LzQTH1J0AwgRFE29vPfVFwaiBU37HE3fh/wewGE+tZb3F/t7J3jPYA6Oc5N4j89DZ4AFEjmtPimVrBmwmcugmvgkVG/eyeuC28iD4IGpGBRSUHSLwhslWdXGQZAbAQzNbClRk2HQAMqEC5yfsA4sS+IudomBWUVsfBFDOizEAQcWCWgJSA9q1zCt/QZCezCA2eCCePYUwLgvfFo5AZ0Nj0Gn92mk+Z8cpokv3w7VUWjeqT1NBi6KHR+OspmjsksAIzIzpxJT+TGi946BoQlAGQ55RpJMReeaR5YFszQapqA1GDaQ9U1BQw0BzWsbaOUaoqe1gDXAI7ku1fHADf/2410o37gd5o8ANHrXaB5l4DD8VuAsaNEUA1jJtCJgfvgTBs1kx4hmrKhxVeG4OJdqTNIw9M/XdhJKFQXMtr/C3FitWwTORdCoxTDCPkCZa9ZHequrj9/QZc2f5AqPJMDIrgtmN5/OC3Bk8pFhGChTnETjAagadLizYLBNUe+o9mA56QgwsRb/cpRDbM5G/prz5tqOhhY6uFi3IkpFwywhM0xvBewPmObDgckurtjy97Dy5/+Upr4LC7wsZY1SsBqAWm+MApaCJhpmxT8BRxVkjfP65e9R0GMtUQLTxBSPZwENVhA01SjUTRd/fXmeXdQJpkhgYzdsgWVB6meynAZ5nN9Z+5UudDcehuEbNrCG3ENT34Lm+qDtKalII1g2+VKj6+QpGwsaiVGVmK4Z4mjHeHY5MhZSRFhQ9MRpW3KjyB4pUIHlXQGrI6ZbCMhNwLDBKnstPj8cD/0SwEW/fD8L/z91Qys6m+6Hlb/aQ1ffRVPflEaYUAFSg7w64MJ4z5ikhjIKHrQBqgTQCtphTzZzjBbpn+Yb4fUaa9CRDIqPBtXUQvgWGKYz1nXcC8Ni45uDkoBvA7zCsEzyDvFM+ODeBxmsz/tCu9FGYA4GNh6EkV/r8hzU7TT5n6HBebgSG0WgomxZ1w6Y8wuD6jEJFi7QatnYBl+wIFIv6c2RjCVWfjQk4Ei7wnV5JnayKYKAZRhmQSNrcqQM9I5G8l90IwN245cYm0MQh1qlB4zX4WWEP7DpCzDyIeTIfZQm/j0PV6i1hE+5gtETZRZmECIjIjPqBphkQCWrkZAZlnWkMGBRBIJyLm/CGOrSlY6IphjY0jLHBsMMSMooDyBqzLbyJgbspocYEw/WaU4zHisFLLuP3uaDsOY3veaMwqnHxZxq6POqqQAawcvBK4UgNIq/nEMLlmgd2pkJAQ2l6ELgSKhA3lBul/BHwcbQPTxYV7EXE6Sgg22wihiweHdLhTFRGRUOf5DThx6G7mYP1gSnKQVNAQOwAcrA5kO45mau/PwonXpUTKttbi6FHWhCkGReAkhiZAts3zAVeQ0lUJFxKA5GEFTvrF6wAAkPKXWcc46jjCJ0bhodGB5E9mS9Ij8TQhZAyT/yYWbXR/qBNa0Mm899Z/qxd8lBuPhWLoxBO/FlSPqD4tWwTowCpMYxGI9KRMa79glHcssxD7li43RWTIQqs80fFqL2QdSV7b7hHdFJ4xntJLCaYl+wfouZdfPD0NtykE9MSpqS5Ik1r6JvSa+bg97Wg7juNj8bOgonHomm6YRp6IxJWmZJ+zlyj3NKBkQpVhkT60zRMkGw04NCG0QSZ2LuVtLwQ8uVaD64S7VpzAwKlAQxSzCgmUB21cc43cJgbVVmtcHyqYpK2X8TTdt2EDfc6eOnURj7EuTpYSfCbwJXyCBA7W0ggpRZlodXOQiOTSNKUCegMHmtGK2rLoYpn1QyYTwXBVum91AZhWQBEwCdnhPAVrElrfkdFvhLD7WYpWLvZyBCUKlT1HULKMhI8NbbfhDX38W/2HsePww6uxC9p5gkKXOENXI+ObhCitRwQB4RPV20PMxnBEUwoi9RawCrjuz1op3MHbNu6fS1Dm/CVDY2zFBZhmv2AawdZbC2Wc2aNGDNQ47AqctK6WTWVaPJOcj2k3VtcMdB3HS3B2vUHfsipGEQUGYaUgxuKX6sERBP2q1jRIgDaoUsgSJDHZlSj84g6g9ZANBHgyjDSEUzekJSJwMRoCT0Lub1Y/vIQhdirQjWXQ8xIawZtsEqIUfXFBgmoCk4FZxp6+04hBt/389AjNKxB8BG9SRsCuWgDM4Tq3RMmLeIE7bO+KIQFYR0j4LsvWAiqMQWaepdBV28IKhXlM6QawoWrOXlzIsDWAehqVnBGwpxbDwV5vTTqpGslpBBU6ra2gZ3Hiw2fYIJ4xi0g2BjMqCWwDtqlII2phIQM1MAGtYYkNNAQ/2lizMUAkA4lhkLSrEWZPBQ9QoCSLEv+feaUZ6tvpsj+O1tge9nhgksv28vs1l3VprfzZBjcOch2PwJ34BR9/b9YMecnglU2GJM4aIn+igUMslpjSoijNF7Nh5PUgiiCRMge9Oc04Ca4i4nmnU7wPp7PFgaOqhuTRuwdMXJtZfbGoDpRYpRKgjKWivLOioGr2DQPukrwkz7PKQgVUFL5mQ9nsU+Fhl1W5HE7Dg0q9yfZiyUdQItuSKvY4p+CbISX2nN+fpaBmvdvQzWjrYZtpmlEfaCre9Crpin3lCCeazNxkz7YrH5jwqOs/dH0NR4aIF3I2hOPyNmxqSpCSwwlYFqSibUsJ0dZjIwdFJeQtQ1zDRFCzoQxTV38BT9vQ8zWA9Ajq9U4ENQClng4UwLuQWcYZMbFOlSCvS9MC0PCT2DQ1c+2Nn8h0/BwJYcjySLNGalJ2WIQzrU8f9HrUNd+baJUl5zzck4FKhP/gi4xnjh384mBux3vwe9nQ8asNoCX0pbvYt3Z8LlHT//M45AQVOQ7fsTA+TqIZh/W4MtyEtuyYBa5eoUt/VwkAiBGsnKpaRLfT1tZmDzKmaPWh3j48ka85hQ9UrBSnHW2T5ePev3kn1CDs80++7ELM28tCNOAzu5R6SZnGAham4lxjQs5Khj2JCGTCBM4cKKAkkJFbZCM5hgRd0FYBo1AOZxZFEe3QFDodNnDViNoBQWsS3qA1OjaQjNF+nneeF3kHtwZYjAqRDL0GGRDxbjCIDQ8Ilyg7Ow+51LjQ0s04jLxbtR8zoNJySgRTAm6PPmqRwdWLv51zYW1ekedFeW0Jw/VzNcFGAFLHJraZo+0EF94nKY+zGk2U1dS7RLYnlYGWZPoa1VTkzYybhQdc3nE72Kepi1L2tgXOIjxcwMh0BGT/79DJh/jc+d3mjqrkp7Tt+QLxow2WxoEX47V15J868CyNQw2pUZyAJMMsOQHIJpcDBgFycBUY/DHtIiEDiS43gfGiciVp9YFh+MYF8ZQb+SX89e2WqLhlGw2O18vvlOD4LApXpLXY5FwGQmVdcCEyhhFBBvbUbAWqDItzOXCVKMmzRQA1KNMMJPjMwESG9GpZglrW2yVJSvcfZyV+Oxzaq8dxrWKli7Lqwy8BzZ7kh3XamJ0XVauTaRuAmqco1J9YpymIX2OqWYNoGuZg8AaZpRA9sklKpxwvjqBIM2vhV7hnbQ6L9FbecDmJl14zT3f7uifpllLRBWYR8+qemYSynEQPFziio1aAbNMYeLABUmvzAbzT1xMSRWF+tju6D/38dY9LZoDWt9qy1pZjVVYyOqXc0XPrKnikJMwbulCUTRIVRHqXoUhN5qE2Xhd/kaqDuV8yjOApM2Krq5ylQe2cJ1XgPv4nObcxV9fUDspXJiD86/TgkomfWML8H55hbZJGVok9TICr8HIThKap1jhXLZKST1dJTzynkiva5TOWBAkw6cf4PTxKUA52+W5wtYAM252T00+zrml9WKIMINgCjJdWowJvePGQQzVErDHAEjjukj+xTAHHqYoJjkZi0ncRdjWFT59+LKq6D51cgFByzZHAfgl1B9EmQtH+wyVjJFAMhTLUXTDar0iAmFFbSwppJDCDvmhAQcZeCcAAsKYusRLj0fofLWUO3uA9iiQTsX0W+wyydeGLkq0NzgqLOoUddNXSg3ynrKxDY5GbUS022pJeIo4uAHhMCxsDTalaAtx6GUJy09aOVJxGr8Kl7n70Cz8+PYFc+O27kwzIhBDCtw+qVd8YqaHZqsrVuNqSJiCjqaOiOAd0aMeTYTZtOLMW8I/Zw4kHw+OwXQKsaj+uQu6K9hi2LZuQJmZirYQ7rZEcss0myiH3HaFFLj1SPG60UOFey27mbAax89EdK6j2azTvdl80TKy3Yq+uggecxs8mKqfl8eGRFP2VwaX+S2KJM0IUUGrZ7YA7OvxLCIctutyMdONtqGkFZwQGMvzT/yc4CX/dU0XvS+r8Dg5f8RTq68di9c8gcfo6P/uJ7GHmvcZs06vuEDENdvjeNQbesoahA9ZXlqDwwMHYEM2qK3c9WwzLBqfg/NvRFqgjmMgrQ+RGg8o5ikruYlBvLmgdp87zSuuemrvGj8OHQGJ0Cnh1dc9jVOX8fB3fthwx030pHPrMep78e2q4kHtmF4dSBpWWF7MIOHPC6B0n++U3lP+Q04j1hssYC1AhofP7it6GaSVKRwofH8dl3i7UGUh3/WAvUYA+XdbWMyD/T7gaFdh7C76Qlced0ojT1yI/3kc4Dlm5DWKyEzW54SFzdBXldQh+F3nmHkLoGmSWoieI8AgxZgXXATuyl4yPYzqKEd6RZhH/R4unjLvYAb9n0ThrY+xOv0vpBZk/RLB0iA+W+WBlbNwMDVf4tDlz6E6/bfRmP/ciO8+TlmzFvJ3NM6idergqJuBVKL56TIMKomr5Ix5Tl7yvM1yQLmX9+VAaJWNoDGO6Q+sO0MA67fD7jxjhdZox6G3uanIc9+zrQAqxcAJrO7UKyahZWrPoNDBxi4fftp7F9/hd76AjPurfTmQJzNQGiMW4lAF2iwHNsN5i+rQNMk6F0BZj5F1j3r1+QacnMjyRulp+BC0+QQAdfvY0aNMlA7PVDPQDS9aQOWvvBRtgDTrxNmBTQFeEiA+zscWPsNdhgfpxNf2wFvPxA7yXrf5KVleOUdd3l0GKvJ1dAdGYemWbqzwHFOGpZBw9ndMPOjZg4yWTGKO5sO69THj8GKy/+BTfFZyEyaNvs5SQtWmyEzoCd5Vpj8MfU2/zf0PvIcDl39QVz3G7fSmw9spPEnpE5ohB/ygZeSamoPA3a01bZ3z7DWFguu5/bEr0csveR53iyG93qdOg1DVx2CFdueMEDNGLBmDVBtsLTSOqqoIa8bzhvAfBlD4Xhw+79x+joOve8DOPPyPjp2eAONP5lBs3XluTGegvVm+QRcoLDCktx7nWEoBiG5dYhqRRddC8X6fadh+BfZ821kz7fyeB+gtKEWKLvabENOgLyGoMDJVxINpvnyLgrHK9jjcidxKHIzbvrfD7ujn92IM6806gq1rw4Mt9q4qNDiXBimDXHQHXwKh3YBTX0vMApWXs2ryh89jcO/8FXobvIhgg92Zlpp1jTQfveXX9SHhQsSslplF1/af07FsjQDN7j9Eehd/N1i5998AMafvJWOH2bLmIwaO/J+bvnqR02bFh2HnTWjiL7+KQVP/5GQZo/cDuWr90I9PQJDVzwB3S0PMVDj0oC257Ory1bYz7rS3KpHa3iWF5Mh6pt8Yx4cxJCkFeCmtkD59ihMPf9+Zv4UDG47DANb/xnyiyj6XkV9thWkxQKW/6Jc7EEP2jDkL/m70njVFwuSXTBVoNILaueyxNUaomm91JPKH0IK9VTABiXpXxlwkD20voRyWs6VGP6KyDtv/w+ON+CUxoCEhwAAAABJRU5ErkJggg==";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-custom.vue2.mjs
var _hoisted_114 = { class: "custom" };
var _hoisted_211 = { key: 0 };
var _hoisted_36 = ["href"];
var _hoisted_44 = { key: 0 };
var _hoisted_54 = ["href"];
var _hoisted_63 = { key: 1 };
var _hoisted_73 = {
  key: 1,
  class: "evaluate"
};
var _hoisted_83 = { class: "evaluate-list" };
var _hoisted_93 = ["src"];
var _hoisted_103 = {
  key: 3,
  class: "textLink"
};
var _hoisted_115 = ["href"];
var _hoisted_123 = ["innerHTML"];
var _sfc_main15 = defineComponent15({
  __name: "message-custom",
  props: {
    messageItem: { default: void 0 },
    content: { default: void 0 }
  },
  setup(__props) {
    const props = __props;
    const custom = ref12();
    const message = ref12();
    const extension = ref12();
    const isCustom = ref12({
      businessID: ""
    });
    watchEffect3(() => {
      custom.value = props.content;
      message.value = props.messageItem;
      const { payload } = props.messageItem;
      isCustom.value = payload.data || "";
      isCustom.value = JSONToObject(payload.data);
      if (payload.data === CHAT_MSG_CUSTOM_TYPE.SERVICE) {
        extension.value = JSONToObject(payload.extension);
      }
    });
    const openLink = (url) => {
      window.open(url);
    };
    return (_ctx, _cache) => {
      return openBlock15(), createElementBlock15("div", _hoisted_114, [
        unref15(isCustom).businessID === unref15(CHAT_MSG_CUSTOM_TYPE).SERVICE ? (openBlock15(), createElementBlock15("div", _hoisted_211, [
          createElementVNode12("h1", null, [
            createElementVNode12("label", null, toDisplayString9(unref15(extension).title), 1),
            unref15(extension).hyperlinks_text ? (openBlock15(), createElementBlock15("a", {
              key: 0,
              href: unref15(extension).hyperlinks_text.value,
              target: "view_window"
            }, toDisplayString9(unref15(extension).hyperlinks_text.key), 9, _hoisted_36)) : createCommentVNode8("", true)
          ]),
          unref15(extension).item && unref15(extension).item.length > 0 ? (openBlock15(), createElementBlock15("ul", _hoisted_44, [
            (openBlock15(true), createElementBlock15(Fragment7, null, renderList6(unref15(extension).item, (item, index3) => {
              return openBlock15(), createElementBlock15("li", { key: index3 }, [
                unref15(isUrl)(item.value) ? (openBlock15(), createElementBlock15("a", {
                  key: 0,
                  href: item.value,
                  target: "view_window"
                }, toDisplayString9(item.key), 9, _hoisted_54)) : (openBlock15(), createElementBlock15("p", _hoisted_63, toDisplayString9(item.key), 1))
              ]);
            }), 128))
          ])) : createCommentVNode8("", true),
          createElementVNode12("article", null, toDisplayString9(unref15(extension).description), 1)
        ])) : unref15(isCustom).businessID === unref15(CHAT_MSG_CUSTOM_TYPE).EVALUATE ? (openBlock15(), createElementBlock15("div", _hoisted_73, [
          createElementVNode12("h1", null, toDisplayString9(unref15(Wt).t("message.custom.对本次服务评价")), 1),
          createElementVNode12("ul", _hoisted_83, [
            (openBlock15(true), createElementBlock15(Fragment7, null, renderList6(Math.max(unref15(isCustom).score, 0), (item, index3) => {
              return openBlock15(), createElementBlock15("li", {
                key: index3,
                class: "evaluate-list-item"
              }, [
                createVNode10(Icon, {
                  file: unref15(starLightIcon),
                  class: "file-icon"
                }, null, 8, ["file"])
              ]);
            }), 128))
          ]),
          createElementVNode12("article", null, toDisplayString9(unref15(isCustom).comment), 1)
        ])) : unref15(isCustom).businessID === unref15(CHAT_MSG_CUSTOM_TYPE).ORDER ? (openBlock15(), createElementBlock15("div", {
          key: 2,
          class: "order",
          onClick: _cache[0] || (_cache[0] = ($event) => openLink(unref15(isCustom).link))
        }, [
          createElementVNode12("img", {
            src: unref15(isCustom).imageUrl
          }, null, 8, _hoisted_93),
          createElementVNode12("main", null, [
            createElementVNode12("h1", null, toDisplayString9(unref15(isCustom).title), 1),
            createElementVNode12("p", null, toDisplayString9(unref15(isCustom).description), 1),
            createElementVNode12("span", null, toDisplayString9(unref15(isCustom).price), 1)
          ])
        ])) : unref15(isCustom).businessID === unref15(CHAT_MSG_CUSTOM_TYPE).LINK ? (openBlock15(), createElementBlock15("div", _hoisted_103, [
          createElementVNode12("p", null, toDisplayString9(unref15(isCustom).text), 1),
          createElementVNode12("a", {
            href: unref15(isCustom).link,
            target: "view_window"
          }, toDisplayString9(unref15(Wt).t("message.custom.查看详情>>")), 9, _hoisted_115)
        ])) : (openBlock15(), createElementBlock15("span", {
          key: 4,
          innerHTML: _ctx.content.custom
        }, null, 8, _hoisted_123))
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-custom.vue.mjs
var MessageCustom = _export_sfc(_sfc_main15, [["__scopeId", "data-v-a34fa3a9"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-tip.vue2.mjs
import { defineComponent as defineComponent16, computed as computed4, createElementBlock as createElementBlock16, openBlock as openBlock16, createElementVNode as createElementVNode13, toDisplayString as toDisplayString10, unref as unref16 } from "vue";
var _hoisted_116 = { class: "message-tip" };
var _sfc_main16 = defineComponent16({
  __name: "message-tip",
  props: {
    content: {
      type: Object,
      default: () => ({})
    }
  },
  setup(__props) {
    const props = __props;
    const tipContent = computed4(() => {
      var _a3, _b3;
      return ((_a3 = props.content) == null ? void 0 : _a3.text) || ((_b3 = props.content) == null ? void 0 : _b3.custom) || "";
    });
    return (_ctx, _cache) => {
      return openBlock16(), createElementBlock16("div", _hoisted_116, [
        createElementVNode13("span", null, toDisplayString10(unref16(tipContent)), 1)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-tip.vue.mjs
var MessageTip = _export_sfc(_sfc_main16, [["__scopeId", "data-v-893dcf07"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-bubble.vue2.mjs
import { defineComponent as defineComponent25, toRefs as toRefs2, computed as computed8, createElementBlock as createElementBlock25, openBlock as openBlock25, normalizeClass as normalizeClass19, unref as unref25, createBlock as createBlock6, createCommentVNode as createCommentVNode15, createElementVNode as createElementVNode19, createVNode as createVNode13, withModifiers as withModifiers5, toDisplayString as toDisplayString17, Fragment as Fragment9, renderSlot as renderSlot4 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/read-status/index.vue2.mjs
import { defineComponent as defineComponent17, ref as ref13, onMounted as onMounted6, onUnmounted as onUnmounted4, computed as computed5, withDirectives, createElementBlock as createElementBlock17, openBlock as openBlock17, normalizeClass as normalizeClass12, unref as unref17, createElementVNode as createElementVNode14, toDisplayString as toDisplayString11, vShow } from "vue";
var _sfc_main17 = defineComponent17({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  emits: ["openReadUserPanel"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const ReadStatus2 = ChatConfig.getFeatureConfig("ReadStatus");
    const TYPES = qt.TYPES;
    const isDisplayMessageReadReceipt = ref13(Jt.getData(o.USER, "displayMessageReadReceipt"));
    onMounted6(() => {
      Jt.watch(o.USER, {
        displayMessageReadReceipt: onDisplayMessageReadReceiptUpdate
      });
    });
    onUnmounted4(() => {
      Jt.unwatch(o.USER, {
        displayMessageReadReceipt: onDisplayMessageReadReceiptUpdate
      });
    });
    const isShowReadStatus = computed5(() => {
      if (!ReadStatus2) {
        return false;
      }
      if (!isDisplayMessageReadReceipt.value) {
        return false;
      }
      const {
        ID,
        type,
        flow,
        status,
        hasRiskContent,
        conversationID,
        conversationType,
        needReadReceipt = false
      } = props.message;
      if (hasRiskContent) {
        return false;
      }
      const { groupProfile } = Jt.getConversationModel(conversationID) || {};
      if ((groupProfile == null ? void 0 : groupProfile.type) === TYPES.GRP_AVCHATROOM || (groupProfile == null ? void 0 : groupProfile.type) === TYPES.GRP_COMMUNITY) {
        return false;
      }
      if (type === TYPES.MSG_CUSTOM) {
        const message = Jt.getMessageModel(ID);
        if ((message == null ? void 0 : message.getSignalingInfo()) !== null) {
          return false;
        }
      }
      if (flow !== "out" || status !== "success") {
        return false;
      }
      if (conversationType === "GROUP") {
        return needReadReceipt;
      } else if (conversationType === "C2C") {
        return true;
      }
      return false;
    });
    const readState = computed5(() => {
      const { conversationType, needReadReceipt = false, isPeerRead = false } = props.message;
      const { readCount = 0, unreadCount = 0, isPeerRead: isReceiptPeerRead = false } = props.message.readReceiptInfo;
      if (conversationType === "C2C") {
        if (needReadReceipt) {
          return isReceiptPeerRead ? 0 : 1;
        } else {
          return isPeerRead ? 0 : 1;
        }
      } else if (conversationType === "GROUP") {
        if (needReadReceipt) {
          if (readCount === 0) {
            return 1;
          } else if (unreadCount === 0) {
            return 2;
          } else {
            return 4;
          }
        } else {
          return 3;
        }
      }
      return 1;
    });
    const readStatusText = computed5(() => {
      const { readCount = 0 } = props.message.readReceiptInfo;
      switch (readState.value) {
        case 0:
          return Wt.t("TUIChat.已读");
        case 1:
          return Wt.t("TUIChat.未读");
        case 2:
          return Wt.t("TUIChat.全部已读");
        case 4:
          return `${readCount}${Wt.t("TUIChat.人已读")}`;
        default:
          return "";
      }
    });
    const isUseUnreadStyle = computed5(() => {
      const { conversationType } = props.message;
      if (conversationType === "C2C") {
        return readState.value !== 0;
      } else if (conversationType === "GROUP") {
        return readState.value !== 2;
      }
      return false;
    });
    const isHoverFingerPointer = computed5(() => {
      return props.message.needReadReceipt && props.message.conversationType === "GROUP" && (readState.value === 4 || readState.value === 1);
    });
    function openReadUserPanel() {
      if (isHoverFingerPointer.value) {
        emits("openReadUserPanel");
      }
    }
    function onDisplayMessageReadReceiptUpdate(isDisplay) {
      isDisplayMessageReadReceipt.value = isDisplay;
    }
    return (_ctx, _cache) => {
      return withDirectives((openBlock17(), createElementBlock17("div", {
        class: normalizeClass12({
          "message-label": true,
          "unread": unref17(isUseUnreadStyle),
          "finger-point": unref17(isHoverFingerPointer)
        }),
        onClick: openReadUserPanel
      }, [
        createElementVNode14("span", null, toDisplayString11(unref17(readStatusText)), 1)
      ], 2)), [
        [vShow, unref17(isShowReadStatus)]
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/read-status/index.vue.mjs
var ReadStatus = _export_sfc(_sfc_main17, [["__scopeId", "data-v-085f4d59"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-quote/index.vue2.mjs
import { defineComponent as defineComponent19, ref as ref15, computed as computed7, onMounted as onMounted8, createElementBlock as createElementBlock19, createCommentVNode as createCommentVNode10, unref as unref19, openBlock as openBlock19, normalizeClass as normalizeClass14, toDisplayString as toDisplayString13 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Toast/index.vue2.mjs
import { defineComponent as defineComponent18, ref as ref14, watch as watch6, computed as computed6, onMounted as onMounted7, createBlock as createBlock4, openBlock as openBlock18, Transition, withCtx as withCtx5, withDirectives as withDirectives2, createElementVNode as createElementVNode15, normalizeStyle as normalizeStyle6, normalizeClass as normalizeClass13, unref as unref18, createElementBlock as createElementBlock18, createCommentVNode as createCommentVNode9, toDisplayString as toDisplayString12, vShow as vShow2 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Toast/type.mjs
var TOAST_TYPE = {
  SUCCESS: "success",
  WARNING: "warning",
  ERROR: "error",
  NORMAL: "normal"
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Toast/index.vue2.mjs
var _hoisted_117 = { key: 0 };
var _hoisted_212 = { key: 1 };
var _sfc_main18 = defineComponent18({
  __name: "index",
  props: {
    message: {
      type: String,
      default: ""
    },
    duration: {
      type: Number,
      default: 3e3
    },
    repeatNum: {
      type: Number,
      default: 1
    },
    id: {
      type: String,
      default: ""
    },
    onClose: {
      type: Function,
      required: false
    },
    offset: {
      type: Number,
      default: 20
    },
    zIndex: {
      type: Number,
      default: 0
    },
    type: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    const props = __props;
    const visible = ref14(false);
    let timer;
    const startTimer = () => {
      if (props.duration > 0) {
        timer = setTimeout(() => {
          if (visible.value) {
            close3();
          }
        }, props.duration);
      }
    };
    const clearTimer = () => {
      clearTimeout(timer);
    };
    const close3 = () => {
      visible.value = false;
      if (typeof props.onClose === "function") {
        props.onClose();
      }
    };
    watch6(
      () => props.repeatNum,
      () => {
        clearTimer();
        startTimer();
      }
    );
    const customStyle = computed6(() => ({
      top: `${props.offset}px`,
      zIndex: props.zIndex
    }));
    onMounted7(() => {
      startTimer();
      visible.value = true;
    });
    const handleStyle = (type) => {
      if (type && (type === TOAST_TYPE.ERROR || type === TOAST_TYPE.SUCCESS || type === TOAST_TYPE.WARNING))
        return type;
      return TOAST_TYPE.NORMAL;
    };
    return (_ctx, _cache) => {
      return openBlock18(), createBlock4(Transition, {
        name: "fade",
        onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("destroy"))
      }, {
        default: withCtx5(() => [
          withDirectives2(createElementVNode15("div", {
            class: normalizeClass13(["message", [handleStyle(__props.type), unref18(isH5) && "message-h5"]]),
            style: normalizeStyle6(unref18(customStyle))
          }, [
            !unref18(isH5) ? (openBlock18(), createElementBlock18("p", _hoisted_117, toDisplayString12(__props.message), 1)) : createCommentVNode9("", true),
            unref18(isH5) ? (openBlock18(), createElementBlock18("span", _hoisted_212, toDisplayString12(__props.message), 1)) : createCommentVNode9("", true)
          ], 6), [
            [vShow2, unref18(visible)]
          ])
        ]),
        _: 1
      });
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Toast/index.vue.mjs
var MessageConstructor = _export_sfc(_sfc_main18, [["__scopeId", "data-v-165fcf08"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Toast/index.mjs
var instances = [];
var seed = 1;
var vueVersionInt = Math.trunc(vueVersion);
var appendTo = document.body;
var Toast = function(options) {
  var _a3;
  let verticalOffset = options.offset || 20;
  instances.forEach(({ vm: vm2 }) => {
    var _a22, _b3;
    verticalOffset += (((_a22 = vm2 == null ? void 0 : vm2.el) == null ? void 0 : _a22.offsetHeight) || ((_b3 = vm2 == null ? void 0 : vm2.$el) == null ? void 0 : _b3.offsetHeight) || 0) + 20;
  });
  verticalOffset += 20;
  const id = `message_${seed += 1}`;
  const userOnClose = options.onClose;
  const props = {
    zIndex: 20 + seed,
    offset: verticalOffset,
    id,
    ...options,
    onClose: () => {
      Toast.close(id, userOnClose);
    }
  };
  let vm;
  let container;
  switch (vueVersionInt) {
    case 2:
      const Vue2 = (_a3 = i) == null ? void 0 : _a3.Vue;
      if (!Vue2) {
        return {};
      }
      const Constructor = Vue2.extend(MessageConstructor);
      const instance = new Constructor({ propsData: props });
      instance.$mount();
      appendTo.appendChild(instance.$el);
      instance.$el.style.zIndex = props.zIndex;
      instance.verticalOffset = props.verticalOffset;
      instance.visible = true;
      instances.push({ vm: instance });
      return {
        close: () => {
          instance.visible = false;
        }
      };
    case 3:
      vm = createVNode2(MessageConstructor, props);
      container = document.createElement("div");
      (vm == null ? void 0 : vm.props) && (vm.props.onDestroy = () => {
        render2(null, container);
      });
      (vm == null ? void 0 : vm.data) && (vm.data.onDestroy = () => {
        render2(null, container);
      });
      render2(vm, container);
      instances.push({ vm });
      appendTo.appendChild(container.firstElementChild);
      return {
        close: () => {
          var _a22;
          ((_a22 = vm == null ? void 0 : vm.component) == null ? void 0 : _a22.proxy) && (vm.component.proxy.visible = false);
        }
      };
  }
  return {};
};
function close(id, userOnClose) {
  var _a3, _b3, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  const idx = instances == null ? void 0 : instances.findIndex(
    ({ vm: vm2 }) => {
      var _a22, _b22, _c22;
      return id === ((_b22 = (_a22 = vm2 == null ? void 0 : vm2.component) == null ? void 0 : _a22.props) == null ? void 0 : _b22.id) || id === ((_c22 = vm2 == null ? void 0 : vm2._props) == null ? void 0 : _c22.id);
    }
  );
  if (idx === -1)
    return;
  const { vm } = instances[idx];
  if (!vm)
    return;
  userOnClose == null ? void 0 : userOnClose(vm);
  const removedHeight = ((_a3 = vm == null ? void 0 : vm.el) == null ? void 0 : _a3.offsetHeight) || ((_b3 = vm == null ? void 0 : vm.$el) == null ? void 0 : _b3.offsetHeight);
  instances.splice(idx, 1);
  const len = instances.length;
  if (len < 1)
    return;
  for (let i2 = idx; i2 < len; i2++) {
    const pos = Number.parseInt(
      ((_f2 = (_e2 = (_d2 = (_c2 = instances[i2]) == null ? void 0 : _c2.vm) == null ? void 0 : _d2.el) == null ? void 0 : _e2.style) == null ? void 0 : _f2.top) || ((_j = (_i = (_h = (_g = instances[i2]) == null ? void 0 : _g.vm) == null ? void 0 : _h.$el) == null ? void 0 : _i.style) == null ? void 0 : _j.top),
      10
    ) - removedHeight - 16;
    ((_n = (_m = (_l = (_k = instances[i2]) == null ? void 0 : _k.vm) == null ? void 0 : _l.component) == null ? void 0 : _m.props) == null ? void 0 : _n.offset) && (instances[i2].vm.component.props.offset = pos);
    ((_q = (_p = (_o = instances[i2]) == null ? void 0 : _o.vm) == null ? void 0 : _p._props) == null ? void 0 : _q.offset) && (instances[i2].vm._props.offset = pos);
  }
}
Toast.close = close;

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-quote/interface.mjs
var MessageQuoteTypeEnum = ((MessageQuoteTypeEnum2) => {
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_NONE"] = 0] = "TYPE_NONE";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_TEXT"] = 1] = "TYPE_TEXT";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_CUSTOM"] = 2] = "TYPE_CUSTOM";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_IMAGE"] = 3] = "TYPE_IMAGE";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_SOUND"] = 4] = "TYPE_SOUND";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_VIDEO"] = 5] = "TYPE_VIDEO";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_FILE"] = 6] = "TYPE_FILE";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_LOCATION"] = 7] = "TYPE_LOCATION";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_FACE"] = 8] = "TYPE_FACE";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_GROUP_TIPS"] = 9] = "TYPE_GROUP_TIPS";
  MessageQuoteTypeEnum2[MessageQuoteTypeEnum2["TYPE_MERGER"] = 10] = "TYPE_MERGER";
  return MessageQuoteTypeEnum2;
})(MessageQuoteTypeEnum || {});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-quote/index.vue2.mjs
var _hoisted_118 = {
  key: 0,
  class: "revoked-text"
};
var _hoisted_213 = {
  key: 1,
  class: "max-double-line"
};
var _sfc_main19 = defineComponent19({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  emits: ["scrollTo", "blinkMessage"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    let selfAddValue = 0;
    const messageQuoteText = ref15("");
    const hasQuoteContent = ref15(false);
    const messageQuoteContent = ref15({});
    const isMessageRevoked = computed7(() => {
      var _a3;
      try {
        const cloudCustomData = JSON.parse(((_a3 = props.message) == null ? void 0 : _a3.cloudCustomData) || "{}");
        const quotedMessageModel = Jt.getMessageModel(cloudCustomData.messageReply.messageID);
        return quotedMessageModel == null ? void 0 : quotedMessageModel.isRevoked;
      } catch (error) {
        return true;
      }
    });
    onMounted8(() => {
      var _a3;
      try {
        const cloudCustomData = JSON.parse(((_a3 = props.message) == null ? void 0 : _a3.cloudCustomData) || "{}");
        hasQuoteContent.value = Boolean(cloudCustomData.messageReply);
        if (hasQuoteContent.value) {
          messageQuoteContent.value = cloudCustomData.messageReply;
          messageQuoteText.value = performQuoteContent(messageQuoteContent.value);
        }
      } catch (error) {
        hasQuoteContent.value = false;
      }
    });
    function performQuoteContent(params) {
      let messageKey = "";
      let quoteContent = "";
      switch (params.messageType) {
        case MessageQuoteTypeEnum.TYPE_TEXT:
          messageKey = "[文本]";
          break;
        case MessageQuoteTypeEnum.TYPE_CUSTOM:
          messageKey = "[自定义消息]";
          break;
        case MessageQuoteTypeEnum.TYPE_IMAGE:
          messageKey = "[图片]";
          break;
        case MessageQuoteTypeEnum.TYPE_SOUND:
          messageKey = "[音频]";
          break;
        case MessageQuoteTypeEnum.TYPE_VIDEO:
          messageKey = "[视频]";
          break;
        case MessageQuoteTypeEnum.TYPE_FILE:
          messageKey = "[文件]";
          break;
        case MessageQuoteTypeEnum.TYPE_LOCATION:
          messageKey = "[地理位置]";
          break;
        case MessageQuoteTypeEnum.TYPE_FACE:
          messageKey = "[动画表情]";
          break;
        case MessageQuoteTypeEnum.TYPE_GROUP_TIPS:
          messageKey = "[群提示]";
          break;
        case MessageQuoteTypeEnum.TYPE_MERGER:
          messageKey = "[聊天记录]";
          break;
        default:
          messageKey = "[消息]";
          break;
      }
      if ([
        MessageQuoteTypeEnum.TYPE_TEXT,
        MessageQuoteTypeEnum.TYPE_MERGER
      ].includes(params.messageType)) {
        quoteContent = params.messageAbstract;
      }
      return quoteContent ? quoteContent : Wt.t(`TUIChat.${messageKey}`);
    }
    async function scrollToOriginalMessage() {
      var _a3;
      if (isMessageRevoked.value) {
        return;
      }
      const originMessageID = (_a3 = messageQuoteContent.value) == null ? void 0 : _a3.messageID;
      const currentMessageList = Jt.getData(o.CHAT, "messageList");
      const isOriginalMessageInScreen = currentMessageList.some((msg) => msg.ID === originMessageID);
      if (originMessageID && isOriginalMessageInScreen) {
        try {
          const scrollViewRect = await T("#messageScrollList", "messageList");
          const originalMessageRect = await T("#tui-" + originMessageID, "messageList");
          const { scrollTop } = await P("#messageScrollList", "messageList");
          const finalScrollTop = originalMessageRect.top + scrollTop - scrollViewRect.top - selfAddValue++ % 2;
          const isNeedScroll = originalMessageRect.top < scrollViewRect.top;
          if (!isUniFrameWork && window) {
            const scrollView = document.getElementById("messageScrollList");
            if (isNeedScroll && scrollView) {
              scrollView.scrollTop = finalScrollTop;
            }
          } else if (isUniFrameWork && isNeedScroll) {
            emits("scrollTo", finalScrollTop);
          }
          emits("blinkMessage", originMessageID);
        } catch (error) {
          console.error(error);
        }
      } else {
        Toast({
          message: Wt.t("TUIChat.无法定位到原消息"),
          type: TOAST_TYPE.WARNING
        });
      }
    }
    return (_ctx, _cache) => {
      return unref19(hasQuoteContent) ? (openBlock19(), createElementBlock19("div", {
        key: 0,
        class: normalizeClass14({
          "reference-content": true,
          "reverse": _ctx.message.flow === "out"
        }),
        onClick: scrollToOriginalMessage
      }, [
        unref19(isMessageRevoked) ? (openBlock19(), createElementBlock19("div", _hoisted_118, toDisplayString13(unref19(Wt).t("TUIChat.引用内容已撤回")), 1)) : (openBlock19(), createElementBlock19("div", _hoisted_213, toDisplayString13(unref19(messageQuoteContent).messageSender) + ": " + toDisplayString13(unref19(transformTextWithKeysToEmojiNames)(unref19(messageQuoteText))), 1))
      ], 2)) : createCommentVNode10("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-quote/index.vue.mjs
var MessageQuote = _export_sfc(_sfc_main19, [["__scopeId", "data-v-42086ba9"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-translate/index.vue2.mjs
import { defineComponent as defineComponent21, ref as ref17, onMounted as onMounted9, onUnmounted as onUnmounted5, createElementBlock as createElementBlock21, createCommentVNode as createCommentVNode12, unref as unref21, openBlock as openBlock21, normalizeClass as normalizeClass16, createVNode as createVNode11, createElementVNode as createElementVNode17, toDisplayString as toDisplayString15 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-translate/translation-content.vue2.mjs
import { defineComponent as defineComponent20, ref as ref16, watch as watch7, nextTick, createElementBlock as createElementBlock20, openBlock as openBlock20, normalizeStyle as normalizeStyle7, unref as unref20, createCommentVNode as createCommentVNode11, createElementVNode as createElementVNode16, normalizeClass as normalizeClass15, Fragment as Fragment8, renderList as renderList7, toDisplayString as toDisplayString14, createTextVNode } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/translation.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _Translator = class _Translator2 {
  constructor() {
    __publicField(this, "isUseCache", true);
    __publicField(this, "translationCache", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    if (!_Translator2.instance) {
      _Translator2.instance = new _Translator2();
    }
    return _Translator2.instance;
  }
  async get(message) {
    if (this.isUseCache) {
      const cache = this.translationCache.get(message.ID);
      if (cache !== void 0) {
        return cache;
      }
    }
    const currentMessage = Jt.getMessageModel(message.ID);
    if (!currentMessage) {
      return [];
    }
    const { text } = currentMessage.getMessageContent() || {};
    const textList = [];
    const splittingList = await this.getNickList(currentMessage);
    for (let i2 = 0; i2 < text.length; ++i2) {
      const item = text[i2];
      if (item.name === "img") {
        textList.push({ type: "face", value: item.src });
        continue;
      }
      const { transSplitingList, atNickList } = this.getSplitResult(item.text, splittingList);
      for (let j = 0; j < transSplitingList.length; ++j) {
        textList.push({ type: "text", value: transSplitingList[j] });
        if (j < atNickList.length) {
          textList.push({ type: "mention", value: atNickList[j] });
        }
      }
    }
    const needTranslateTextIndex = [];
    const needTranslateText = textList.filter((item, index3) => {
      if (item.type === "text" && item.value.trim() !== "") {
        needTranslateTextIndex.push(index3);
        return true;
      }
      return false;
    }).map((item) => item.value);
    if (needTranslateText.length === 0) {
      this.translationCache.set(currentMessage.ID, textList);
      return textList;
    }
    const translationResult = await this.getTranslationStandard(needTranslateText);
    translationResult.forEach((item, index3) => {
      textList[needTranslateTextIndex[index3]].value = item;
    });
    this.translationCache.set(currentMessage.ID, textList);
    return textList;
  }
  /**
   * Clears the translation cache.
   */
  clear() {
    this.translationCache.clear();
  }
  disableCache() {
    this.isUseCache = false;
  }
  enableCache() {
    this.isUseCache = true;
  }
  getTranslationStandard(originTextList) {
    return new Promise((resolve, reject) => {
      Qt.translateText({
        sourceTextList: originTextList,
        sourceLanguage: "auto"
      }).then((response) => {
        const {
          data: { translatedTextList }
        } = response;
        resolve(translatedTextList);
      }).catch((error) => {
        reject(error);
      });
    });
  }
  /**
   * the nick list is used to split the text by @ + {nick or userID}
   * @param message
   * @returns e.g. ['@james', '@john']
   */
  async getNickList(message) {
    const splittingList = [];
    const { atUserList = [] } = message;
    const atAllID = qt.TYPES.MSG_AT_ALL;
    if (atUserList.includes(atAllID)) {
      splittingList.push(`@${Wt.t("TUIChat.所有人")}`);
    }
    if (atUserList.length > 0) {
      const { data: userProfileList } = await Zt.getUserProfile({ userIDList: atUserList });
      userProfileList.forEach((user) => {
        const atNick = `@${user.nick || user.userID}`;
        splittingList.push(atNick);
      });
    }
    return [...new Set(splittingList)];
  }
  /**
   * Splits the given text into substrings based on the provided splitString array.
   *
   * @param {string} text - The text to be split.
   * @param {string[]} splitString - The array of strings to split the text by.
   * @return {{ transSplitingList: string[]; atNickList: string[] }} - An object containing two arrays:
   *   - transSplitingList: An array of substrings extracted from the text.
   *   - atNickList: An array of split strings that were found in the text.
   */
  getSplitResult(text, splitString) {
    let searchStartPos = 0;
    const transSplitingList = [];
    const atNickList = [];
    while (searchStartPos < text.length) {
      const nextAtCharPos = text.indexOf("@", searchStartPos);
      if (nextAtCharPos === -1) {
        transSplitingList.push(text.substring(searchStartPos));
        break;
      }
      let found2 = false;
      for (let i2 = 0; i2 < splitString.length; ++i2) {
        const pos = text.indexOf(splitString[i2], nextAtCharPos);
        if (pos !== -1 && pos === nextAtCharPos) {
          transSplitingList.push(text.substring(searchStartPos, pos));
          atNickList.push(splitString[i2]);
          searchStartPos = pos + splitString[i2].length;
          found2 = true;
          break;
        }
      }
      if (!found2) {
        transSplitingList.push(text.substring(searchStartPos));
        break;
      }
    }
    return {
      transSplitingList,
      atNickList
    };
  }
};
__publicField(_Translator, "instance");
var Translator = _Translator;
var translator = Translator.getInstance();

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-translate/translation-content.vue2.mjs
var _hoisted_119 = ["src"];
var _hoisted_214 = {
  key: 1,
  class: "text-plain"
};
var _sfc_main20 = defineComponent20({
  __name: "translation-content",
  props: {
    message: { default: () => ({}) },
    translationContentVisible: { type: Boolean },
    isSingleTranslation: { type: Boolean },
    translationWrapperRef: {}
  },
  emits: ["toggleErrorStatus"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const translationFinished = ref16(false);
    const translationErrorText = ref16("");
    const translationTextList = ref16([]);
    const calculateHeight = ref16(0);
    const calculateWidth = ref16(0);
    const translationLoadingRef = ref16();
    const translationContentRef = ref16();
    watch7(() => props.translationContentVisible, (newVal) => {
      if (newVal) {
        translator.get(props.message).then((result) => {
          translationFinished.value = true;
          translationTextList.value = result;
          nextTick(() => {
            const { height: originHeight, width: originWidth } = C(translationLoadingRef.value);
            const { height, width } = C(translationContentRef.value);
            calculateHeight.value = originHeight;
            calculateWidth.value = originWidth;
            requestAnimationFrame(() => {
              calculateHeight.value = height;
              calculateWidth.value = width;
              if (props.isSingleTranslation) {
                nextTick(() => {
                  const { bottom } = C(props.translationWrapperRef);
                  const { bottom: bottomWindow } = C("#messageScrollList");
                  if (bottom > bottomWindow) {
                    const timer = setTimeout(() => {
                      props.translationWrapperRef.scrollIntoView({ block: "end", behavior: "smooth" });
                      clearTimeout(timer);
                    }, 150);
                  }
                });
              }
            });
          });
        }).catch((err) => {
          translationFinished.value = true;
          const { height: originHeight } = C(translationLoadingRef.value);
          calculateHeight.value = originHeight;
          translationTextList.value = [];
          emits("toggleErrorStatus", true);
          translationErrorText.value = err.message;
        });
      }
    }, { immediate: true });
    return (_ctx, _cache) => {
      return openBlock20(), createElementBlock20("div", {
        class: "message-translation-container",
        style: normalizeStyle7({
          height: unref20(calculateHeight) > 0 ? `${unref20(calculateHeight)}px` : "auto",
          width: unref20(calculateWidth) > 0 ? `${unref20(calculateWidth)}px` : "auto"
        })
      }, [
        unref20(translationFinished) ? (openBlock20(), createElementBlock20("div", {
          key: 0,
          ref_key: "translationContentRef",
          ref: translationContentRef,
          class: normalizeClass15({
            "translation-content": true,
            "occur": unref20(calculateHeight) > 0
          })
        }, [
          unref20(translationTextList).length > 0 ? (openBlock20(true), createElementBlock20(Fragment8, { key: 0 }, renderList7(unref20(translationTextList), (text, index3) => {
            return openBlock20(), createElementBlock20("span", { key: index3 }, [
              text.type === "face" ? (openBlock20(), createElementBlock20("img", {
                key: 0,
                class: "text-face",
                src: text.value
              }, null, 8, _hoisted_119)) : (openBlock20(), createElementBlock20("span", _hoisted_214, toDisplayString14(text.value), 1))
            ]);
          }), 128)) : (openBlock20(), createElementBlock20(Fragment8, { key: 1 }, [
            createTextVNode(toDisplayString14(unref20(translationErrorText)), 1)
          ], 64))
        ], 2)) : createCommentVNode11("", true),
        createElementVNode16("div", {
          ref_key: "translationLoadingRef",
          ref: translationLoadingRef,
          class: normalizeClass15({
            "loading": true,
            "loading-end": unref20(translationFinished)
          })
        }, toDisplayString14(unref20(Wt).t("TUIChat.翻译中")) + "... ", 3)
      ], 4);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-translate/translation-content.vue.mjs
var TranslationContent = _export_sfc(_sfc_main20, [["__scopeId", "data-v-2d45d33b"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/check-sm.svg.mjs
var checkIcon = "data:image/svg+xml,%3csvg%20width='13'%20height='13'%20viewBox='0%200%2013%2013'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M6.50001%2013C2.91038%2013%200%2010.0896%200%206.50001C0%202.91038%202.91038%200%206.50001%200C10.0896%200%2013%202.91038%2013%206.50001C13%2010.0896%2010.0896%2013%206.50001%2013ZM5.05051%209.05234C5.31489%209.31679%205.74359%209.31685%206.00805%209.05247C6.00809%209.05242%206.00813%209.05238%206.00817%209.05234L10.1129%204.94758C10.3774%204.68313%2010.3774%204.25437%2010.1129%203.98992C9.84847%203.72546%209.41971%203.72546%209.15526%203.98992L5.50008%207.58659L3.86425%205.95076C3.5998%205.68631%203.17104%205.68631%202.90659%205.95076C2.64213%206.21521%202.64213%206.64398%202.90659%206.90843L5.05051%209.05235L5.05051%209.05234Z'%20fill='%23999'/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-translate/index.vue2.mjs
var _hoisted_120 = { class: "copyright" };
var _hoisted_215 = { class: "copyright-text" };
var _sfc_main21 = defineComponent21({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  setup(__props) {
    const props = __props;
    const translationVisible = ref17(false);
    const hasTranslationError = ref17(false);
    const translationWrapperRef = ref17();
    let isSingleTranslation = true;
    onMounted9(() => {
      Jt.watch(o.CHAT, {
        translateTextInfo: onMessageTranslationUpdated
      });
    });
    onUnmounted5(() => {
      Jt.unwatch(o.CHAT, {
        translateTextInfo: onMessageTranslationUpdated
      });
    });
    function toggleErrorStatus(hasError) {
      hasTranslationError.value = hasError;
    }
    function onMessageTranslationUpdated(info) {
      if (info === void 0)
        return;
      isSingleTranslation = false;
      const translationInfoList = info.get(props.message.conversationID) || [];
      for (let i2 = 0; i2 < translationInfoList.length; ++i2) {
        const { messageID, visible } = translationInfoList[i2];
        if (messageID === props.message.ID && visible !== void 0) {
          if (translationInfoList.length === 1 && visible) {
            isSingleTranslation = true;
          }
          hasTranslationError.value = false;
          translationVisible.value = visible;
          break;
        }
      }
    }
    return (_ctx, _cache) => {
      return unref21(translationVisible) ? (openBlock21(), createElementBlock21("div", {
        key: 0,
        ref_key: "translationWrapperRef",
        ref: translationWrapperRef,
        class: normalizeClass16({
          "message-translation": true,
          "reverse": props.message.flow === "out",
          "error": unref21(hasTranslationError)
        })
      }, [
        createVNode11(TranslationContent, {
          message: props.message,
          translationContentVisible: unref21(translationVisible),
          translationWrapperRef: unref21(translationWrapperRef),
          isSingleTranslation: unref21(isSingleTranslation),
          onToggleErrorStatus: toggleErrorStatus
        }, null, 8, ["message", "translationContentVisible", "translationWrapperRef", "isSingleTranslation"]),
        createElementVNode17("div", _hoisted_120, [
          createVNode11(Icon, {
            file: unref21(checkIcon),
            size: "13px"
          }, null, 8, ["file"]),
          createElementVNode17("div", _hoisted_215, toDisplayString15(unref21(Wt).t("TUIChat.由IM提供翻译支持")), 1)
        ])
      ], 2)) : createCommentVNode12("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-translate/index.vue.mjs
var MessageTranslate = _export_sfc(_sfc_main21, [["__scopeId", "data-v-05f1fa32"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-convert/index.vue2.mjs
import { defineComponent as defineComponent23, ref as ref19, onMounted as onMounted10, onUnmounted as onUnmounted6, createElementBlock as createElementBlock23, createCommentVNode as createCommentVNode14, unref as unref23, openBlock as openBlock23, normalizeClass as normalizeClass18, createVNode as createVNode12 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-convert/convert-content.vue2.mjs
import { defineComponent as defineComponent22, ref as ref18, watch as watch8, nextTick as nextTick2, createElementBlock as createElementBlock22, openBlock as openBlock22, normalizeStyle as normalizeStyle8, unref as unref22, createCommentVNode as createCommentVNode13, createElementVNode as createElementVNode18, normalizeClass as normalizeClass17, toDisplayString as toDisplayString16 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/convertVoiceToText.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var _Convertor = class _Convertor2 {
  constructor() {
    __publicField2(this, "isUseCache", true);
    __publicField2(this, "convertCache", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    if (!_Convertor2.instance) {
      _Convertor2.instance = new _Convertor2();
    }
    return _Convertor2.instance;
  }
  async get(message) {
    if (this.isUseCache) {
      const cache = this.convertCache.get(message.ID);
      if (cache !== void 0) {
        return cache;
      }
    }
    const currentMessage = Jt.getMessageModel(message.ID);
    if (!currentMessage) {
      return Promise.reject("message not found");
    }
    const response = await Qt.convertVoiceToText({
      message: currentMessage
    });
    let { data: { result } = {} } = response;
    if (result) {
      this.convertCache.set(currentMessage.ID, result);
    } else {
      result = "";
    }
    return result;
  }
  clear() {
    this.convertCache.clear();
  }
  disableCache() {
    this.isUseCache = false;
  }
  enableCache() {
    this.isUseCache = true;
  }
};
__publicField2(_Convertor, "instance");
var Convertor = _Convertor;
var convertor = Convertor.getInstance();

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-convert/convert-content.vue2.mjs
var _sfc_main22 = defineComponent22({
  __name: "convert-content",
  props: {
    message: { default: () => ({}) },
    contentVisible: { type: Boolean },
    convertWrapperRef: {},
    isSingleConvert: { type: Boolean, default: false }
  },
  emits: ["toggleErrorStatus"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const convertFinished = ref18(false);
    const convertText2 = ref18("");
    const calculateHeight = ref18(0);
    const calculateWidth = ref18(0);
    const convertLoadingRef = ref18();
    const convertContentRef = ref18();
    watch8(() => props.contentVisible, (newVal) => {
      if (newVal) {
        convertor.get(props.message).then((text) => {
          convertFinished.value = true;
          convertText2.value = text;
          nextTick2(() => {
            const { height: originHeight, width: originWidth } = C(convertLoadingRef.value);
            const { height, width } = C(convertContentRef.value);
            calculateHeight.value = originHeight;
            calculateWidth.value = originWidth;
            requestAnimationFrame(() => {
              calculateHeight.value = height;
              calculateWidth.value = width;
              if (props.isSingleConvert) {
                nextTick2(() => {
                  const { bottom } = C(props.convertWrapperRef);
                  const { bottom: bottomWindow } = C("#messageScrollList");
                  if (bottom > bottomWindow) {
                    const timer = setTimeout(() => {
                      props.convertWrapperRef.scrollIntoView({ block: "end", behavior: "smooth" });
                      clearTimeout(timer);
                    }, 150);
                  }
                });
              }
            });
          });
        }).catch((err) => {
          convertFinished.value = true;
          emits("toggleErrorStatus", true);
          const { height: originHeight } = C(convertLoadingRef.value);
          calculateHeight.value = originHeight;
          convertText2.value = err.message;
        });
      }
    }, {
      immediate: true
    });
    return (_ctx, _cache) => {
      return openBlock22(), createElementBlock22("div", {
        class: "message-convert-container",
        style: normalizeStyle8({
          height: unref22(calculateHeight) > 0 ? `${unref22(calculateHeight)}px` : "auto",
          width: unref22(calculateWidth) > 0 ? `${unref22(calculateWidth)}px` : "auto"
        })
      }, [
        unref22(convertFinished) ? (openBlock22(), createElementBlock22("div", {
          key: 0,
          ref_key: "convertContentRef",
          ref: convertContentRef,
          class: normalizeClass17({
            "convert-content": true,
            "occur": unref22(calculateHeight) > 0
          })
        }, toDisplayString16(unref22(convertText2)), 3)) : createCommentVNode13("", true),
        createElementVNode18("div", {
          ref_key: "convertLoadingRef",
          ref: convertLoadingRef,
          class: normalizeClass17({
            "loading": true,
            "loading-end": unref22(convertFinished)
          })
        }, toDisplayString16(unref22(Wt).t("TUIChat.转换中")) + "... ", 3)
      ], 4);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-convert/convert-content.vue.mjs
var ConvertContent = _export_sfc(_sfc_main22, [["__scopeId", "data-v-83761a11"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-convert/index.vue2.mjs
var _sfc_main23 = defineComponent23({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  setup(__props) {
    const props = __props;
    const convertVisible = ref19(false);
    const hasConvertError = ref19(false);
    const convertWrapperRef = ref19();
    let isSingleConvert = true;
    onMounted10(() => {
      Jt.watch(o.CHAT, {
        voiceToTextInfo: onMessageConvertUpdated
      });
    });
    onUnmounted6(() => {
      Jt.unwatch(o.CHAT, {
        voiceToTextInfo: onMessageConvertUpdated
      });
    });
    function toggleErrorStatus(hasError) {
      hasConvertError.value = hasError;
    }
    function onMessageConvertUpdated(info) {
      if (info === void 0)
        return;
      isSingleConvert = false;
      const convertInfoList = info.get(props.message.conversationID) || [];
      for (let i2 = 0; i2 < convertInfoList.length; ++i2) {
        const { messageID, visible } = convertInfoList[i2];
        if (messageID === props.message.ID && visible !== void 0) {
          if (convertInfoList.length === 1 && visible) {
            isSingleConvert = true;
          }
          hasConvertError.value = false;
          convertVisible.value = visible;
          break;
        }
      }
    }
    return (_ctx, _cache) => {
      return unref23(convertVisible) ? (openBlock23(), createElementBlock23("div", {
        key: 0,
        ref_key: "convertWrapperRef",
        ref: convertWrapperRef,
        class: normalizeClass18({
          "message-convert": true,
          "reverse": props.message.flow === "out",
          "error": unref23(hasConvertError)
        })
      }, [
        createVNode12(ConvertContent, {
          message: props.message,
          contentVisible: unref23(convertVisible),
          isSingleConvert: unref23(isSingleConvert),
          convertWrapperRef: unref23(convertWrapperRef),
          onToggleErrorStatus: toggleErrorStatus
        }, null, 8, ["message", "contentVisible", "isSingleConvert", "convertWrapperRef"])
      ], 2)) : createCommentVNode14("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-convert/index.vue.mjs
var MessageConvert = _export_sfc(_sfc_main23, [["__scopeId", "data-v-702f862c"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/RadioSelect/index.vue2.mjs
import { defineComponent as defineComponent24, createElementBlock as createElementBlock24, openBlock as openBlock24, createBlock as createBlock5, unref as unref24 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/radio.svg.mjs
var radioIcon = "data:image/svg+xml,%3csvg%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;'%3e%3ccircle%20id='&%23230;&%23164;&%23173;&%23229;&%23156;&%23134;&%23229;&%23189;&%23162;'%20cx='22'%20cy='22'%20r='22'%20fill='%23147AFF'/%3e%3cpath%20id='&%23232;&%23183;&%23175;&%23229;&%23190;&%23132;'%20d='M29.8629%2013.8987C30.2582%2013.5129%2030.8913%2013.5206%2031.277%2013.9159L33.035%2015.7172C33.4207%2016.1124%2033.4131%2016.7454%2033.0179%2017.1312L19.0302%2030.7857C18.6448%2031.162%2018.0305%2031.1653%2017.641%2030.7933L10.9897%2024.4405C10.5904%2024.0591%2010.5758%2023.4262%2010.9571%2023.0268L12.6958%2021.2055C13.0772%2020.8061%2013.7102%2020.7914%2014.1096%2021.1727L18.3055%2025.1785L29.8629%2013.8987Z'%20fill='white'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/RadioSelect/index.vue2.mjs
var _hoisted_121 = {
  key: 0,
  class: "radio-no-select"
};
var _sfc_main24 = defineComponent24({
  __name: "index",
  props: {
    isSelected: { type: Boolean }
  },
  emits: ["onChange"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    function toggleSelect() {
      emits("onChange", !props.isSelected);
    }
    return (_ctx, _cache) => {
      return openBlock24(), createElementBlock24("div", {
        class: "radio-select",
        onClick: toggleSelect
      }, [
        !props.isSelected ? (openBlock24(), createElementBlock24("div", _hoisted_121)) : (openBlock24(), createBlock5(Icon, {
          key: 1,
          file: unref24(radioIcon),
          size: "20px"
        }, null, 8, ["file"]))
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/RadioSelect/index.vue.mjs
var RadioSelect = _export_sfc(_sfc_main24, [["__scopeId", "data-v-fff45f1e"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/loading.png.mjs
var loadingIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABGUUKwAAAQ30lEQVR4AdWbe5CW1XnA9/t2FxQUFwJLE8VREVkuQWWYie1kvLTTeBnbjjOiSZThqlHH4B9pk/aPVs0/1bbpRI0iiGBtsBEYjXHwktFBZxwmTmMRBXYjTKJFRZc7KCqX/fr7PXvO67cfu7Cgobtn5nzPuTzPc57bubzve75S3ZeUli5dWi+ra6655mBm+cwzzwx85513xnz22WcTSqXSuI6OjrPpayGP2L9//+CRI0cOvvzyyxtHjBix5+DBg7srlco2+jaC11pfX99K27oBAwa8Be1nmSc4MQ5txTi571hgw7EQVdMgUGnZsmXlqVOndiAU1Upp4cKF39i3b9+3N27cOJn6OPJwcl3O4EUZRessk5rM5XL5dHDOz/20bcN4bZ9++ulr9D3W2Nj43/QdBMeBNESMCTzmFKMfC7VCVCs+b968U2m7Fq9NA56ncjlRz94q0Y4OpToioNTc3Fx35ZVX1g0fPrwOukrCBz2S1XpKYSxo7H+d+hJ4/GLQoEHvUVb+MvmYDXFMBrjjjjvK48ePLxnujz76aPOePXtuRagZCDKKrPR6SKUtl80qDazTMMkAddUGsN3+nKE10RyWVM56ihVoLW8iLz7hhBPup9oOjdFg3+dWp6E3Sev1OjFQybmOATo++OCDhoceemj2xx9//D+0/yNMTiOH0p0yhvecYl3GsC/n6oHVU+VrkrTyiHkPFMEpcBr4/+TU+OSTT2bS1qjytBsxR+XULsLB6LDJkNfr9913XwuL0wrCeCGCnOrgZogVtOCpokdIKhRa94Sb2zUOZaPJMRyLoTtOY+os+uijj1awVrTQrwOK8SkfMfUKWasa9io/f/7877JCv8LgfwH3A2QVyIIVA7Jo5QUuvJZwa0NUC9VaSRz55ilURIZGSCkb2gZx/xxnvLJ3797vaATwlKeWb6btAo9oABmRYuQFCxbcTX0J9WFwUUAF6WmgLJxQvOrpoNBubXtTtmybSZly2Bc8GDcbNJD8SUrKW6WHEQ2P7d69+277lDn1W+0xOVCPKTNg3g/YuXPnfLw+A+SwMB52USqE0uPgy8t+jaIX5L/fPR3ctZTXgLdu4MCBvz/ppJN2Uv+ooaGhjrk8hPYm8M5ACUP5fPC/DjwHnEay4zjHHSOcZjklx9IINFUc+4cYoRl4E237gJB2OjDhdwE9eS+sKyHKn7hr167/QKCpMNNLsdDQFwrTFgyBFkDrUEAHfZ+mxw8cOPCrpqam12fOnKnCvU4YfOjgwYPPxSBXwsvt9TSIHUZDxBjAgl8qA2L3aQAuO+WUU6ZD+wll5fkcuaDqDLWqamdRgjvvvFPjVHbs2DEP70yFwX5yIwoWXhebNoHzNjwB7kbKD3G6m8+asSsPzhrSwNYZQnhokqibFN61Hb47oH2Zw89LwB+zyN0INI+hO4wNLKKB9nAabRF1wKlEwsfAmWTngzwPMUJID0KX5Fbngvfwww//M4R/T9bzWrXW6zINj9D3KeV7WYz+be7cuVuoZyOWb7/99oPdDd5l0JqK9DQZ2hpLF9JUGcG297c4YS7lE+wDhhF0TE60WQyZmVZ3DRky5B9oq4eH61aXdIgBqpS/DqY/l0jiTJWYRyxSlqEWX8u2OGfWrFmvult4SMpH40z3RSDjKKeKaogOpuQFKOYWPIG+A2TlK3ShHsMBtYp01w8bNmyJeLVGCOsFNj8Kr+c51k4E+acg2xWnuFTOIW+7zBtoX0b+psprPDvkQdsh4WbfsSR5kcN7KsHc/g1T4s/gtZy6Dgj3U44IdQzLpGyUezitTpQH7V10ljgSHSJLVcabP6E+nLKKxHk8kDp/wgsUteb8G2644WZgJRuvCu9LLzJOVlSn+PR4LfP8Zwx0M2X71CHme5oSoIXSX8Fg94Hzl/THLkV7WKiwhqc8G08//fQ5wG+JSC5Cn3J4PxGq/DyVt13PY4AQzvofOzG2c1/ZKkTDLcD7yepC8yGBJ57rwcXbt2+fkeQv9I4QgYj2UoWz/UhWXc/2X0uccghFSNGWjbJszpw51+h1FjiJDxmVAf/oSbkZRNk7iISlbLlT8XyWsXp85TMyNrF+TDn77LN9gJKucz6w5YWnWVi05tfIhn6hfOIUjD3IYKTwvO0ySf3HHdSMfQv19QihLnmqZMepvPKP4mxxaxI0dC7rRfKBRYsWjUK5aakzlNcGKWsu7FPvyeqm6dOnb0t0xy3sk1yHAOSKrZCtbiuyfQ+EfeQI8Sy/RHrcdQEdrt+2bdso+tw9yrFlicCR9GrAmeQDdBYrf2JiRMjkp7Nnz37leM955TtcQrYwAlvdK8h4D1lZXewiAqSlrFFU+kynSuJXim1PhWByHRGgx4sFIhHK3O2uDSP9xLb169f/v4V9ErxHgKz/TufvgD6rmOIlTCIoWyddZz86HYxtkOfpKYRGvIujswgfkGIKSEH/I9OmTWtfuXJlwyWXXOKq2qcSymRHfbB169bFyH5XrYC0hW7A8z788MMp9L8aDSin9w37CPUUCXVAPW37+0OHDl0gw4svvtjFpK+mkA25H0TA98h6vKLXUTqyOiZDXKcS8eIAgklWTCBUw4gX+h/n5eUOFz76+2z4K5vKsRb4EPY4WV18WxU6+ZPahOeSy+UlS5ZMpH1cwihWf3EhrPd5HQP80n7P+AmvL4OQEZmfTkLqZFNWPk6K9I1rb2+f6BQYj6LNQMM/Vv9EmPfSN9j319h2mMfYRNInQMjNtF6NNG+QNYjrQwgHVGenwQh2g3EYqjzWEAFG+FtOdSNAq7X6XE/4uxP02fAP7fhRRlKD04CXKG3Of2CsA9VrgWV0PsdFYkIiLsJbxUkRDTwYvW4lv8yw3A9SdtRrGEOjxGJfJXcoSF+LXh2dFC4MkBCDCAOstd6X9/4qxXIxG6DNBhQtDKBBSNkA55SZKyM0QA/Z/f5tKXzoEfaTFLIS3X9AYU9/sQDWQqZGsyvk4KRUbQTYfJB37Uf1MrMvGYg5vhP94myQlc+6WsfpgxpAGmKlJtmgQTqYAntq+vpNlS/Ue4jwvAOETtW6Uj7Fo3Bo7xRIVukC+422PQharXAtijq7C+yxUJNyQxkrnlzT12+qRO/JGCAvgFmnavl3lTnkhAEwAufCzrNAFaznO3xTNUV/KuNcZS/uGBgNKQMi8PcaAe1ZqRwJwpSdImfYnz6UWOwPKbyNkmeSu3zPUPGc+Yax1cPO20nZYi1IGsaREqSvW+8nzwHZOWEA9BqblM0LYTgWpNCVSG9rYJVcRxRIGI2ZA9CnKA10rm186upuDlWh953iSy+9FLJy1p+cpFJBt/y8wFMMddsM8bespCjICNIFE6w07sknn2ziJYh7Kmh9+3kgyXiAb5pNvAYfryKkLs7L+vKk+1YZK61DqXZyvE0FdpJgsaAslSaxmsb7Ar8d5M4+DENG3vicz0lvEsrq6vB+ktloUNct6N7q9TYN0Kbi5HgCtIznS+Q4RTFF/lrifvI8ELGNDn+lHiTE74h3ANqCctiEn1YueK0NjOXLl9+DsnNBVmFfFkoYBukEpfcgnHjVVVf16WmAUohe8pN+E6++11P/KvJrkFAo6eW7ACPgZ2PGjPl+hMuJJ574GAZw0SuUB8H1QMtpslOp3mgbC0x8ULDc11KWbfPmzTfisK8m2Tu9ibDUzerYwRW7nyt/GICrbr/FAKu1kJ0JFgujiOwWs1asWPEnvhH23aBtfSmhWFnZ3nzzzZHoMqtaNhVPqXO7q1Te4Bbra7aV/Sbg52ws5vdzLRRImQJmPjL7WOye+oPc3lchC/bfKSv6qFOx9WXdElyisSjXl/PCBuEydP093ndr7GIE6rZpnNueeuqpC4mAjr4UBcjleaVj3bp130Tp7yclY6paTkmd1ONtHLo0tVX8Ltjhx44rrrjiXTr+i+wOUEkwpoHIDgBopP3Bp59+enhfMUJW/t133/0KMj5IfQA5di/l1gBmDBPvBdHtP0ePHv2/6qxOMZfzxw4ejO6FZhNZ6xWmo2zSyq6g4zDCA51NMUCxyOS24wWRpRibGyB+DPH9ZuxkWfEEAfGp7H0M4F2CuqxzGADFvA5Xf+mll7aD8GPq4sRXIgsm2o0CdK83EqY+99xzD+TXZNIG0nH8qRqzwjR+gEPP1XjZHau40aLySZe8sN9x1llnfSiOOitusZr7zp+OEjvCYpR9gT7nS4RSYiK+iWpEws3PP/98RIKL6PFcE5AzPuoqTGtrq8p7RUZZ48Bje062k3XQr9khFlHWu8UaV4SQBCrh3EaxibwIWUnTcC2lxiRRskUtRqhhrOVcU5l9wQUX7NYrLqryEOHLTghf5jge1/Tb2tpO5srcIiLSz/pGa5czTJI3ZKd/K/kSnmjXyoO+Qr4iAhRWwdNUWItit8kkM7I/lS2apHV7vJprJ6ueeOKJPzUS7JBHsrTVL5zklUPeMVjt/UfKKmS8mj5lKPSgHuMBLcTRnoee21ReHtXKi9glAoKSHxEd6Nlnn42LkjR5aSK2wozD4Lno/HK/9cLzvZwq//XCCy8sLkpedNFFZRcccDoly1RHgPArebJ7+eWXO/I9pDVr1jTD5wdM9eKiJHKEILQHR2Eqh8xEyN0tLS1e9lT5cFD10N0awMF9A2REsNgtZsAZEO+HMF9czoNkXh3IAUpIsQGwgEtLC6ufHdx2tmzZEkbo6Rtjftr03UM6qMiysmHDhiHcYfAofgPZC9TZuw4aMtTAkBWZHpkwYcJM9NFIRsMhTujWAHLUCBKsWrUqLkvT5LUSw01Lmih2JstkCZxbDuaT5Gbqj+OBX/Je8fUpU6bsSui9AqtXr27icfU8+PwNslwLr3iwcQxyjAEsHGGZpAx62df9y7g3NH3UqFGHvSz9uRbdiKURbMYzjdz4fpBI0JoKECmTMFghCG15ywnvgOjU2ACOC9BrGOQtrse/zZljBwLGNwei5WTwhtJ2BnACuH67969255AHkB0qFi76uvU6OJAQ5/X19j/CyfYmrsN5YSqcI+wuHdYAEsCzwGF3uAvmP7SZHN5WHvFMSdCAtIsTn9yBxTyl3X7P4fYdtE4yqtyqPJ0VfKg7tTSofTFOwi9w6FNv8VyHjLx/mTRp0o8sQyPeIWFve04xeq50BzMD14TLLrvsR6yo3wVvOzkvKoZdIVAVD5pLvpFVEMPS6ZO3HxfUgeRBKVvOi6w44mogaW1Xy+7GoDn2fw20HeWvT8pngx9WeWi63wXs6C7l3YFIaGGweeBcRFZOhdYQGiVIheYsOPjdtce3iMQj+vOP+JlH5pn7qIdxgMEU3JU8398yduzYNsbLjsnoh4VHjIBqaldvjcCRuY3X5Zcx8GyE2ASOfLKns5eDtFb4an6JptNiNR21VQ1JkrcnO8cz5N8nImezyF6u8sqWcAC9SznseoWNMkoRx162pQM8QS4mGlbQfivGmEHfKHIOu7znquBRGTobDQWd/yotj7wOyGsTii/mAej+yZMnt6u4RgE3jwlK71KvrN8dKwbs8tfZF1988VTO5N9mJfcSYtw5zIooWCoDYmrkOe2iJftYR9I4lnO93n5p4Cn0r7OPAn/Btrq5Vobu5DxS2zEbIDOuFcL6Cy+88A22o+sR/lyE9d/i8UwBpNrz2pB5CpPiW9l6f4e3f6vSePtVIEN0NX413dGWv7AB8oBp/nX5+zwnuIFcRRuDEn5e8zVVC4YZjQLNKDgIZYZIT303YC99XnjeSLkVpdvYy9cyvzfw9tazRCT6I2Sg7bLW5P6jhf8HQQgchWA4BKsAAAAASUVORK5CYII=";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-bubble.vue2.mjs
var _hoisted_124 = { class: "message-bubble-content" };
var _hoisted_216 = {
  key: 0,
  class: "message-body-nick-name"
};
var _hoisted_37 = { class: "content-main" };
var _hoisted_45 = {
  key: 0,
  class: "content-has-risk-tips"
};
var _hoisted_55 = {
  key: 0,
  class: "audio-unplay-mark"
};
var _hoisted_64 = { class: "message-bubble-extra-content" };
var riskImageReplaceUrl = "https://web.sdk.qcloud.com/component/TUIKit/assets/has_risk_default.png";
var _sfc_main25 = defineComponent25({
  __name: "message-bubble",
  props: {
    messageItem: { default: () => ({}) },
    content: { default: () => ({}) },
    classNameList: { default: () => [] },
    blinkMessageIDList: { default: () => [] },
    isMultipleSelectMode: { type: Boolean, default: false },
    isAudioPlayed: { type: Boolean, default: false },
    multipleSelectedMessageIDList: { default: () => [] }
  },
  emits: ["resendMessage", "blinkMessage", "setReadReceiptPanelVisible", "changeSelectMessageIDList", "scrollTo"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const TYPES = qt.TYPES;
    const needLoadingIconMessageType = [
      TYPES.MSG_LOCATION,
      TYPES.MSG_TEXT,
      TYPES.MSG_CUSTOM,
      TYPES.MSG_MERGER,
      TYPES.MSG_FACE
    ];
    const { blinkMessageIDList, messageItem: message } = toRefs2(props);
    const isMultipleSelected = computed8(() => {
      return props.multipleSelectedMessageIDList.includes(message.value.ID);
    });
    const isDisplayUnplayMark = computed8(() => {
      return message.value.flow === "in" && message.value.status === "success" && message.value.type === TYPES.MSG_AUDIO && !props.isAudioPlayed;
    });
    const containerClassNameList = computed8(() => {
      return [
        "message-bubble",
        isMultipleSelected.value ? "multiple-selected" : "",
        ...props.classNameList
      ];
    });
    const hasEmojiReaction = computed8(() => {
      var _a3;
      return (_a3 = message.value) == null ? void 0 : _a3.reactionList.some((item) => item.totalUserCount !== 0);
    });
    const isNoPadding = computed8(() => {
      return !hasEmojiReaction.value && [TYPES.MSG_IMAGE, TYPES.MSG_VIDEO, TYPES.MSG_MERGER].includes(message.value.type);
    });
    const riskContentText = computed8(() => {
      let content = Wt.t("TUIChat.涉及敏感内容") + ", ";
      if (message.value.flow === "out") {
        content += Wt.t("TUIChat.发送失败");
      } else {
        content += Wt.t(
          message.value.type === TYPES.MSG_AUDIO ? "TUIChat.无法收听" : "TUIChat.无法查看"
        );
      }
      return content;
    });
    const isBlink = computed8(() => {
      var _a3, _b3;
      if ((_a3 = message.value) == null ? void 0 : _a3.ID) {
        return (_b3 = blinkMessageIDList == null ? void 0 : blinkMessageIDList.value) == null ? void 0 : _b3.includes(message.value.ID);
      }
      return false;
    });
    function toggleMultipleSelect(isSelected) {
      emits("changeSelectMessageIDList", {
        type: isSelected ? "add" : "remove",
        messageID: message.value.ID
      });
    }
    function resendMessage() {
      var _a3;
      if (!((_a3 = message.value) == null ? void 0 : _a3.hasRiskContent)) {
        emits("resendMessage");
      }
    }
    function blinkMessage(messageID) {
      emits("blinkMessage", messageID);
    }
    function scrollTo(scrollHeight) {
      emits("scrollTo", scrollHeight);
    }
    function openReadUserPanel() {
      emits("setReadReceiptPanelVisible", true, message.value);
    }
    return (_ctx, _cache) => {
      return openBlock25(), createElementBlock25("div", {
        class: normalizeClass19(unref25(containerClassNameList))
      }, [
        props.isMultipleSelectMode ? (openBlock25(), createBlock6(RadioSelect, {
          key: 0,
          class: "multiple-select-radio",
          isSelected: unref25(isMultipleSelected),
          onOnChange: toggleMultipleSelect
        }, null, 8, ["isSelected"])) : createCommentVNode15("", true),
        createElementVNode19("div", {
          class: normalizeClass19({
            "control-reverse": unref25(message).flow === "out"
          })
        }, [
          createElementVNode19("div", _hoisted_124, [
            createElementVNode19("div", {
              class: normalizeClass19(["message-bubble-main-content", [unref25(message).flow === "in" ? "" : "reverse"]])
            }, [
              createVNode13(Avatar, {
                useSkeletonAnimation: "",
                url: unref25(message).avatar || ""
              }, null, 8, ["url"]),
              createElementVNode19("main", {
                class: "message-body",
                onClick: _cache[1] || (_cache[1] = withModifiers5(() => {
                }, ["stop"]))
              }, [
                unref25(message).flow === "in" && unref25(message).conversationType === "GROUP" ? (openBlock25(), createElementBlock25("div", _hoisted_216, toDisplayString17(props.content.showName), 1)) : createCommentVNode15("", true),
                createElementVNode19("div", {
                  class: normalizeClass19(["message-body-main", unref25(message).flow === "out" && "message-body-main-reverse"])
                }, [
                  createElementVNode19("div", {
                    class: normalizeClass19([
                      "blink",
                      "message-body-content",
                      unref25(message).flow === "out" ? "content-out" : "content-in",
                      unref25(message).hasRiskContent && "content-has-risk",
                      unref25(isNoPadding) ? "content-no-padding" : "",
                      unref25(isNoPadding) && unref25(isBlink) ? "blink-shadow" : "",
                      !unref25(isNoPadding) && unref25(isBlink) ? "blink-content" : ""
                    ])
                  }, [
                    createElementVNode19("div", _hoisted_37, [
                      (unref25(message).type === unref25(TYPES).MSG_IMAGE || unref25(message).type === unref25(TYPES).MSG_VIDEO) && unref25(message).hasRiskContent ? (openBlock25(), createElementBlock25("img", {
                        key: 0,
                        class: normalizeClass19(["message-risk-replace", !unref25(isPC) && "message-risk-replace-h5"]),
                        src: riskImageReplaceUrl
                      }, null, 2)) : (openBlock25(), createElementBlock25(Fragment9, { key: 1 }, [
                        renderSlot4(_ctx.$slots, "messageElement", {}, void 0, true),
                        renderSlot4(_ctx.$slots, "TUIEmojiPlugin", {}, void 0, true)
                      ], 64))
                    ]),
                    unref25(message).hasRiskContent ? (openBlock25(), createElementBlock25("div", _hoisted_45, toDisplayString17(unref25(riskContentText)), 1)) : createCommentVNode15("", true)
                  ], 2),
                  unref25(isDisplayUnplayMark) ? (openBlock25(), createElementBlock25("div", _hoisted_55)) : createCommentVNode15("", true),
                  unref25(message).status === "fail" || unref25(message).hasRiskContent ? (openBlock25(), createElementBlock25("div", {
                    key: 1,
                    class: "message-label fail",
                    onClick: _cache[0] || (_cache[0] = ($event) => resendMessage())
                  }, " ! ")) : createCommentVNode15("", true),
                  unref25(message).status === "unSend" && needLoadingIconMessageType.includes(unref25(message).type) ? (openBlock25(), createBlock6(Icon, {
                    key: 2,
                    class: "message-label loading-circle",
                    file: unref25(loadingIcon),
                    width: "15px",
                    height: "15px"
                  }, null, 8, ["file"])) : createCommentVNode15("", true),
                  createVNode13(ReadStatus, {
                    class: "message-label align-self-bottom",
                    message: unref25(shallowCopyMessage)(unref25(message)),
                    onOpenReadUserPanel: openReadUserPanel
                  }, null, 8, ["message"])
                ], 2)
              ])
            ], 2),
            createElementVNode19("div", _hoisted_64, [
              createVNode13(MessageTranslate, {
                class: normalizeClass19(unref25(message).flow === "out" ? "reverse" : "flex-row"),
                message: unref25(message)
              }, null, 8, ["class", "message"]),
              createVNode13(MessageConvert, {
                class: normalizeClass19(unref25(message).flow === "out" ? "reverse" : "flex-row"),
                message: unref25(message)
              }, null, 8, ["class", "message"]),
              createVNode13(MessageQuote, {
                class: normalizeClass19(unref25(message).flow === "out" ? "reverse" : "flex-row"),
                message: unref25(message),
                onBlinkMessage: blinkMessage,
                onScrollTo: scrollTo
              }, null, 8, ["class", "message"])
            ])
          ])
        ], 2)
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-bubble.vue.mjs
var MessageBubble = _export_sfc(_sfc_main25, [["__scopeId", "data-v-1883bd8e"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-location.vue2.mjs
import { defineComponent as defineComponent26, ref as ref20, watchEffect as watchEffect4, createElementBlock as createElementBlock26, openBlock as openBlock26, unref as unref26, createElementVNode as createElementVNode20, toDisplayString as toDisplayString18 } from "vue";
var _hoisted_125 = ["href"];
var _hoisted_217 = { class: "el-icon-location-outline" };
var _hoisted_38 = ["src"];
var _sfc_main26 = defineComponent26({
  __name: "message-location",
  props: {
    content: {
      type: Object,
      default: () => ({})
    }
  },
  setup(__props) {
    const props = __props;
    const data = ref20();
    watchEffect4(() => {
      data.value = props.content;
    });
    return (_ctx, _cache) => {
      return openBlock26(), createElementBlock26("a", {
        class: "message-location",
        href: unref26(data).href,
        target: "_blank",
        title: "点击查看详情"
      }, [
        createElementVNode20("span", _hoisted_217, toDisplayString18(unref26(data).description), 1),
        createElementVNode20("img", {
          src: unref26(data).url
        }, null, 8, _hoisted_38)
      ], 8, _hoisted_125);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-location.vue.mjs
var MessageLocation = _export_sfc(_sfc_main26, [["__scopeId", "data-v-a089c0b8"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-timestamp.vue2.mjs
import { defineComponent as defineComponent27, toRefs as toRefs3, ref as ref21, watch as watch9, createElementBlock as createElementBlock27, createCommentVNode as createCommentVNode16, unref as unref27, openBlock as openBlock27, toDisplayString as toDisplayString19 } from "vue";
var _hoisted_126 = {
  key: 0,
  class: "message-timestamp"
};
var _sfc_main27 = defineComponent27({
  __name: "message-timestamp",
  props: {
    currTime: {
      type: Number,
      default: 0
    },
    prevTime: {
      type: Number,
      default: 0
    }
  },
  setup(__props) {
    const props = __props;
    const { currTime, prevTime } = toRefs3(props);
    const timestampShowFlag = ref21(false);
    const timestampShowContent = ref21("");
    const handleItemTime = (currTime2, prevTime2) => {
      timestampShowFlag.value = false;
      if (currTime2 <= 0) {
        return "";
      } else if (!prevTime2 || prevTime2 <= 0) {
        timestampShowFlag.value = true;
        return calculateTimestamp(currTime2 * 1e3);
      } else {
        const minDiffToShow = 10 * 60;
        const diff = currTime2 - prevTime2;
        if (diff >= minDiffToShow) {
          timestampShowFlag.value = true;
          return calculateTimestamp(currTime2 * 1e3);
        }
      }
      return "";
    };
    watch9(
      () => [currTime.value, prevTime.value],
      (newVal, oldVal) => {
        if ((newVal == null ? void 0 : newVal.toString()) === (oldVal == null ? void 0 : oldVal.toString())) {
          return;
        } else {
          timestampShowContent.value = handleItemTime(
            currTime.value,
            prevTime.value
          );
        }
      },
      {
        immediate: true
      }
    );
    return (_ctx, _cache) => {
      return unref27(timestampShowFlag) ? (openBlock27(), createElementBlock27("div", _hoisted_126, toDisplayString19(unref27(timestampShowContent)), 1)) : createCommentVNode16("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-timestamp.vue.mjs
var MessageTimestamp = _export_sfc(_sfc_main27, [["__scopeId", "data-v-9c0f4a26"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-video.vue2.mjs
import { defineComponent as defineComponent28, ref as ref22, watchEffect as watchEffect5, nextTick as nextTick3, computed as computed9, watch as watch10, createElementBlock as createElementBlock28, openBlock as openBlock28, createElementVNode as createElementVNode21, createCommentVNode as createCommentVNode17, normalizeClass as normalizeClass20, unref as unref28, withModifiers as withModifiers6, createVNode as createVNode14 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/icon-close.svg.mjs
var closeIcon2 = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.30533%207.99984L15.7557%201.54943C16.0813%201.22383%2016.0813%200.687032%2015.7557%200.361432L15.7205%200.326232C15.3949%200.000631131%2014.8581%200.000631131%2014.5325%200.326232L8.08212%206.78544L1.63172%200.326232C1.30612%200.000631131%200.769316%200.000631131%200.443715%200.326232L0.408515%200.361432C0.0741147%200.687032%200.0741147%201.22383%200.408515%201.54943L6.85892%207.99984L0.408515%2014.4502C0.0829148%2014.7759%200.0829148%2015.3126%200.408515%2015.6383L0.443715%2015.6735C0.769316%2015.9991%201.30612%2015.9991%201.63172%2015.6735L8.08212%209.22304L14.5325%2015.6735C14.8581%2015.9991%2015.3949%2015.9991%2015.7205%2015.6735L15.7557%2015.6383C16.0813%2015.3126%2016.0813%2014.7759%2015.7557%2014.4502L9.30533%207.99984Z'%20fill='%238F959E'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-video.vue2.mjs
var _hoisted_127 = { class: "message-video" };
var _hoisted_218 = ["src"];
var _hoisted_39 = ["src", "poster"];
var _hoisted_46 = ["src", "poster"];
var _hoisted_56 = {
  key: 0,
  class: "dialog-video"
};
var _hoisted_65 = ["src"];
var transparentPosterUrl = "https://web.sdk.qcloud.com/im/assets/images/transparent.png";
var _sfc_main28 = defineComponent28({
  __name: "message-video",
  props: {
    content: { default: () => ({}) },
    messageItem: { default: () => ({}) }
  },
  emits: ["uploading"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isShow = ref22(false);
    const poster = ref22("");
    const posterWidth = ref22(0);
    const posterHeight = ref22(0);
    const skeleton = ref22();
    const videoRef = ref22();
    watchEffect5(async () => {
      if (!props.content)
        return;
      poster.value = await handlePosterUrl(props.content, props.messageItem);
      nextTick3(async () => {
        var _a3, _b3, _c2, _d2, _e2;
        const containerWidth = ((_a3 = document.getElementById("messageScrollList")) == null ? void 0 : _a3.clientWidth) || 0;
        const max = !isPC ? Math.min(containerWidth - 172, 300) : 300;
        let size;
        if (props.messageItem.status === "success") {
          let { snapshotWidth = 0, snapshotHeight = 0 } = props.content;
          const { snapshotUrl } = props.content;
          if (snapshotWidth === 0 || snapshotHeight === 0)
            return;
          if (snapshotUrl === transparentPosterUrl) {
            snapshotWidth = posterWidth.value;
            snapshotHeight = posterHeight.value;
          }
          size = handleSkeletonSize(snapshotWidth, snapshotHeight, max, max);
          ((_b3 = skeleton == null ? void 0 : skeleton.value) == null ? void 0 : _b3.style) && (skeleton.value.style.width = `${size.width}px`);
          ((_c2 = skeleton == null ? void 0 : skeleton.value) == null ? void 0 : _c2.style) && (skeleton.value.style.height = `${size.height}px`);
          if (isPC) {
            ((_d2 = videoRef == null ? void 0 : videoRef.value) == null ? void 0 : _d2.style) && (videoRef.value.style.width = `${size.width}px`);
            ((_e2 = videoRef == null ? void 0 : videoRef.value) == null ? void 0 : _e2.style) && (videoRef.value.style.height = `${size.height}px`);
          }
        } else {
          emits("uploading");
        }
      });
    });
    const isWidth = computed9(() => {
      const { snapshotWidth = 0, snapshotHeight = 0 } = props.messageItem.payload;
      return snapshotWidth >= snapshotHeight;
    });
    watch10(() => props.messageItem.status, (newVal, oldVal) => {
      if (newVal === "success" && oldVal !== "success") {
        emits("uploading");
      }
    });
    function toggleVideoPreviewer() {
      if (props.messageItem.progress > 0 && props.messageItem.progress < 1) {
        return;
      }
      isShow.value = !isShow.value;
    }
    function getVideoBase64(url) {
      return new Promise((resolve) => {
        let dataURL = "";
        const video = document.createElement("video");
        video.setAttribute("crossOrigin", "anonymous");
        video.setAttribute("src", url);
        video.setAttribute("preload", "auto");
        video.addEventListener(
          "loadeddata",
          function() {
            const canvas = document.createElement("canvas"), width = video.videoWidth, height = video.videoHeight;
            canvas.width = width;
            canvas.height = height;
            canvas.getContext("2d").drawImage(video, 0, 0, width, height);
            dataURL = canvas.toDataURL("image/jpeg");
            posterWidth.value = width;
            posterHeight.value = height;
            resolve(dataURL);
          },
          { once: true }
        );
      });
    }
    async function handlePosterUrl(messgeContent, messageItem) {
      var _a3, _b3, _c2, _d2;
      if (!messageItem)
        return "";
      if (messageItem.status !== "success") {
        return await getVideoBase64(messgeContent.url);
      } else {
        return messgeContent.snapshotUrl !== transparentPosterUrl && messgeContent.snapshotUrl || ((_a3 = messageItem == null ? void 0 : messageItem.payload) == null ? void 0 : _a3.snapshotUrl) !== transparentPosterUrl && ((_b3 = messageItem == null ? void 0 : messageItem.payload) == null ? void 0 : _b3.snapshotUrl) || ((_c2 = messageItem.payload) == null ? void 0 : _c2.thumbUrl) !== transparentPosterUrl && ((_d2 = messageItem == null ? void 0 : messageItem.payload) == null ? void 0 : _d2.thumbUrl) || await getVideoBase64(messgeContent.url);
      }
    }
    return (_ctx, _cache) => {
      return openBlock28(), createElementBlock28("div", _hoisted_127, [
        createElementVNode21("div", {
          ref_key: "skeleton",
          ref: skeleton,
          class: normalizeClass20(["message-video-box", [
            (!props.messageItem.progress || props.messageItem.progress === 1) && !unref28(isPC) && "message-video-cover"
          ]]),
          onClick: toggleVideoPreviewer
        }, [
          props.messageItem.progress > 0 && props.messageItem.progress < 1 && unref28(poster) || !unref28(isPC) && unref28(poster) ? (openBlock28(), createElementBlock28("img", {
            key: 0,
            class: normalizeClass20(["message-img", [unref28(isWidth) ? "is-width" : "is-height"]]),
            src: unref28(poster)
          }, null, 10, _hoisted_218)) : !unref28(isPC) ? (openBlock28(), createElementBlock28("video", {
            key: 1,
            ref_key: "videoRef",
            ref: videoRef,
            class: "message-img video-h5-uploading",
            src: props.content.url + "#t=0.1",
            poster: props.content.url,
            preload: "auto",
            muted: ""
          }, null, 8, _hoisted_39)) : (openBlock28(), createElementBlock28("video", {
            key: 2,
            ref_key: "videoRef",
            ref: videoRef,
            class: "message-img video-web",
            src: props.content.url,
            controls: "",
            preload: "metadata",
            poster: unref28(poster)
          }, null, 8, _hoisted_46))
        ], 2),
        unref28(isShow) && !unref28(isPC) ? (openBlock28(), createElementBlock28("div", _hoisted_56, [
          createElementVNode21("div", {
            class: "dialog-video-close",
            onClick: withModifiers6(toggleVideoPreviewer, ["stop"])
          }, [
            createVNode14(Icon, { file: unref28(closeIcon2) }, null, 8, ["file"])
          ]),
          createElementVNode21("div", {
            class: normalizeClass20(["dialog-video-box", [!unref28(isPC) ? "dialog-video-h5" : ""]]),
            onClick: withModifiers6(toggleVideoPreviewer, ["self"])
          }, [
            createElementVNode21("video", {
              class: normalizeClass20([unref28(isWidth) ? "is-width" : "is-height"]),
              src: props.content.url,
              controls: "",
              autoplay: ""
            }, null, 10, _hoisted_65)
          ], 2)
        ])) : createCommentVNode17("", true)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-elements/message-video.vue.mjs
var MessageVideo = _export_sfc(_sfc_main28, [["__scopeId", "data-v-281f1f55"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-tool/index.vue2.mjs
import { defineComponent as defineComponent29, ref as ref23, onMounted as onMounted11, onUnmounted as onUnmounted7, watchEffect as watchEffect6, computed as computed10, createElementBlock as createElementBlock29, createCommentVNode as createCommentVNode18, unref as unref29, openBlock as openBlock29, normalizeClass as normalizeClass21, renderSlot as renderSlot5, createElementVNode as createElementVNode22, Fragment as Fragment10, renderList as renderList8, createVNode as createVNode15, toDisplayString as toDisplayString20 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/msg-del.svg.mjs
var delIcon = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='40px'%20height='40px'%20viewBox='0%200%2040%2040'%20version='1.1'%3e%3ctitle%3e矩形%3c/title%3e%3cdefs%3e%3cpath%20d='M467,0%20C474.731986,-2.71135202e-14%20481,6.2680135%20481,14%20L481,247%20C481,254.731986%20474.731986,261%20467,261%20L353.036,261%20L340.862492,273.204941%20C339.302377,274.769018%20336.769719,274.77223%20335.205642,273.212116%20C335.203247,273.209727%20335.200856,273.207335%20335.198467,273.204941%20L323.024,261%20L14,261%20C6.2680135,261%202.72325209e-15,254.731986%200,247%20L0,14%20C8.29461588e-16,6.2680135%206.2680135,3.19669972e-15%2014,0%20L467,0%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-10.1%25'%20y='-14.0%25'%20width='120.2%25'%20height='135.4%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeOffset%20dx='0'%20dy='10'%20in='SourceAlpha'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='14.5'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.06%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='消息状态'%20transform='translate(-779.000000,%20-326.000000)'%3e%3cg%20id='编组-11'%20transform='translate(499.000000,%20163.000000)'%3e%3cg%20id='形状结合'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cuse%20fill='%23FFFFFF'%20fill-rule='evenodd'%20xlink:href='%23path-1'%3e%3c/use%3e%3c/g%3e%3cg%20id='编组-13备份'%20transform='translate(246.000000,%20131.583780)'%3e%3cg%20id='编组-17'%20transform='translate(34.000000,%2031.416220)'%3e%3cg%20id='编组-18'%20transform='translate(4.000000,%202.847939)'%3e%3cpath%20d='M27,8.04349833%20L27,34.26099%20L5,34.26099%20L5,8.04349833%20L27,8.04349833%20Z'%20id='路径-5'%20stroke='%23444444'%20stroke-width='4'%3e%3c/path%3e%3crect%20id='矩形'%20fill='%23444444'%20x='9.14285714'%20y='0'%20width='14'%20height='4.02899889'%3e%3c/rect%3e%3crect%20id='矩形'%20fill='%23444444'%20x='0'%20y='6.04349833'%20width='32'%20height='4.02899889'%3e%3c/rect%3e%3cpath%20d='M14,15.1087458%20L14,27.1957425%20L10,27.1957425%20L10,15.1087458%20L14,15.1087458%20Z%20M22,15.1087458%20L22,27.1957425%20L18,27.1957425%20L18,15.1087458%20L22,15.1087458%20Z'%20id='形状结合'%20fill='%23444444'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3cg%20id='编组-19'%20transform='translate(8.000000,%201.000000)'%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/msg-copy.svg.mjs
var copyIcon = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='40px'%20height='40px'%20viewBox='0%200%2040%2040'%20version='1.1'%3e%3ctitle%3e编组%2014%3c/title%3e%3cdefs%3e%3cpath%20d='M467,0%20C474.731986,-2.71135202e-14%20481,6.2680135%20481,14%20L481,247%20C481,254.731986%20474.731986,261%20467,261%20L353.036,261%20L340.862492,273.204941%20C339.302377,274.769018%20336.769719,274.77223%20335.205642,273.212116%20C335.203247,273.209727%20335.200856,273.207335%20335.198467,273.204941%20L323.024,261%20L14,261%20C6.2680135,261%202.72325209e-15,254.731986%200,247%20L0,14%20C8.29461588e-16,6.2680135%206.2680135,3.19669972e-15%2014,0%20L467,0%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-10.1%25'%20y='-14.0%25'%20width='120.2%25'%20height='135.4%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeOffset%20dx='0'%20dy='10'%20in='SourceAlpha'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='14.5'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.06%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='消息状态'%20transform='translate(-541.000000,%20-196.000000)'%3e%3cg%20id='编组-11'%20transform='translate(499.000000,%20163.000000)'%3e%3cg%20id='形状结合'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cuse%20fill='%23FFFFFF'%20fill-rule='evenodd'%20xlink:href='%23path-1'%3e%3c/use%3e%3c/g%3e%3cg%20id='编组-19'%20transform='translate(8.000000,%201.000000)'%20fill-rule='nonzero'%3e%3cg%20id='编组-17'%20transform='translate(34.000000,%2032.000000)'%3e%3cg%20id='编组-14'%20transform='translate(0.000000,%200.249660)'%3e%3crect%20id='矩形'%20stroke='%23444444'%20stroke-width='4'%20x='6'%20y='11.7115453'%20width='20.4869565'%20height='24.5849258'%20rx='1'%3e%3c/rect%3e%3cpath%20d='M36,2.01560374%20L36,28.7262543%20C36,29.0023967%2035.7761424,29.2262543%2035.5,29.2262543%20L32.4652074,29.2262543%20C32.1890657,29.2262525%2031.9652084,29.002396%2031.9652057,28.7262543%20L31.9651258,6.04681123%20L31.9651258,6.04681123%20L12.2913043,6.04719144%20C12.015162,6.04720643%2011.7913,5.82335314%2011.7912947,5.54721076%20C11.7912947,5.54720754%2011.7912947,5.54720432%2011.7913043,5.5472011%20L11.7913043,2.51560374%20C11.7913043,2.23946137%2012.015162,2.01560374%2012.2913043,2.01560374%20L36,2.01560374%20L36,2.01560374%20Z'%20id='路径-3'%20fill='%23444444'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/msg-quote.svg.mjs
var quoteIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2040%2041'%20class='design-iconfont'%3e%3cg%20fill='none'%20fill-rule='evenodd'%3e%3cpath%20d='M34,2%20L34,28.6209709%20L20.7153357,28.6209709%20L17.9993455,31.4022694%20L15.2847485,28.6219998%20L2,28.6219998%20L2,2%20L34,2%20Z'%20transform='translate(2%203.273066)'%20fill-rule='nonzero'%20stroke='%23444'%20stroke-width='4'/%3e%3cpath%20fill='%23444'%20d='M11%2016.12483H15V20.15603749H11z'%20transform='translate(0%20.24966)'/%3e%3cpath%20fill='%23444'%20d='M18%2016.12483H22V20.15603749H18z'%20transform='translate(0%20.24966)'/%3e%3cpath%20fill='%23444'%20d='M25%2016.12483H29V20.15603749H25z'%20transform='translate(0%20.24966)'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/msg-revoke.svg.mjs
var revokeIcon = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='40px'%20height='40px'%20viewBox='0%200%2040%2040'%20version='1.1'%3e%3ctitle%3e矩形%3c/title%3e%3cdefs%3e%3cpath%20d='M467,0%20C474.731986,-2.71135202e-14%20481,6.2680135%20481,14%20L481,247%20C481,254.731986%20474.731986,261%20467,261%20L353.036,261%20L340.862492,273.204941%20C339.302377,274.769018%20336.769719,274.77223%20335.205642,273.212116%20C335.203247,273.209727%20335.200856,273.207335%20335.198467,273.204941%20L323.024,261%20L14,261%20C6.2680135,261%202.72325209e-15,254.731986%200,247%20L0,14%20C8.29461588e-16,6.2680135%206.2680135,3.19669972e-15%2014,0%20L467,0%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-10.1%25'%20y='-14.0%25'%20width='120.2%25'%20height='135.4%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeOffset%20dx='0'%20dy='10'%20in='SourceAlpha'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='14.5'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.06%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='消息状态'%20transform='translate(-660.000000,%20-327.000000)'%3e%3cg%20id='编组-11'%20transform='translate(499.000000,%20163.000000)'%3e%3cg%20id='形状结合'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cuse%20fill='%23FFFFFF'%20fill-rule='evenodd'%20xlink:href='%23path-1'%3e%3c/use%3e%3c/g%3e%3cg%20id='编组-19'%20transform='translate(8.000000,%201.000000)'%20fill='%23444444'%20fill-rule='nonzero'%3e%3cg%20id='编组-13'%20transform='translate(119.000000,%20131.000000)'%3e%3cg%20id='编组-21'%20transform='translate(34.000000,%2032.000000)'%3e%3cpath%20d='M9.94902685,18.825399%20C9.94902685,19.1015414%209.72516923,19.325399%209.44902685,19.325399%20C9.31552791,19.325399%209.18757266,19.2720125%209.09366105,19.1771306%20L2.13687841,12.1484693%20C1.94403281,11.9536312%201.94403281,11.6398441%202.13687841,11.445006%20L9.09366105,4.41634471%20C9.28791708,4.2200816%209.60449539,4.21845454%209.8007585,4.41271056%20C9.89564042,4.50662217%209.94902685,4.63457741%209.94902685,4.76807636%20L9.94824421,9.73507632%20L22.6994692,9.73558854%20C31.0812313,9.73558854%2038,15.6504194%2038,23.1330579%20C38,30.5145797%2031.2669616,36.3703807%2023.0384554,36.5272976%20L22.6994692,36.5305273%20L10.4390092,36.5305273%20C9.88672441,36.5305273%209.43900916,36.082812%209.43900916,35.5305273%20L9.43900916,33.408229%20C9.43900916,32.8559443%209.88672441,32.408229%2010.4390092,32.408229%20L22.6994692,32.408229%20C28.9648068,32.408229%2033.9198585,28.1721729%2033.9198585,23.1330579%20C33.9198585,18.1779281%2029.1285988,13.9993117%2023.0116273,13.861401%20L22.6994692,13.8578868%20L9.94824421,13.8570763%20L9.94902685,18.825399%20Z'%20id='路径'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/msg-forward.svg.mjs
var forwardIcon = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='40px'%20height='40px'%20viewBox='0%200%2040%2040'%20version='1.1'%3e%3ctitle%3e编组%3c/title%3e%3cdefs%3e%3cpath%20d='M467,0%20C474.731986,-2.71135202e-14%20481,6.2680135%20481,14%20L481,247%20C481,254.731986%20474.731986,261%20467,261%20L353.036,261%20L340.862492,273.204941%20C339.302377,274.769018%20336.769719,274.77223%20335.205642,273.212116%20C335.203247,273.209727%20335.200856,273.207335%20335.198467,273.204941%20L323.024,261%20L14,261%20C6.2680135,261%202.72325209e-15,254.731986%200,247%20L0,14%20C8.29461588e-16,6.2680135%206.2680135,3.19669972e-15%2014,0%20L467,0%20Z'%20id='path-1'%3e%3c/path%3e%3cfilter%20x='-10.1%25'%20y='-14.0%25'%20width='120.2%25'%20height='135.4%25'%20filterUnits='objectBoundingBox'%20id='filter-2'%3e%3cfeOffset%20dx='0'%20dy='10'%20in='SourceAlpha'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='14.5'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.06%200'%20type='matrix'%20in='shadowBlurOuter1'%3e%3c/feColorMatrix%3e%3c/filter%3e%3c/defs%3e%3cg%20id='页面-1'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='消息状态'%20transform='translate(-660.000000,%20-196.000000)'%3e%3cg%20id='编组-11'%20transform='translate(499.000000,%20163.000000)'%3e%3cg%20id='形状结合'%3e%3cuse%20fill='black'%20fill-opacity='1'%20filter='url(%23filter-2)'%20xlink:href='%23path-1'%3e%3c/use%3e%3cuse%20fill='%23FFFFFF'%20fill-rule='evenodd'%20xlink:href='%23path-1'%3e%3c/use%3e%3c/g%3e%3cg%20id='编组-19'%20transform='translate(8.000000,%201.000000)'%20fill-rule='nonzero'%20stroke='%23444444'%20stroke-width='4'%3e%3cg%20id='编组-13'%20transform='translate(119.000000,%200.000000)'%3e%3cg%20id='编组-17'%20transform='translate(34.000000,%2032.000000)'%3e%3cg%20id='编组'%20transform='translate(0.000000,%200.249660)'%3e%3cpath%20d='M23.1265517,6.28055724%20L35.7271185,19.5748426%20L23.0577232,32.8831329%20L23.0577232,25.1147287%20C22.2832234,25.0144246%2021.6206186,24.9731478%2021.1119625,24.9593482%20C19.8469875,24.9250298%2017.622079,25.0087745%2015.0567889,25.7301995%20C10.5501298,27.0035633%206.83444935,29.6335962%204.00998374,33.593477%20C3.98525766,32.7188606%203.9976824,31.6416134%204.10230378,30.4471653%20C4.26498285,28.6221312%204.60551504,26.8911737%205.12965716,25.3080362%20C5.77312173,23.3656805%206.68732788,21.6451437%207.85433875,20.1962611%20C11.1297915,16.1439451%2016.3122766,14.2888953%2023.1265517,14.4503809%20L23.1265517,14.4503809%20L23.1265517,6.28055724%20Z'%20id='路径'%3e%3c/path%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/translate.svg.mjs
var translateIcon = "data:image/svg+xml,%3csvg%20width='19'%20height='18'%20viewBox='0%200%2019%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cmask%20id='path-1-inside-1_313_82772'%20fill='white'%3e%3crect%20x='7'%20y='7.62939e-06'%20width='12'%20height='12'%20rx='0.5'/%3e%3c/mask%3e%3crect%20x='7'%20y='7.62939e-06'%20width='12'%20height='12'%20rx='0.5'%20fill='%23444444'%20stroke='%23CCCCCC'%20stroke-width='4'%20mask='url(%23path-1-inside-1_313_82772)'/%3e%3cpath%20d='M12.7426%203.61601H12.6745L12.6496%203.67939L10.9636%207.96339L10.9098%208.10001H11.0566H11.5846H11.6536L11.6781%208.03553L12.1096%206.90001H13.9397L14.3712%208.03553L14.3957%208.10001H14.4646H14.9986H15.1455L15.0917%207.96339L13.4057%203.67939L13.3808%203.61601H13.3126H12.7426ZM13.7079%206.28601H12.3421L13.03%204.49341L13.7079%206.28601Z'%20fill='%23CCCCCC'%20stroke='%23CCCCCC'%20stroke-width='0.2'/%3e%3cmask%20id='path-3-inside-2_313_82772'%20fill='white'%3e%3crect%20y='6.00001'%20width='12'%20height='12'%20rx='0.5'/%3e%3c/mask%3e%3crect%20y='6.00001'%20width='12'%20height='12'%20rx='0.5'%20fill='%23444444'%20stroke='%23CCCCCC'%20stroke-width='4'%20mask='url(%23path-3-inside-2_313_82772)'/%3e%3cpath%20d='M5.77801%208.97401H5.67801V9.07401V10.054H3.63H3.53V10.154V12.974V13.074H3.63H4.062H4.162V12.974V12.696H5.67801V14.642V14.742H5.77801H6.222H6.322V14.642V12.696H7.84401V12.974V13.074H7.94401H8.37601H8.47601V12.974V10.154V10.054H8.37601H6.322V9.07401V8.97401H6.222H5.77801ZM4.162%2012.076V10.674H5.67801V12.076H4.162ZM6.322%2012.076V10.674H7.84401V12.076H6.322Z'%20fill='%23CCCCCC'%20stroke='%23CCCCCC'%20stroke-width='0.2'/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/multiple-select.svg.mjs
var multipleSelectIcon = "data:image/svg+xml,%3csvg%20width='37'%20height='37'%20viewBox='0%200%2037%2037'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;'%3e%3cpath%20id='&%23229;&%23189;&%23162;&%23231;&%23138;&%23182;&%23231;&%23187;&%23147;&%23229;&%23144;&%23136;'%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M10.5826%200.46165C10.2025%200.0807196%209.58916%200.0688692%209.19464%200.434835L5.63779%203.73431L4.20962%202.56125C3.79371%202.21963%203.18202%202.26848%202.8256%202.67178L1.19197%204.52024C0.816905%204.94463%200.868823%205.59552%201.30642%205.95509L5.1484%209.11198C5.5349%209.42956%206.09662%209.41269%206.46335%209.07247L12.304%203.65419C12.7194%203.26888%2012.732%202.61581%2012.3318%202.21475L10.5826%200.46165ZM9.16745%2014.027C9.56196%2013.661%2010.1753%2013.6728%2010.5554%2014.0538L12.3046%2015.8069C12.7048%2016.2079%2012.6922%2016.861%2012.2768%2017.2463L6.43616%2022.6646C6.06942%2023.0048%205.5077%2023.0217%205.1212%2022.7041L1.27923%2019.5472C0.841626%2019.1876%200.789707%2018.5368%201.16478%2018.1124L2.7984%2016.2639C3.15483%2015.8606%203.76652%2015.8118%204.18243%2016.1534L5.61059%2017.3264L9.16745%2014.027ZM14.1637%2016.0705C14.1637%2015.7944%2014.3876%2015.5705%2014.6637%2015.5705H36.4728C36.7489%2015.5705%2036.9728%2015.7944%2036.9728%2016.0705V19.4692C36.9728%2019.7453%2036.7489%2019.9692%2036.4728%2019.9692H14.6637C14.3876%2019.9692%2014.1637%2019.7453%2014.1637%2019.4692V16.0705ZM10.5554%2027.6271C10.1753%2027.2461%209.56196%2027.2343%209.16745%2027.6002L5.61059%2030.8997L4.18243%2029.7267C3.76652%2029.385%203.15483%2029.4339%202.7984%2029.8372L1.16478%2031.6857C0.789707%2032.11%200.841626%2032.7609%201.27923%2033.1205L5.1212%2036.2774C5.5077%2036.595%206.06942%2036.5781%206.43616%2036.2379L12.2768%2030.8196C12.6922%2030.4343%2012.7048%2029.7812%2012.3046%2029.3802L10.5554%2027.6271ZM14.6637%2029.1438C14.3876%2029.1438%2014.1637%2029.3677%2014.1637%2029.6438V33.0424C14.1637%2033.3186%2014.3876%2033.5424%2014.6637%2033.5424H36.4728C36.7489%2033.5424%2036.9728%2033.3186%2036.9728%2033.0424V29.6438C36.9728%2029.3677%2036.7489%2029.1438%2036.4728%2029.1438H14.6637ZM14.6909%201.97839C14.4148%201.97839%2014.1909%202.20225%2014.1909%202.47839V5.87703C14.1909%206.15318%2014.4148%206.37703%2014.6909%206.37703H36.5C36.7761%206.37703%2037%206.15318%2037%205.87703V2.47839C37%202.20225%2036.7761%201.97839%2036.5%201.97839H14.6909Z'%20fill='%23444444'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/convertText_zh.svg.mjs
var convertText = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cmask%20id='path-1-inside-1_1_4'%20fill='white'%3e%3crect%20y='6.10352e-05'%20width='16'%20height='16'%20rx='0.5'/%3e%3c/mask%3e%3crect%20y='6.10352e-05'%20width='16'%20height='16'%20rx='0.5'%20fill='white'%20stroke='%23444444'%20stroke-width='4'%20mask='url(%23path-1-inside-1_1_4)'/%3e%3cpath%20d='M4.51199%205.81608V6.39208H5.74399C6.10399%207.62408%206.74399%208.69608%207.67199%209.60808C6.80799%2010.3921%205.70399%2010.9601%204.35999%2011.3201L4.66399%2011.8241C6.02399%2011.4321%207.15999%2010.8161%208.07199%209.97608C8.93599%2010.7201%2010.024%2011.3361%2011.352%2011.8321L11.664%2011.3521C10.384%2010.8801%209.31999%2010.2881%208.47199%209.56808C9.25599%208.72008%209.84799%207.65608%2010.24%206.39208H11.488V5.81608H8.43199C8.17599%205.26408%207.90399%204.79208%207.59999%204.40808L7.02399%204.61608C7.34399%204.99208%207.60799%205.39208%207.82399%205.81608H4.51199ZM6.31199%206.39208H9.63999C9.30399%207.49608%208.78399%208.43208%208.07199%209.20808C7.23999%208.40808%206.65599%207.47208%206.31199%206.39208Z'%20fill='%23444444'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M4.31199%205.61608H7.48751C7.31129%205.31249%207.10719%205.02243%206.87168%204.74571L6.68467%204.52597L7.66745%204.17108L7.7568%204.28394C8.0517%204.65645%208.31433%205.10396%208.55891%205.61608H11.688V6.59208H10.3863C10.0114%207.74389%209.46813%208.73403%208.75997%209.54663C9.55979%2010.1899%2010.5494%2010.7279%2011.7332%2011.1644L11.9682%2011.2511L11.4323%2012.0756L11.282%2012.0194C10.0044%2011.5423%208.9389%2010.9527%208.07627%2010.2412C7.1617%2011.0446%206.04107%2011.6353%204.71938%2012.0163L4.57197%2012.0587L4.05139%2011.1957L4.30824%2011.1269C5.54648%2010.7952%206.56828%2010.2862%207.38032%209.59789C6.54448%208.73191%205.95109%207.72929%205.59553%206.59208H4.31199V5.61608ZM5.74399%206.39208C6.08545%207.56066%206.67884%208.58529%207.53097%209.46597C7.57721%209.51377%207.62422%209.56114%207.67199%209.60808C7.62257%209.65292%207.57237%209.69705%207.52139%209.74048C6.72554%2010.4184%205.73841%2010.9245%204.56%2011.2645C4.49393%2011.2835%204.42726%2011.3021%204.35999%2011.3201L4.66399%2011.8241C6.02399%2011.4321%207.15999%2010.8161%208.07199%209.97608C8.93599%2010.7201%2010.024%2011.3361%2011.352%2011.8321L11.664%2011.3521C11.5996%2011.3283%2011.5357%2011.3043%2011.4724%2011.2799C10.3526%2010.8491%209.40393%2010.3229%208.6263%209.69577C8.57409%209.65366%208.52265%209.6111%208.47199%209.56808C8.51719%209.51918%208.56176%209.46957%208.60569%209.41924C9.32359%208.59671%209.87059%207.5832%2010.24%206.39208H11.488V5.81608H8.43199C8.17599%205.26408%207.90399%204.79208%207.59999%204.40808L7.02399%204.61608C7.07008%204.67024%207.115%204.72489%207.15879%204.78004C7.3708%205.04705%207.55614%205.32573%207.71752%205.61608C7.75424%205.68215%207.78972%205.74881%207.82399%205.81608H4.51199V6.39208H5.74399ZM6.31199%206.39208C6.3334%206.45931%206.35574%206.52597%206.37901%206.59208C6.70795%207.52643%207.223%208.34973%207.92962%209.06741C7.97624%209.11476%208.0237%209.16165%208.07199%209.20808C8.07199%209.20808%208.07198%209.20809%208.07199%209.20808C8.11712%209.1589%208.16148%209.10906%208.20507%209.05858C8.80725%208.36128%209.26261%207.54091%209.5765%206.59208C9.59834%206.52604%209.61951%206.45937%209.63999%206.39208H6.31199ZM6.59144%206.59208C6.90978%207.46685%207.39807%208.23985%208.06267%208.91746C8.62858%208.25932%209.06168%207.48673%209.36556%206.59208H6.59144Z'%20fill='%23444444'/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/utils/enableSampleTaskStatus.mjs
function enableSampleTaskStatus(taskKey) {
  const tasks = Jt.getData(o.APP, "tasks");
  if (taskKey in tasks && !tasks[taskKey]) {
    tasks[taskKey] = true;
    Jt.update(o.APP, "tasks", tasks);
  }
}

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/copy.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
var _CopyManager = class _CopyManager2 {
  constructor() {
    __publicField3(this, "savedSelection");
    this.savedSelection = null;
  }
  static getInstance() {
    if (!_CopyManager2.instance) {
      _CopyManager2.instance = new _CopyManager2();
    }
    return _CopyManager2.instance;
  }
  saveCurrentSelection() {
    const selection = window.getSelection();
    if (isH5 || !selection) {
      return;
    }
    this.savedSelection = {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
  restoreSelection() {
    const selection = window.getSelection();
    if (isH5 || !selection || !this.savedSelection) {
      return;
    }
    const { anchorNode, anchorOffset, focusNode, focusOffset } = this.savedSelection;
    if (!anchorNode || !focusNode) {
      return;
    }
    const range = document.createRange();
    const isForwardSelection = anchorNode === focusNode ? anchorOffset <= focusOffset : anchorNode.compareDocumentPosition(focusNode) & Node.DOCUMENT_POSITION_FOLLOWING;
    if (isForwardSelection) {
      range.setStart(anchorNode, anchorOffset);
      range.setEnd(focusNode, focusOffset);
    } else {
      range.setStart(focusNode, focusOffset);
      range.setEnd(anchorNode, anchorOffset);
    }
    selection.removeAllRanges();
    selection.addRange(range);
  }
  async copySelection(defaultContent) {
    this.restoreSelection();
    const selection = window.getSelection();
    if (isH5 || !selection || selection.rangeCount === 0) {
      await this.copyTextOrHtml(defaultContent, "text");
      return;
    }
    const range = selection.getRangeAt(0);
    const fragment = range.cloneContents();
    const tempContainer = document.createElement("div");
    tempContainer.appendChild(fragment);
    const content = tempContainer.innerHTML || defaultContent;
    const type = tempContainer.innerHTML ? "html" : "text";
    await this.copyTextOrHtml(content, type);
    this.savedSelection = null;
  }
  async copyTextOrHtml(content, type) {
    const mimeType = type === "html" ? "text/html" : "text/plain";
    if (navigator.clipboard) {
      try {
        const contentBlob = new Blob([content], { type: mimeType });
        const clipboardItem = new ClipboardItem({ [mimeType]: contentBlob });
        await navigator.clipboard.write([clipboardItem]);
        return;
      } catch (err) {
      }
    }
    let tempElement;
    if (type === "html") {
      tempElement = document.createElement("div");
      tempElement.style.position = "fixed";
      tempElement.style.opacity = "0";
      tempElement.contentEditable = "true";
      tempElement.innerHTML = content;
      document.body.appendChild(tempElement);
      const range = document.createRange();
      range.selectNodeContents(tempElement);
      const selection = window.getSelection();
      selection == null ? void 0 : selection.removeAllRanges();
      selection == null ? void 0 : selection.addRange(range);
      tempElement.focus();
    } else {
      tempElement = document.createElement("textarea");
      tempElement.value = content;
      tempElement.style.position = "fixed";
      document.body.appendChild(tempElement);
      tempElement.focus();
      tempElement.select();
    }
    try {
      document.execCommand("copy");
    } catch (err) {
      Toast({
        message: Wt.t("TUIChat.此机型暂不支持复制"),
        type: TOAST_TYPE.ERROR
      });
      console.warn("use document.execCommand copy failed:", err);
    } finally {
      document.body.removeChild(tempElement);
    }
  }
};
__publicField3(_CopyManager, "instance");
var CopyManager = _CopyManager;
var CopyManager$1 = CopyManager.getInstance();

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-tool/index.vue2.mjs
var _hoisted_128 = ["onClick", "onMousedown"];
var _hoisted_219 = { class: "list-item-text" };
var _sfc_main29 = defineComponent29({
  __name: "index",
  props: {
    messageItem: { default: () => ({}) },
    isMultipleSelectMode: { type: Boolean, default: false }
  },
  emits: ["toggleMultipleSelectMode"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const featureConfig = ChatConfig.getFeatureConfig();
    const TYPES = qt.TYPES;
    const actionItems = ref23([
      {
        key: "open",
        text: Wt.t("TUIChat.打开"),
        iconUrl: copyIcon,
        renderCondition() {
          var _a3;
          if (!featureConfig.DownloadFile || !message.value)
            return false;
          return isPC && (((_a3 = message.value) == null ? void 0 : _a3.type) === TYPES.MSG_FILE || message.value.type === TYPES.MSG_VIDEO || message.value.type === TYPES.MSG_IMAGE);
        },
        clickEvent: openMessage
      },
      {
        key: "copy",
        text: Wt.t("TUIChat.复制"),
        iconUrl: copyIcon,
        renderCondition() {
          if (!featureConfig.CopyMessage || !message.value)
            return false;
          return message.value.type === TYPES.MSG_TEXT;
        },
        clickEvent: copyMessage
      },
      {
        key: "revoke",
        text: Wt.t("TUIChat.撤回"),
        iconUrl: revokeIcon,
        renderCondition() {
          if (!featureConfig.RevokeMessage || !message.value)
            return false;
          return message.value.flow === "out" && message.value.status === "success";
        },
        clickEvent: revokeMessage
      },
      {
        key: "delete",
        text: Wt.t("TUIChat.删除"),
        iconUrl: delIcon,
        renderCondition() {
          if (!featureConfig.DeleteMessage || !message.value)
            return false;
          return message.value.status === "success";
        },
        clickEvent: deleteMessage
      },
      {
        key: "forward",
        text: Wt.t("TUIChat.转发"),
        iconUrl: forwardIcon,
        renderCondition() {
          if (!featureConfig.ForwardMessage || !message.value)
            return false;
          return message.value.status === "success";
        },
        clickEvent: forwardSingleMessage
      },
      {
        key: "quote",
        text: Wt.t("TUIChat.引用"),
        iconUrl: quoteIcon,
        renderCondition() {
          if (!featureConfig.QuoteMessage || !message.value)
            return false;
          const _message = Jt.getMessageModel(message.value.ID);
          return message.value.status === "success" && !_message.getSignalingInfo();
        },
        clickEvent: quoteMessage
      },
      {
        key: "translate",
        text: Wt.t("TUIChat.翻译"),
        visible: false,
        iconUrl: translateIcon,
        renderCondition() {
          if (!featureConfig.TranslateMessage || !message.value)
            return false;
          return message.value.status === "success" && message.value.type === TYPES.MSG_TEXT;
        },
        clickEvent: translateMessage
      },
      {
        key: "convert",
        text: Wt.t("TUIChat.转文字"),
        visible: false,
        iconUrl: convertText,
        renderCondition() {
          if (!featureConfig.VoiceToText || !message.value)
            return false;
          return message.value.status === "success" && message.value.type === TYPES.MSG_AUDIO;
        },
        clickEvent: convertVoiceToText
      },
      {
        key: "multi-select",
        text: Wt.t("TUIChat.多选"),
        iconUrl: multipleSelectIcon,
        renderCondition() {
          if (!featureConfig.MultiSelection || !message.value)
            return false;
          return message.value.status === "success";
        },
        clickEvent: multipleSelectMessage
      }
    ]);
    const message = ref23();
    const messageToolDom = ref23();
    onMounted11(() => {
      Jt.watch(o.CHAT, {
        translateTextInfo: onMessageTranslationInfoUpdated,
        voiceToTextInfo: onMessageConvertInfoUpdated
      });
    });
    onUnmounted7(() => {
      Jt.unwatch(o.CHAT, {
        translateTextInfo: onMessageTranslationInfoUpdated,
        voiceToTextInfo: onMessageConvertInfoUpdated
      });
    });
    watchEffect6(() => {
      message.value = Jt.getMessageModel(props.messageItem.ID);
    });
    const isAllActionItemInvalid = computed10(() => {
      for (let i2 = 0; i2 < actionItems.value.length; ++i2) {
        if (actionItems.value[i2].renderCondition()) {
          return false;
        }
      }
      return true;
    });
    function getFunction(index3) {
      actionItems.value[index3].clickEvent();
    }
    function openMessage() {
      var _a3;
      let url = "";
      switch ((_a3 = message.value) == null ? void 0 : _a3.type) {
        case qt.TYPES.MSG_FILE:
          url = message.value.payload.fileUrl;
          break;
        case qt.TYPES.MSG_VIDEO:
          url = message.value.payload.remoteVideoUrl;
          break;
        case qt.TYPES.MSG_IMAGE:
          url = message.value.payload.imageInfoArray[0].url;
          break;
      }
      window == null ? void 0 : window.open(url, "_blank");
    }
    function revokeMessage() {
      if (!message.value)
        return;
      const messageModel = Jt.getMessageModel(message.value.ID);
      messageModel.revokeMessage().then(() => {
        enableSampleTaskStatus("revokeMessage");
      }).catch((error) => {
        if (error.code === 20016 || error.code === 10031) {
          const message2 = Wt.t("TUIChat.已过撤回时限");
          Toast({
            message: message2,
            type: TOAST_TYPE.ERROR
          });
        }
      });
    }
    function deleteMessage() {
      if (!message.value)
        return;
      const messageModel = Jt.getMessageModel(message.value.ID);
      messageModel.deleteMessage();
    }
    async function copyMessage() {
      var _a3, _b3, _c2, _d2, _e2;
      if (isUniFrameWork) {
        (_c2 = i) == null ? void 0 : _c2.setClipboardData({
          data: transformTextWithKeysToEmojiNames((_b3 = (_a3 = message.value) == null ? void 0 : _a3.payload) == null ? void 0 : _b3.text)
        });
      } else {
        CopyManager$1.copySelection((_e2 = (_d2 = message.value) == null ? void 0 : _d2.payload) == null ? void 0 : _e2.text);
      }
    }
    function beforeCopy(key) {
      if (key !== "copy" || isH5) {
        return;
      }
      CopyManager$1.saveCurrentSelection();
    }
    function forwardSingleMessage() {
      if (!message.value)
        return;
      Jt.update(o.CUSTOM, "singleForwardMessageID", message.value.ID);
    }
    function quoteMessage() {
      if (!message.value)
        return;
      message.value.quoteMessage();
    }
    function translateMessage() {
      const enable = Jt.getData(o.APP, "enabledTranslationPlugin");
      if (!enable) {
        Toast({
          message: Wt.t("TUIChat.请开通翻译功能"),
          type: TOAST_TYPE.WARNING
        });
        return;
      }
      if (!message.value)
        return;
      const index3 = actionItems.value.findIndex((item) => item.key === "translate");
      Jt.update(o.CHAT, "translateTextInfo", {
        conversationID: message.value.conversationID,
        messageID: message.value.ID,
        visible: !actionItems.value[index3].visible
      });
    }
    function convertVoiceToText() {
      const enable = Jt.getData(o.APP, "enabledVoiceToText");
      if (!enable) {
        Toast({
          message: Wt.t("TUIChat.请开通语音转文字功能")
        });
        return;
      }
      if (!message.value)
        return;
      const index3 = actionItems.value.findIndex((item) => item.key === "convert");
      Jt.update(o.CHAT, "voiceToTextInfo", {
        conversationID: message.value.conversationID,
        messageID: message.value.ID,
        visible: !actionItems.value[index3].visible
      });
    }
    function multipleSelectMessage() {
      emits("toggleMultipleSelectMode");
    }
    function onMessageTranslationInfoUpdated(info) {
      if (info === void 0)
        return;
      const translationInfoList = info.get(props.messageItem.conversationID) || [];
      const idx = actionItems.value.findIndex((item) => item.key === "translate");
      for (let i2 = 0; i2 < translationInfoList.length; ++i2) {
        const { messageID, visible } = translationInfoList[i2];
        if (messageID === props.messageItem.ID) {
          actionItems.value[idx].text = Wt.t(visible ? "TUIChat.隐藏" : "TUIChat.翻译");
          actionItems.value[idx].visible = !!visible;
          return;
        }
      }
      actionItems.value[idx].text = Wt.t("TUIChat.翻译");
    }
    function onMessageConvertInfoUpdated(info) {
      if (info === void 0)
        return;
      const convertInfoList = info.get(props.messageItem.conversationID) || [];
      const idx = actionItems.value.findIndex((item) => item.key === "convert");
      for (let i2 = 0; i2 < convertInfoList.length; ++i2) {
        const { messageID, visible } = convertInfoList[i2];
        if (messageID === props.messageItem.ID) {
          actionItems.value[idx].text = Wt.t(visible ? "TUIChat.隐藏" : "TUIChat.转文字");
          actionItems.value[idx].visible = !!visible;
          return;
        }
      }
      actionItems.value[idx].text = Wt.t("TUIChat.转文字");
    }
    __expose({
      messageToolDom
    });
    return (_ctx, _cache) => {
      return !unref29(isAllActionItemInvalid) && !_ctx.messageItem.hasRiskContent ? (openBlock29(), createElementBlock29("div", {
        key: 0,
        ref_key: "messageToolDom",
        ref: messageToolDom,
        class: normalizeClass21(["dialog-item", !unref29(isPC) ? "dialog-item-h5" : "dialog-item-web"])
      }, [
        unref29(featureConfig).EmojiReaction ? renderSlot5(_ctx.$slots, "TUIEmojiPlugin", { key: 0 }, void 0, true) : createCommentVNode18("", true),
        createElementVNode22("div", {
          class: normalizeClass21(["dialog-item-list", !unref29(isPC) ? "dialog-item-list-h5" : "dialog-item-list-web"])
        }, [
          (openBlock29(true), createElementBlock29(Fragment10, null, renderList8(unref29(actionItems), (item, index3) => {
            return openBlock29(), createElementBlock29(Fragment10, null, [
              item.renderCondition() ? (openBlock29(), createElementBlock29("div", {
                key: item.key,
                class: "list-item",
                onClick: ($event) => getFunction(index3),
                onMousedown: ($event) => beforeCopy(item.key)
              }, [
                createVNode15(Icon, {
                  file: item.iconUrl,
                  size: "15px"
                }, null, 8, ["file"]),
                createElementVNode22("span", _hoisted_219, toDisplayString20(item.text), 1)
              ], 40, _hoisted_128)) : createCommentVNode18("", true)
            ], 64);
          }), 256))
        ], 2)
      ], 2)) : createCommentVNode18("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-tool/index.vue.mjs
var MessageTool = _export_sfc(_sfc_main29, [["__scopeId", "data-v-96f7d799"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-tool/message-revoked.vue2.mjs
import { defineComponent as defineComponent30, ref as ref24, watchEffect as watchEffect7, createElementBlock as createElementBlock30, openBlock as openBlock30, createElementVNode as createElementVNode23, createCommentVNode as createCommentVNode19, unref as unref30, toDisplayString as toDisplayString21 } from "vue";
var _hoisted_129 = { class: "revoke" };
var _hoisted_220 = { key: 0 };
var _hoisted_310 = { key: 1 };
var _hoisted_47 = { key: 2 };
var _sfc_main30 = defineComponent30({
  __name: "message-revoked",
  props: {
    isEdit: {
      type: Boolean,
      default: () => false
    },
    messageItem: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["messageEdit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const message = ref24();
    const isEditMsg = ref24(false);
    const emits = __emit;
    watchEffect7(() => {
      message.value = props.messageItem;
      isEditMsg.value = props.isEdit;
    });
    const messageEdit = () => {
      emits("messageEdit");
    };
    return (_ctx, _cache) => {
      return openBlock30(), createElementBlock30("div", _hoisted_129, [
        unref30(message).flow === "in" ? (openBlock30(), createElementBlock30("span", _hoisted_220, toDisplayString21(unref30(message).nick || unref30(message).from), 1)) : unref30(message).from === unref30(message).revoker ? (openBlock30(), createElementBlock30("span", _hoisted_310, toDisplayString21(unref30(Wt).t("TUIChat.您")), 1)) : (openBlock30(), createElementBlock30("span", _hoisted_47, toDisplayString21(unref30(message).revoker), 1)),
        createElementVNode23("span", null, toDisplayString21(unref30(Wt).t("TUIChat.撤回了一条消息")), 1),
        unref30(message).flow === "out" && unref30(isEditMsg) ? (openBlock30(), createElementBlock30("span", {
          key: 3,
          class: "edit",
          onClick: messageEdit
        }, toDisplayString21(unref30(Wt).t("TUIChat.重新编辑")), 1)) : createCommentVNode19("", true)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/message-tool/message-revoked.vue.mjs
var MessageRevoked = _export_sfc(_sfc_main30, [["__scopeId", "data-v-f40107e2"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-plugin.vue2.mjs
import { defineComponent as defineComponent36, computed as computed14, createBlock as createBlock7, openBlock as openBlock35, unref as unref35, withCtx as withCtx7, createCommentVNode as createCommentVNode23, createVNode as createVNode18 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/index.mjs
function isCallMessage(message) {
  var _a3;
  const payloadData = JSONToObject((_a3 = message == null ? void 0 : message.payload) == null ? void 0 : _a3.data);
  if ((payloadData == null ? void 0 : payloadData.businessID) === 1 && (payloadData == null ? void 0 : payloadData.data)) {
    const payloadDataData = JSONToObject(payloadData.data);
    if (payloadDataData.businessID === "av_call") {
      return true;
    }
  }
  return false;
}
function isRoomSignalingMessage(message) {
  var _a3;
  const payloadData = JSONToObject((_a3 = message == null ? void 0 : message.payload) == null ? void 0 : _a3.data);
  return (payloadData == null ? void 0 : payloadData.businessID) === "ROOM_INVITE_ACTION" || (payloadData == null ? void 0 : payloadData.businessID) === "tuikit_engine_room";
}
function isRoomCardMessage(message) {
  var _a3;
  const payloadData = JSONToObject((_a3 = message == null ? void 0 : message.payload) == null ? void 0 : _a3.data);
  return (payloadData == null ? void 0 : payloadData.businessID) === "group_room_message";
}
function isPluginMessage(message) {
  return message.type === qt.TYPES.MSG_CUSTOM && (isCallMessage(message) || isRoomCardMessage(message) || isRoomSignalingMessage(message));
}

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-plugin-layout.vue2.mjs
import { defineComponent as defineComponent31, computed as computed11, createElementBlock as createElementBlock31, openBlock as openBlock31, createCommentVNode as createCommentVNode20, renderSlot as renderSlot6, withModifiers as withModifiers7, unref as unref31, createVNode as createVNode16, withCtx as withCtx6 } from "vue";
var _hoisted_130 = { class: "message-plugin" };
var _hoisted_221 = {
  key: 0,
  class: "message-plugin-tip"
};
var _sfc_main31 = defineComponent31({
  __name: "message-plugin-layout",
  props: {
    message: { default: () => ({}) },
    showStyle: { default: "" },
    bubbleClassNameList: { default: () => [] },
    blinkMessageIDList: { default: () => [] }
  },
  emits: ["resendMessage", "handleToggleMessageItem", "handleH5LongPress"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const messageModel = computed11(() => {
      var _a3;
      return Jt.getMessageModel((_a3 = props.message) == null ? void 0 : _a3.ID);
    });
    const resendMessage = (message) => {
      emits("resendMessage", message);
    };
    const handleToggleMessageItem = (e, message, isLongpress = false) => {
      emits("handleToggleMessageItem", e, message, isLongpress);
    };
    const handleH5LongPress = (e, message, type) => {
      emits("handleH5LongPress", e, message, type);
    };
    return (_ctx, _cache) => {
      return openBlock31(), createElementBlock31("div", _hoisted_130, [
        props.showStyle === "tip" ? (openBlock31(), createElementBlock31("div", _hoisted_221, [
          renderSlot6(_ctx.$slots, "messageTip", {}, void 0, true)
        ])) : props.showStyle === "bubble" ? (openBlock31(), createElementBlock31("div", {
          key: 1,
          class: "message-plugin-bubble-content",
          onLongpress: _cache[1] || (_cache[1] = ($event) => handleToggleMessageItem($event, unref31(messageModel), true)),
          onContextmenu: _cache[2] || (_cache[2] = withModifiers7(($event) => handleToggleMessageItem($event, unref31(messageModel)), ["prevent", "right"])),
          onTouchstart: _cache[3] || (_cache[3] = ($event) => handleH5LongPress($event, unref31(messageModel), "touchstart")),
          onTouchend: _cache[4] || (_cache[4] = ($event) => handleH5LongPress($event, unref31(messageModel), "touchend")),
          onMouseover: _cache[5] || (_cache[5] = ($event) => handleH5LongPress($event, unref31(messageModel), "touchend"))
        }, [
          createVNode16(MessageBubble, {
            messageItem: unref31(messageModel),
            content: unref31(messageModel).getMessageContent(),
            blinkMessageIDList: props.blinkMessageIDList,
            classNameList: props.bubbleClassNameList,
            onResendMessage: _cache[0] || (_cache[0] = ($event) => resendMessage(unref31(messageModel)))
          }, {
            messageElement: withCtx6(() => [
              !unref31(isUniFrameWork) ? renderSlot6(_ctx.$slots, "messageBubble", { key: 0 }, void 0, true) : createCommentVNode20("", true)
            ]),
            default: withCtx6(() => [
              unref31(isUniFrameWork) ? renderSlot6(_ctx.$slots, "messageBubble", { key: 0 }, void 0, true) : createCommentVNode20("", true)
            ]),
            _: 3
          }, 8, ["messageItem", "content", "blinkMessageIDList", "classNameList"])
        ], 32)) : createCommentVNode20("", true)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-plugin-layout.vue.mjs
var MessagePluginLayout = _export_sfc(_sfc_main31, [["__scopeId", "data-v-8fd6ea50"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-call/message-call-group.vue2.mjs
import { defineComponent as defineComponent32, computed as computed12, createElementBlock as createElementBlock32, createCommentVNode as createCommentVNode21, unref as unref32, openBlock as openBlock32, normalizeClass as normalizeClass22, toDisplayString as toDisplayString22 } from "vue";
var _sfc_main32 = defineComponent32({
  __name: "message-call-group",
  props: {
    message: { default: () => ({}) },
    signalingInfo: { default: () => ({}) },
    customContent: { default: () => ({}) },
    blinkMessageIDList: { default: () => [] }
  },
  setup(__props) {
    const props = __props;
    const TYPES = qt.TYPES;
    const isCallMessage2 = computed12(() => !!props.signalingInfo);
    const conversationType = computed12(() => {
      var _a3;
      return (_a3 = props.message) == null ? void 0 : _a3.conversationType;
    });
    const custom = computed12(() => {
      var _a3;
      return (_a3 = props.customContent) == null ? void 0 : _a3.custom;
    });
    const isBlink = computed12(() => {
      var _a3, _b3;
      if ((_a3 = props.message) == null ? void 0 : _a3.ID) {
        return (_b3 = props.blinkMessageIDList) == null ? void 0 : _b3.includes(props.message.ID);
      }
      return false;
    });
    return (_ctx, _cache) => {
      return unref32(isCallMessage2) && unref32(conversationType) === unref32(TYPES).CONV_GROUP ? (openBlock32(), createElementBlock32("div", {
        key: 0,
        class: normalizeClass22({ "blink-text": unref32(isBlink) })
      }, toDisplayString22(unref32(custom)), 3)) : createCommentVNode21("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-call/message-call-group.vue.mjs
var MessageCallGroup = _export_sfc(_sfc_main32, [["__scopeId", "data-v-c8d1a674"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-call/message-call-c2c.vue2.mjs
import { defineComponent as defineComponent33, ref as ref25, computed as computed13, createElementBlock as createElementBlock33, createCommentVNode as createCommentVNode22, unref as unref33, openBlock as openBlock33, normalizeClass as normalizeClass23, createElementVNode as createElementVNode24, createVNode as createVNode17, toDisplayString as toDisplayString23 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/call-video.svg.mjs
var callVideoSVG = "data:image/svg+xml,%3csvg%20width='33'%20height='23'%20viewBox='0%200%2033%2023'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M0.5%204.33337C0.5%202.12424%202.29086%200.333374%204.5%200.333374H19.1667C21.3758%200.333374%2023.1667%202.12424%2023.1667%204.33337V18.3334C23.1667%2020.5425%2021.3758%2022.3334%2019.1667%2022.3334H4.5C2.29086%2022.3334%200.5%2020.5425%200.5%2018.3334V4.33337ZM4.5%205.45837C4.5%204.90609%204.94771%204.45837%205.5%204.45837H7.5C8.05228%204.45837%208.5%204.90609%208.5%205.45837V7.58337C8.5%208.13566%208.05228%208.58337%207.5%208.58337H5.5C4.94771%208.58337%204.5%208.13566%204.5%207.58337V5.45837ZM33%204.85879C33%203.68986%2031.7222%202.97013%2030.7225%203.576L25.5742%206.69633L25.3333%206.8423V7.12393V15.43V15.7017L25.5613%2015.8495L30.684%2019.1709C31.6819%2019.8179%2033%2019.1016%2033%2017.9122V4.85879ZM31.2408%204.43119C31.5741%204.22923%2032%204.46914%2032%204.85879V17.9122C32%2018.3087%2031.5606%2018.5475%2031.228%2018.3318L26.3333%2015.1583V7.40555L31.2408%204.43119Z'%20fill='%23333333'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/call-voice.svg.mjs
var callVoiceSVG = "data:image/svg+xml,%3csvg%20width='32'%20height='12'%20viewBox='0%200%2032%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8.6347%2011.9983C9.72788%2011.9992%2010.6193%2011.1223%2010.6362%2010.0292L10.673%207.64717C11.6292%207.36896%2013.5482%206.92739%2016.0961%206.92739C18.6443%206.92739%2020.5804%207.36912%2021.5479%207.64767L21.5621%209.97475C21.5689%2011.0721%2022.4585%2011.9591%2023.5559%2011.9625L29.9833%2011.9825C31.0878%2011.9859%2031.986%2011.0933%2031.9895%209.98883L32%206.68064C32%204.65824%2030.7746%202.85759%2028.9507%202.2C26.1675%201.1964%2021.6615%200%2016%200C10.3386%200%205.83262%201.1964%203.04934%202.2C2.38985%202.43778%201.80885%202.82489%201.33541%203.31805C0.499655%204.18858%200.000161509%205.38952%200%206.68064L0.00557949%209.99594C0.00743508%2011.0985%200.90127%2011.9916%202.00385%2011.9926L8.6347%2011.9983Z'%20fill='%23333333'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/offlinePushInfoManager/info.mjs
var chatOfflinePushInfo = {
  androidInfo: {
    sound: "private_ring.mp3",
    XiaoMiChannelID: "high_custom_1",
    OPPOChannelID: "tuikit"
  },
  apnsInfo: {
    sound: "01.caf",
    image: "https://web.sdk.qcloud.com/im/demo/latest/faviconnew.png"
  }
};
var callOfflinePushInfo = {
  title: "call",
  description: "you have a call",
  androidSound: "private_ring",
  androidOPPOChannelID: "tuikit",
  iOSSound: "01.caf"
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/offlinePushInfoManager/const.mjs
var DEFAULT_DESC = {
  [qt.TYPES.MSG_TEXT]: "[文本]",
  [qt.TYPES.MSG_FACE]: "[动画表情]",
  [qt.TYPES.MSG_IMAGE]: "[图片]",
  [qt.TYPES.MSG_FILE]: "[文件]",
  [qt.TYPES.MSG_AUDIO]: "[语音]",
  [qt.TYPES.MSG_VIDEO]: "[视频]",
  [qt.TYPES.MSG_LOCATION]: "[地理位置]",
  [qt.TYPES.MSG_MERGER]: "[聊天记录]",
  [qt.TYPES.MSG_CUSTOM]: "[自定义消息]"
};
var PUSH_SCENE = ((PUSH_SCENE2) => {
  PUSH_SCENE2["CHAT"] = "chat";
  PUSH_SCENE2["CALL"] = "call";
  return PUSH_SCENE2;
})(PUSH_SCENE || {});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/offlinePushInfoManager/offlinePushInfoManager.mjs
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
var _OfflinePushInfoManager = class _OfflinePushInfoManager2 {
  constructor() {
    __publicField4(this, "name", "OfflinePushInfoManager");
    __publicField4(this, "offlinePushInfo", {});
    this.offlinePushInfo = {
      [PUSH_SCENE.CHAT]: chatOfflinePushInfo,
      [PUSH_SCENE.CALL]: callOfflinePushInfo
    };
  }
  static getInstance() {
    if (!_OfflinePushInfoManager2.instance) {
      _OfflinePushInfoManager2.instance = new _OfflinePushInfoManager2();
    }
    return _OfflinePushInfoManager2.instance;
  }
  getOfflinePushInfo(scene) {
    if (!Object.values(PUSH_SCENE).includes(scene)) {
      console.error(`${this.name} getOfflinePushInfo scene: ${scene} is invalid`);
      return null;
    }
    return this.offlinePushInfo[scene];
  }
  genTitle(conversation, userInfo) {
    let title = conversation == null ? void 0 : conversation.getShowName();
    if (conversation.type === qt.TYPES.CONV_C2C) {
      title = (userInfo == null ? void 0 : userInfo.nick) || (userInfo == null ? void 0 : userInfo.userID);
    }
    return title;
  }
  genDesc(messageType, payload) {
    let desc = "";
    if (messageType === qt.TYPES.MSG_TEXT) {
      desc = transformTextWithKeysToEmojiNames(payload.text);
    }
    if (messageType === qt.TYPES.MSG_CUSTOM) {
      desc = payload.description;
    }
    return desc || Wt.t(`TUIChat.${DEFAULT_DESC[messageType]}`);
  }
  create(options) {
    var _a3;
    const { conversation, messageType = "", payload = {} } = options || {};
    const userInfo = Jt.getData(o.USER, "userProfile");
    const entity = {
      sender: conversation.type === qt.TYPES.CONV_GROUP ? (_a3 = conversation.groupProfile) == null ? void 0 : _a3.groupID : userInfo == null ? void 0 : userInfo.userID,
      nickName: userInfo == null ? void 0 : userInfo.nick,
      chatType: conversation.type === qt.TYPES.CONV_GROUP ? 2 : 1,
      version: 1,
      action: 1
    };
    return {
      title: this.genTitle(conversation, userInfo),
      description: this.genDesc(messageType, payload),
      extension: JSON.stringify({ entity }),
      ...this.offlinePushInfo[PUSH_SCENE.CHAT]
    };
  }
};
__publicField4(_OfflinePushInfoManager, "instance", null);
var OfflinePushInfoManager = _OfflinePushInfoManager;

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/offlinePushInfoManager/index.mjs
var OfflinePushInfoManager2 = OfflinePushInfoManager.getInstance();

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-call/message-call-c2c.vue2.mjs
var _hoisted_131 = { class: "call-content" };
var _sfc_main33 = defineComponent33({
  __name: "message-call-c2c",
  props: {
    message: {
      type: Object,
      default: () => ({})
    },
    signalingInfo: {
      type: Object,
      default: () => ({})
    },
    customContent: {
      type: Object,
      default: () => ({})
    }
  },
  setup(__props) {
    const props = __props;
    const TYPES = ref25(qt.TYPES);
    const isCallMessage2 = computed13(() => props.signalingInfo != null);
    const callInfo = computed13(() => {
      var _a3, _b3;
      const callType = (_b3 = JSONToObject((_a3 = props.signalingInfo) == null ? void 0 : _a3.data)) == null ? void 0 : _b3.call_type;
      switch (callType) {
        case 1:
          return {
            type: 1,
            icon: callVoiceSVG
          };
        case 2:
          return {
            type: 2,
            icon: callVideoSVG
          };
      }
      return {
        type: 0,
        icon: ""
      };
    });
    const conversationType = computed13(() => {
      var _a3;
      return (_a3 = props.message) == null ? void 0 : _a3.conversationType;
    });
    const custom = computed13(() => {
      var _a3;
      return (_a3 = props.customContent) == null ? void 0 : _a3.custom;
    });
    const callAgain = () => {
      var _a3, _b3, _c2, _d2;
      if (conversationType.value === qt.TYPES.CONV_C2C) {
        const userID = ((_a3 = props.message) == null ? void 0 : _a3.flow) === "out" ? (_b3 = props.message) == null ? void 0 : _b3.to : (_c2 = props.message) == null ? void 0 : _c2.from;
        R.callService({
          serviceName: E.TUICalling.SERVICE.NAME,
          method: E.TUICalling.SERVICE.METHOD.START_CALL,
          params: {
            userIDList: [userID],
            type: (_d2 = callInfo == null ? void 0 : callInfo.value) == null ? void 0 : _d2.type,
            callParams: {
              offlinePushInfo: OfflinePushInfoManager2.getOfflinePushInfo(PUSH_SCENE.CALL)
            }
          }
        });
      }
    };
    return (_ctx, _cache) => {
      return unref33(isCallMessage2) && unref33(conversationType) === unref33(TYPES).CONV_C2C ? (openBlock33(), createElementBlock33("div", {
        key: 0,
        class: normalizeClass23(["call", ["call-" + unref33(conversationType), __props.message.flow === "out" && "call-reverse"]]),
        onClick: callAgain
      }, [
        createElementVNode24("div", {
          class: normalizeClass23(["icon", __props.message.flow === "out" && unref33(callInfo).type === 2 && "icon-reverse"])
        }, [
          createVNode17(Icon, {
            file: unref33(callInfo).icon
          }, null, 8, ["file"])
        ], 2),
        createElementVNode24("span", _hoisted_131, toDisplayString23(unref33(custom)), 1)
      ], 2)) : createCommentVNode22("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-call/message-call-c2c.vue.mjs
var MessageCallC2C = _export_sfc(_sfc_main33, [["__scopeId", "data-v-96c8717e"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-customer/message-customer-service.vue2.mjs
import { defineComponent as defineComponent34 } from "vue";
var _sfc_main34 = defineComponent34({
  __name: "message-customer-service",
  props: {
    message: { default: () => ({}) }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return null;
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-customer/message-customer-service.vue.mjs
var MessageCustomerService = _export_sfc(_sfc_main34, [["__scopeId", "data-v-dcbdb24a"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-room/message-room-default.vue2.mjs
import { defineComponent as defineComponent35, createElementBlock as createElementBlock34, openBlock as openBlock34, normalizeClass as normalizeClass24, unref as unref34, toDisplayString as toDisplayString24 } from "vue";
var _sfc_main35 = defineComponent35({
  __name: "message-room-default",
  props: {
    message: { default: () => ({}) }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock34(), createElementBlock34("div", {
        class: normalizeClass24([
          "room-default",
          unref34(isUniFrameWork) && "room-default-uni",
          props.message.flow === "in" ? "room-default-in" : "room-default-out"
        ])
      }, toDisplayString24(unref34(Wt).t("message.custom.自定义消息")), 3);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-room/message-room-default.vue.mjs
var MessageRoom = _export_sfc(_sfc_main35, [["__scopeId", "data-v-3183e690"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-plugin.vue2.mjs
var _sfc_main36 = defineComponent36({
  __name: "message-plugin",
  props: {
    message: { default: () => ({}) },
    blinkMessageIDList: { default: () => [] }
  },
  emits: ["resendMessage", "handleToggleMessageItem", "handleH5LongPress"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const messageModel = computed14(() => Jt.getMessageModel(props.message.ID));
    const messageSignalingInfo = computed14(() => {
      var _a3;
      return (_a3 = messageModel == null ? void 0 : messageModel.value) == null ? void 0 : _a3.getSignalingInfo();
    });
    const messageCustomContent = computed14(() => {
      var _a3;
      return (_a3 = messageModel == null ? void 0 : messageModel.value) == null ? void 0 : _a3.getMessageContent();
    });
    const pluginMessageType = computed14(() => {
      var _a3;
      let typeObj = { pluginType: "", showStyle: "" };
      if (isCallMessage(messageModel.value)) {
        typeObj = {
          pluginType: "call",
          showStyle: ((_a3 = messageModel.value) == null ? void 0 : _a3.conversationType) === qt.TYPES.CONV_GROUP ? "tip" : "bubble"
        };
      } else if (isRoomCardMessage(messageModel.value)) {
        typeObj = {
          pluginType: "room",
          showStyle: "bubble"
        };
      }
      return typeObj;
    });
    const resendMessage = (message) => {
      emits("resendMessage", message);
    };
    const handleToggleMessageItem = (e, message, isLongpress = false) => {
      emits("handleToggleMessageItem", e, message, isLongpress);
    };
    const handleH5LongPress = (e, message, type) => {
      emits("handleH5LongPress", e, message, type);
    };
    return (_ctx, _cache) => {
      return openBlock35(), createBlock7(MessagePluginLayout, {
        message: props.message,
        showStyle: unref35(pluginMessageType).showStyle,
        bubbleClassNameList: [unref35(pluginMessageType).pluginType === "room" ? "message-bubble-room" : ""],
        onResendMessage: resendMessage,
        onHandleToggleMessageItem: handleToggleMessageItem,
        onHandleH5LongPress: handleH5LongPress
      }, {
        messageTip: withCtx7(() => [
          createVNode18(MessageCallGroup, {
            message: props.message,
            signalingInfo: unref35(messageSignalingInfo),
            customContent: unref35(messageCustomContent),
            blinkMessageIDList: props.blinkMessageIDList
          }, null, 8, ["message", "signalingInfo", "customContent", "blinkMessageIDList"])
        ]),
        messageBubble: withCtx7(() => [
          unref35(pluginMessageType).pluginType === "call" ? (openBlock35(), createBlock7(MessageCallC2C, {
            key: 0,
            message: props.message,
            signalingInfo: unref35(messageSignalingInfo),
            customContent: unref35(messageCustomContent)
          }, null, 8, ["message", "signalingInfo", "customContent"])) : createCommentVNode23("", true),
          unref35(pluginMessageType).pluginType === "customer" ? (openBlock35(), createBlock7(MessageCustomerService, {
            key: 1,
            message: props.message
          }, null, 8, ["message"])) : createCommentVNode23("", true),
          unref35(pluginMessageType).pluginType === "room" ? (openBlock35(), createBlock7(MessageRoom, {
            key: 2,
            message: props.message
          }, null, 8, ["message"])) : createCommentVNode23("", true)
        ]),
        _: 1
      }, 8, ["message", "showStyle", "bubbleClassNameList"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/plugins/plugin-components/message-plugin.vue.mjs
var MessagePlugin = _export_sfc(_sfc_main36, [["__scopeId", "data-v-0e263a95"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/scroll-button/index.vue2.mjs
import { defineComponent as defineComponent37, ref as ref26, computed as computed15, watch as watch11, onMounted as onMounted12, onUnmounted as onUnmounted8, createElementBlock as createElementBlock35, createCommentVNode as createCommentVNode24, unref as unref36, openBlock as openBlock36, createVNode as createVNode19, createElementVNode as createElementVNode25, toDisplayString as toDisplayString25 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/double-arrow.svg.mjs
var doubleArrowIcon = "data:image/svg+xml,%3csvg%20t='1660053550964'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='3181'%20width='200'%20height='200'%3e%3cpath%20d='M95.658667%20461.354667a71.637333%2071.637333%200%200%200%200%20101.290666l365.696%20365.696a71.637333%2071.637333%200%200%200%20101.290666%200l365.696-365.696a71.637333%2071.637333%200%201%200-101.248-101.290666L512%20776.448l-315.093333-315.093333a71.594667%2071.594667%200%200%200-101.248%200z'%20p-id='3182'%20fill='%23bfbfbf'%3e%3c/path%3e%3cpath%20d='M95.658667%2095.658667a71.637333%2071.637333%200%200%200%200%20101.248l365.696%20365.738666a71.594667%2071.594667%200%200%200%20101.290666%200l365.696-365.738666a71.637333%2071.637333%200%200%200-101.248-101.248L512%20410.709333%20196.906667%2095.658667a71.637333%2071.637333%200%200%200-101.248%200z'%20p-id='3183'%20fill='%23bfbfbf'%3e%3c/path%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/scroll-button/index.vue2.mjs
var _hoisted_133 = { class: "scroll-button-text" };
var _sfc_main37 = defineComponent37({
  __name: "index",
  emits: ["scrollToLatestMessage"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    const messageList = ref26([]);
    const currentConversationID2 = ref26("");
    const currentLastMessageTime = ref26(0);
    const newMessageCount = ref26(0);
    const isScrollOverOneScreen = ref26(false);
    const isExistLastMessage = ref26(false);
    const isScrollButtonVisible = ref26(false);
    const scrollButtonContent = computed15(
      () => newMessageCount.value ? `${newMessageCount.value}${Wt.t("TUIChat.条新消息")}` : Wt.t("TUIChat.回到最新位置")
    );
    watch11(
      () => [isScrollOverOneScreen.value, isExistLastMessage.value],
      () => {
        isScrollButtonVisible.value = isScrollOverOneScreen.value || isExistLastMessage.value;
        if (!isScrollButtonVisible.value) {
          resetNewMessageCount();
        }
      },
      { immediate: true }
    );
    onMounted12(() => {
      Jt.watch(o.CHAT, {
        messageList: onMessageListUpdated,
        newMessageList: onNewMessageListUpdated
      });
      Jt.watch(o.CONV, {
        currentConversation: onCurrentConversationUpdated
      });
    });
    onUnmounted8(() => {
      Jt.unwatch(o.CHAT, {
        messageList: onMessageListUpdated,
        newMessageList: onNewMessageListUpdated
      });
      Jt.unwatch(o.CONV, {
        currentConversation: onCurrentConversationUpdated
      });
    });
    function isTypingMessage(message) {
      var _a3, _b3;
      return ((_b3 = JSONToObject((_a3 = message.payload) == null ? void 0 : _a3.data)) == null ? void 0 : _b3.businessID) === "user_typing_status";
    }
    function onMessageListUpdated(newMessageList) {
      var _a3, _b3;
      messageList.value = newMessageList || [];
      const lastMessage = (_b3 = messageList.value) == null ? void 0 : _b3[((_a3 = messageList.value) == null ? void 0 : _a3.length) - 1];
      isExistLastMessage.value = !!(lastMessage && (lastMessage == null ? void 0 : lastMessage.time) < (currentLastMessageTime == null ? void 0 : currentLastMessageTime.value));
    }
    function onNewMessageListUpdated(newMessageList) {
      if (Array.isArray(newMessageList) && isScrollButtonVisible.value) {
        newMessageList.forEach((message) => {
          if (message && message.conversationID === currentConversationID2.value && !message.isDeleted && !message.isRevoked && !isTypingMessage(message)) {
            newMessageCount.value += 1;
          }
        });
      }
    }
    function onCurrentConversationUpdated(conversation) {
      var _a3;
      if ((conversation == null ? void 0 : conversation.conversationID) !== currentConversationID2.value) {
        resetNewMessageCount();
      }
      currentConversationID2.value = (conversation == null ? void 0 : conversation.conversationID) || "";
      currentLastMessageTime.value = ((_a3 = conversation == null ? void 0 : conversation.lastMessage) == null ? void 0 : _a3.lastTime) || 0;
    }
    async function judgeScrollOverOneScreen(e) {
      var _a3, _b3, _c2, _d2, _e2;
      if (e.target) {
        try {
          const { height } = await T(`#${(_a3 = e.target) == null ? void 0 : _a3.id}`, "messageList") || {};
          const scrollHeight = ((_b3 = e.target) == null ? void 0 : _b3.scrollHeight) || ((_c2 = e.detail) == null ? void 0 : _c2.scrollHeight);
          const scrollTop = ((_d2 = e.target) == null ? void 0 : _d2.scrollTop) || ((_e2 = e.detail) == null ? void 0 : _e2.scrollTop) || 0;
          if (scrollHeight - scrollTop > 2 * height) {
            isScrollOverOneScreen.value = true;
            return;
          }
          isScrollOverOneScreen.value = false;
        } catch (error) {
          isScrollOverOneScreen.value = false;
        }
      }
    }
    function resetMessageSource() {
      if (Jt.getData(o.CHAT, "messageSource") !== void 0) {
        Jt.update(o.CHAT, "messageSource", void 0);
      }
    }
    function resetNewMessageCount() {
      newMessageCount.value = 0;
    }
    function scrollToMessageListBottom() {
      resetMessageSource();
      resetNewMessageCount();
      emits("scrollToLatestMessage");
    }
    __expose({
      judgeScrollOverOneScreen,
      isScrollButtonVisible
    });
    return (_ctx, _cache) => {
      return unref36(isScrollButtonVisible) ? (openBlock36(), createElementBlock35("div", {
        key: 0,
        class: "scroll-button",
        onClick: scrollToMessageListBottom
      }, [
        createVNode19(Icon, {
          width: "10px",
          height: "10px",
          file: unref36(doubleArrowIcon)
        }, null, 8, ["file"]),
        createElementVNode25("div", _hoisted_133, toDisplayString25(unref36(scrollButtonContent)), 1)
      ])) : createCommentVNode24("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/scroll-button/index.vue.mjs
var ScrollButton = _export_sfc(_sfc_main37, [["__scopeId", "data-v-650a7132"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/read-receipt-panel/index.vue2.mjs
import { defineComponent as defineComponent39, ref as ref28, onMounted as onMounted14, nextTick as nextTick4, watch as watch13, createBlock as createBlock8, openBlock as openBlock38, withCtx as withCtx8, createElementVNode as createElementVNode27, normalizeClass as normalizeClass25, unref as unref38, toDisplayString as toDisplayString27, createVNode as createVNode20, createElementBlock as createElementBlock37, Fragment as Fragment11, renderList as renderList9, createCommentVNode as createCommentVNode25 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/FetchMore/index.vue2.mjs
import { defineComponent as defineComponent38, ref as ref27, getCurrentInstance, onMounted as onMounted13, onUnmounted as onUnmounted9, watch as watch12, createElementBlock as createElementBlock36, openBlock as openBlock37, renderSlot as renderSlot7, createElementVNode as createElementVNode26, toDisplayString as toDisplayString26, unref as unref37 } from "vue";
var _sfc_main38 = defineComponent38({
  __name: "index",
  props: {
    isFetching: { type: Boolean, default: false },
    isTerminateObserve: { type: Boolean, default: false }
  },
  emits: ["onExposed"],
  setup(__props, { emit: __emit }) {
    var _a3;
    const emits = __emit;
    const props = __props;
    let observer = null;
    const selfDomRef = ref27();
    const thisInstance = ((_a3 = getCurrentInstance()) == null ? void 0 : _a3.proxy) || getCurrentInstance();
    onMounted13(() => {
      if (props.isTerminateObserve) {
        return;
      }
      if (!isUniFrameWork) {
        observer = new IntersectionObserver(([entry]) => {
          if (entry.isIntersecting) {
            emits("onExposed");
          }
        }, {
          threshold: 1
        });
        if (selfDomRef.value) {
          observer.observe(selfDomRef.value);
        }
      } else {
        observer = uni.createIntersectionObserver(thisInstance).relativeToViewport();
        observer.observe(".fetch-more-block", () => {
          emits("onExposed");
        });
      }
    });
    onUnmounted9(() => {
      if (observer) {
        observer.disconnect();
        observer = null;
      }
    });
    watch12(() => props.isTerminateObserve, (isTerminateObserve) => {
      if (!observer) {
        return;
      }
      if (isTerminateObserve) {
        observer.disconnect();
      } else if (selfDomRef.value) {
        observer.disconnect();
        if (!isUniFrameWork) {
          observer.observe(selfDomRef.value);
        } else {
          observer.observe(".fetch-more-block", () => {
            emits("onExposed");
          });
        }
      }
    });
    return (_ctx, _cache) => {
      return openBlock37(), createElementBlock36("div", {
        ref_key: "selfDomRef",
        ref: selfDomRef,
        class: "fetch-more-block"
      }, [
        props.isFetching ? renderSlot7(_ctx.$slots, "fetching", { key: 0 }, () => [
          createElementVNode26("div", null, toDisplayString26(unref37(Wt).t("TUIChat.正在加载")), 1)
        ], true) : renderSlot7(_ctx.$slots, "fetchEnd", { key: 1 }, () => [
          createElementVNode26("div", null, toDisplayString26(unref37(Wt).t("TUIChat.加载结束")), 1)
        ], true)
      ], 512);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/FetchMore/index.vue.mjs
var FetchMore = _export_sfc(_sfc_main38, [["__scopeId", "data-v-a245d20e"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/read-receipt-panel/index.vue2.mjs
var _hoisted_134 = { class: "header" };
var _hoisted_223 = { class: "header-text" };
var _hoisted_311 = { class: "header-close-icon" };
var _hoisted_48 = { class: "read-status-counter-container" };
var _hoisted_57 = ["onClick"];
var _hoisted_66 = { class: "status-text" };
var _hoisted_74 = { class: "status-count" };
var _hoisted_84 = { class: "read-status-member-list" };
var _hoisted_94 = {
  key: 0,
  class: "empty-list-tip"
};
var _hoisted_104 = { class: "username" };
var _hoisted_1110 = { class: "username" };
var _hoisted_1210 = {
  key: 2,
  class: "fetch-more-container"
};
var _sfc_main39 = defineComponent39({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  emits: ["setReadReceiptPanelVisible"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    let lastUnreadCursor = "";
    let lastReadCursor = "";
    const tabNameList = ["unread", "read"];
    const isListFetchCompleted = {
      unread: false,
      read: false,
      close: false
    };
    const isPullDownFetching = ref28(false);
    const isPanelClose = ref28(false);
    const isFirstLoadFinished = ref28(false);
    const isStopFetchMore = ref28(false);
    const currentTabName = ref28("unread");
    const tabInfo = ref28(generateInitalTabInfo());
    onMounted14(async () => {
      await initAndRefetchReceiptInfomation();
      nextTick4(() => {
        isFirstLoadFinished.value = true;
      });
    });
    watch13(
      () => props.message.readReceiptInfo.readCount,
      () => {
        initAndRefetchReceiptInfomation();
      }
    );
    async function fetchGroupMessageRecriptMemberListByType(readType = "all") {
      const message = Jt.getMessageModel(props.message.ID);
      let unreadResult = {};
      let readResult = {};
      if (readType === "all" || readType === "unread") {
        unreadResult = await Qt.getGroupMessageReadMemberList({
          message,
          filter: 1,
          cursor: lastUnreadCursor,
          count: 100
        });
        if (unreadResult) {
          lastUnreadCursor = unreadResult.data.cursor;
          if (unreadResult.data.isCompleted) {
            isListFetchCompleted.unread = true;
          }
        }
      }
      if (readType === "all" || readType === "read") {
        readResult = await Qt.getGroupMessageReadMemberList({
          message,
          filter: 0,
          cursor: lastReadCursor,
          count: 100
        });
        if (readResult) {
          lastReadCursor = readResult.data.cursor;
          if (readResult.data.isCompleted) {
            isListFetchCompleted.read = true;
          }
        }
      }
      const { unreadCount: totalUnreadCount, readCount: totalReadCount } = message.readReceiptInfo;
      return {
        unreadResult: {
          count: totalUnreadCount,
          ...unreadResult.data
        },
        readResult: {
          count: totalReadCount,
          ...readResult.data
        }
      };
    }
    async function pullDownFetchMoreData() {
      if (isListFetchCompleted[currentTabName.value] || isPullDownFetching.value) {
        return;
      }
      isPullDownFetching.value = true;
      if (currentTabName.value === "unread" || currentTabName.value === "read") {
        const { unreadResult, readResult } = await fetchGroupMessageRecriptMemberListByType(currentTabName.value);
        checkStopFetchMore();
        try {
          tabInfo.value.unread.memberList = tabInfo.value.unread.memberList.concat(unreadResult.unreadUserInfoList || []);
          tabInfo.value.read.memberList = tabInfo.value.read.memberList.concat(readResult.readUserInfoList || []);
        } finally {
          isPullDownFetching.value = false;
        }
      }
    }
    async function initAndRefetchReceiptInfomation() {
      lastUnreadCursor = "";
      lastReadCursor = "";
      isStopFetchMore.value = false;
      isListFetchCompleted.unread = false;
      isListFetchCompleted.read = false;
      const { unreadResult, readResult } = await fetchGroupMessageRecriptMemberListByType("all");
      checkStopFetchMore();
      resetTabInfo("read", readResult.count, readResult.readUserInfoList);
      resetTabInfo("unread", unreadResult.count, unreadResult.unreadUserInfoList);
      resetTabInfo("close");
    }
    function checkStopFetchMore() {
      if (isListFetchCompleted.read && isListFetchCompleted.unread) {
        isStopFetchMore.value = true;
      }
    }
    function resetTabInfo(tabName, count, memberList2) {
      tabInfo.value[tabName].count = count;
      tabInfo.value[tabName].memberList = memberList2 || [];
    }
    function generateInitalTabInfo() {
      return {
        read: {
          tabName: Wt.t("TUIChat.已读"),
          count: void 0,
          memberList: []
        },
        unread: {
          tabName: Wt.t("TUIChat.未读"),
          count: void 0,
          memberList: []
        },
        close: {
          tabName: Wt.t("TUIChat.关闭"),
          count: void 0,
          memberList: []
        }
      };
    }
    function toggleTabName(tabName) {
      currentTabName.value = tabName;
    }
    function closeReadReceiptPanel() {
      isPanelClose.value = true;
      setTimeout(() => {
        emits("setReadReceiptPanelVisible", false);
      }, 200);
    }
    return (_ctx, _cache) => {
      return openBlock38(), createBlock8(Overlay, {
        maskColor: "transparent",
        onOnOverlayClick: closeReadReceiptPanel
      }, {
        default: withCtx8(() => [
          createElementVNode27("div", {
            class: normalizeClass25({
              "read-receipt-panel": true,
              "read-receipt-panel-mobile": unref38(isMobile),
              "read-receipt-panel-uni": unref38(isUniFrameWork),
              "read-receipt-panel-close-mobile": unref38(isMobile) && unref38(isPanelClose)
            })
          }, [
            createElementVNode27("div", _hoisted_134, [
              createElementVNode27("div", _hoisted_223, toDisplayString27(unref38(Wt).t("TUIChat.消息详情")), 1),
              createElementVNode27("div", _hoisted_311, [
                createVNode20(Icon, {
                  size: "12px",
                  hotAreaSize: "8",
                  file: unref38(closeIcon2),
                  onOnClick: closeReadReceiptPanel
                }, null, 8, ["file"])
              ])
            ]),
            createElementVNode27("div", _hoisted_48, [
              (openBlock38(), createElementBlock37(Fragment11, null, renderList9(tabNameList, (tabName) => {
                return createElementVNode27("div", {
                  key: tabName,
                  class: normalizeClass25({
                    "read-status-counter": true,
                    "active": tabName === unref38(currentTabName)
                  }),
                  onClick: ($event) => toggleTabName(tabName)
                }, [
                  createElementVNode27("div", _hoisted_66, toDisplayString27(unref38(tabInfo)[tabName].tabName), 1),
                  createElementVNode27("div", _hoisted_74, toDisplayString27(unref38(tabInfo)[tabName].count === void 0 ? "" : unref38(tabInfo)[tabName].count), 1)
                ], 10, _hoisted_57);
              }), 64))
            ]),
            createElementVNode27("div", _hoisted_84, [
              unref38(tabInfo)[unref38(currentTabName)].count === 0 && unref38(isFirstLoadFinished) ? (openBlock38(), createElementBlock37("div", _hoisted_94, " - " + toDisplayString27(unref38(Wt).t("TUIChat.空")) + " - ", 1)) : unref38(isFirstLoadFinished) ? (openBlock38(), createElementBlock37(Fragment11, { key: 1 }, [
                unref38(currentTabName) === "unread" ? (openBlock38(true), createElementBlock37(Fragment11, { key: 0 }, renderList9(unref38(tabInfo)[unref38(currentTabName)].memberList, (item) => {
                  return openBlock38(), createElementBlock37("div", {
                    key: item.userID,
                    class: "read-status-member-container"
                  }, [
                    createVNode20(Avatar, {
                      class: "read-status-avatar",
                      useSkeletonAnimation: "",
                      url: item.avatar || ""
                    }, null, 8, ["url"]),
                    createElementVNode27("div", _hoisted_104, toDisplayString27(item.nick || item.userID), 1)
                  ]);
                }), 128)) : createCommentVNode25("", true),
                unref38(currentTabName) === "read" ? (openBlock38(true), createElementBlock37(Fragment11, { key: 1 }, renderList9(unref38(tabInfo)[unref38(currentTabName)].memberList, (item) => {
                  return openBlock38(), createElementBlock37("div", {
                    key: item.userID,
                    class: "read-status-member-container"
                  }, [
                    createVNode20(Avatar, {
                      class: "read-status-avatar",
                      useSkeletonAnimation: "",
                      url: item.avatar
                    }, null, 8, ["url"]),
                    createElementVNode27("div", _hoisted_1110, toDisplayString27(item.nick || item.userID), 1)
                  ]);
                }), 128)) : createCommentVNode25("", true)
              ], 64)) : createCommentVNode25("", true),
              unref38(isFirstLoadFinished) ? (openBlock38(), createElementBlock37("div", _hoisted_1210, [
                createVNode20(FetchMore, {
                  isFetching: unref38(isPullDownFetching),
                  isTerminateObserve: unref38(isStopFetchMore),
                  onOnExposed: pullDownFetchMoreData
                }, null, 8, ["isFetching", "isTerminateObserve"])
              ])) : createCommentVNode25("", true)
            ])
          ], 2)
        ]),
        _: 1
      });
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/read-receipt-panel/index.vue.mjs
var ReadReceiptPanel = _export_sfc(_sfc_main39, [["__scopeId", "data-v-767e085a"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Dialog/index.vue2.mjs
import { defineComponent as defineComponent40, ref as ref29, watchEffect as watchEffect8, createElementBlock as createElementBlock38, createCommentVNode as createCommentVNode26, unref as unref39, openBlock as openBlock39, withModifiers as withModifiers8, normalizeClass as normalizeClass26, createElementVNode as createElementVNode28, toDisplayString as toDisplayString28, renderSlot as renderSlot8 } from "vue";
var _hoisted_135 = {
  key: 0,
  class: "dialog-main-header"
};
var _hoisted_224 = { class: "dialog-main-title" };
var _hoisted_312 = {
  key: 1,
  class: "dialog-main-footer"
};
var _sfc_main40 = defineComponent40({
  __name: "index",
  props: {
    show: {
      type: Boolean,
      default: false
    },
    isHeaderShow: {
      type: Boolean,
      default: true
    },
    isFooterShow: {
      type: Boolean,
      default: true
    },
    background: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ""
    },
    center: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:show", "submit"],
  setup(__props, { emit: __emit }) {
    const clickType = {
      OUTSIDE: "outside",
      INSIDE: "inside"
    };
    const props = __props;
    const showDialog = ref29(false);
    const isHeaderShowDialog = ref29(true);
    const isFooterShowDialog = ref29(true);
    const backgroundDialog = ref29(true);
    const showTitle = ref29("");
    watchEffect8(() => {
      showDialog.value = props.show;
      showTitle.value = props.title;
      isHeaderShowDialog.value = props.isHeaderShow;
      isFooterShowDialog.value = props.isFooterShow;
      backgroundDialog.value = props.background;
    });
    const emit = __emit;
    const toggleView = (type) => {
      if (type === clickType.OUTSIDE) {
        close3();
      }
    };
    const close3 = () => {
      showDialog.value = !showDialog.value;
      emit("update:show", showDialog.value);
    };
    const submit = () => {
      emit("submit");
      close3();
    };
    return (_ctx, _cache) => {
      return unref39(showDialog) ? (openBlock39(), createElementBlock38("div", {
        key: 0,
        class: normalizeClass26(["dialog", [!unref39(isPC) ? "dialog-h5" : "", __props.center ? "center" : ""]]),
        onClick: _cache[1] || (_cache[1] = withModifiers8(($event) => toggleView(clickType.OUTSIDE), ["stop", "prevent"]))
      }, [
        createElementVNode28("main", {
          class: normalizeClass26(["dialog-main", [!unref39(backgroundDialog) ? "dialog-main-back" : ""]]),
          onClick: _cache[0] || (_cache[0] = withModifiers8(($event) => toggleView(clickType.INSIDE), ["stop", "prevent"]))
        }, [
          unref39(isHeaderShowDialog) ? (openBlock39(), createElementBlock38("header", _hoisted_135, [
            createElementVNode28("h1", _hoisted_224, toDisplayString28(unref39(showTitle)), 1),
            createElementVNode28("i", {
              class: "icon icon-close",
              onClick: close3
            })
          ])) : createCommentVNode26("", true),
          createElementVNode28("div", {
            class: normalizeClass26(["dialog-main-content", [unref39(isUniFrameWork) && unref39(isH5) ? "dialog-main-content-uniapp" : ""]])
          }, [
            renderSlot8(_ctx.$slots, "default", {}, void 0, true)
          ], 2),
          unref39(isFooterShowDialog) ? (openBlock39(), createElementBlock38("footer", _hoisted_312, [
            createElementVNode28("button", {
              class: "btn btn-cancel",
              onClick: close3
            }, toDisplayString28(unref39(Wt).t("component.取消")), 1),
            createElementVNode28("button", {
              class: "btn btn-default",
              onClick: submit
            }, toDisplayString28(unref39(Wt).t("component.确定")), 1)
          ])) : createCommentVNode26("", true)
        ], 2)
      ], 2)) : createCommentVNode26("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Dialog/index.vue.mjs
var Dialog = _export_sfc(_sfc_main40, [["__scopeId", "data-v-9ac9ce3c"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/ImagePreviewer/index.vue2.mjs
import { defineComponent as defineComponent42, ref as ref30, watchEffect as watchEffect9, onMounted as onMounted15, onUnmounted as onUnmounted10, createElementBlock as createElementBlock40, openBlock as openBlock41, normalizeClass as normalizeClass27, unref as unref40, createElementVNode as createElementVNode29, withDirectives as withDirectives3, createCommentVNode as createCommentVNode27, withModifiers as withModifiers9, normalizeStyle as normalizeStyle10, Fragment as Fragment12, renderList as renderList10, createVNode as createVNode21, vShow as vShow3, toDisplayString as toDisplayString29 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/icon-arrow-left.svg.mjs
var iconArrowLeft = "data:image/svg+xml,%3c?xml%20version='1.0'%20standalone='no'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20class='icon'%20width='32px'%20height='32.00px'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23444444'%20d='M384%20512L731.733333%20202.666667c17.066667-14.933333%2019.2-42.666667%204.266667-59.733334-14.933333-17.066667-42.666667-19.2-59.733333-4.266666l-384%20341.333333c-10.666667%208.533333-14.933333%2019.2-14.933334%2032s4.266667%2023.466667%2014.933334%2032l384%20341.333333c8.533333%206.4%2019.2%2010.666667%2027.733333%2010.666667%2012.8%200%2023.466667-4.266667%2032-14.933333%2014.933333-17.066667%2014.933333-44.8-4.266667-59.733334L384%20512z'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/zoom-in.svg.mjs
var iconZoomIn = "data:image/svg+xml,%3c?xml%20version='1.0'%20standalone='no'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20class='icon'%20width='200px'%20height='200.00px'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23444444'%20d='M945.066667%20898.133333l-189.866667-189.866666c55.466667-64%2087.466667-149.333333%2087.466667-241.066667%200-204.8-168.533333-373.333333-373.333334-373.333333S96%20264.533333%2096%20469.333333%20264.533333%20842.666667%20469.333333%20842.666667c91.733333%200%20174.933333-34.133333%20241.066667-87.466667l189.866667%20189.866667c6.4%206.4%2014.933333%208.533333%2023.466666%208.533333s17.066667-2.133333%2023.466667-8.533333c8.533333-12.8%208.533333-34.133333-2.133333-46.933334zM469.333333%20778.666667C298.666667%20778.666667%20160%20640%20160%20469.333333S298.666667%20160%20469.333333%20160%20778.666667%20298.666667%20778.666667%20469.333333%20640%20778.666667%20469.333333%20778.666667z'%20/%3e%3cpath%20fill='%23444444'%20d='M597.333333%20437.333333h-96V341.333333c0-17.066667-14.933333-32-32-32s-32%2014.933333-32%2032v96H341.333333c-17.066667%200-32%2014.933333-32%2032s14.933333%2032%2032%2032h96V597.333333c0%2017.066667%2014.933333%2032%2032%2032s32-14.933333%2032-32v-96H597.333333c17.066667%200%2032-14.933333%2032-32s-14.933333-32-32-32z'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/zoom-out.svg.mjs
var iconZoomOut = "data:image/svg+xml,%3c?xml%20version='1.0'%20standalone='no'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20class='icon'%20width='200px'%20height='200.00px'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23444444'%20d='M945.066667%20898.133333l-189.866667-189.866666c55.466667-64%2087.466667-149.333333%2087.466667-241.066667%200-204.8-168.533333-373.333333-373.333334-373.333333S96%20264.533333%2096%20469.333333%20264.533333%20842.666667%20469.333333%20842.666667c91.733333%200%20174.933333-34.133333%20241.066667-87.466667l189.866667%20189.866667c6.4%206.4%2014.933333%208.533333%2023.466666%208.533333s17.066667-2.133333%2023.466667-8.533333c8.533333-12.8%208.533333-34.133333-2.133333-46.933334zM469.333333%20778.666667C298.666667%20778.666667%20160%20640%20160%20469.333333S298.666667%20160%20469.333333%20160%20778.666667%20298.666667%20778.666667%20469.333333%20640%20778.666667%20469.333333%20778.666667z'%20/%3e%3cpath%20fill='%23444444'%20d='M597.333333%20437.333333H341.333333c-17.066667%200-32%2014.933333-32%2032s14.933333%2032%2032%2032h256c17.066667%200%2032-14.933333%2032-32s-14.933333-32-32-32z'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/rotate-left.svg.mjs
var iconRotateLeft = "data:image/svg+xml,%3c?xml%20version='1.0'%20standalone='no'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20class='icon'%20width='200px'%20height='200.00px'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23444444'%20d='M672%20418H144c-17.7%200-32%2014.3-32%2032v414c0%2017.7%2014.3%2032%2032%2032h528c17.7%200%2032-14.3%2032-32V450c0-17.7-14.3-32-32-32z%20m-44%20402H188V494h440v326zM819.3%20328.5c-78.8-100.7-196-153.6-314.6-154.2l-0.2-64c0-6.5-7.6-10.1-12.6-6.1l-128%20101c-4%203.1-3.9%209.1%200%2012.3L492%20318.6c5.1%204%2012.7%200.4%2012.6-6.1v-63.9c12.9%200.1%2025.9%200.9%2038.8%202.5%2042.1%205.2%2082.1%2018.2%20119%2038.7%2038.1%2021.2%2071.2%2049.7%2098.4%2084.3%2027.1%2034.7%2046.7%2073.7%2058.1%20115.8%2011%2040.7%2014%2082.7%208.9%20124.8-0.7%205.4-1.4%2010.8-2.4%2016.1h74.9c14.8-103.6-11.3-213-81-302.3z'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/rotate-right.svg.mjs
var iconRotateRight = "data:image/svg+xml,%3c?xml%20version='1.0'%20standalone='no'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20class='icon'%20width='200px'%20height='200.00px'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23444444'%20d='M480.5%20251.2c13-1.6%2025.9-2.4%2038.8-2.5v63.9c0%206.5%207.5%2010.1%2012.6%206.1L660%20217.6c4-3.2%204-9.2%200-12.3l-128-101c-5.1-4-12.6-0.4-12.6%206.1l-0.2%2064c-118.6%200.5-235.8%2053.4-314.6%20154.2-69.6%2089.2-95.7%20198.6-81.1%20302.4h74.9c-0.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1%208.9-124.8%2011.4-42.2%2031-81.1%2058.1-115.8%2027.2-34.7%2060.3-63.2%2098.4-84.3%2037-20.6%2076.9-33.6%20119.1-38.8zM880%20418H352c-17.7%200-32%2014.3-32%2032v414c0%2017.7%2014.3%2032%2032%2032h528c17.7%200%2032-14.3%2032-32V450c0-17.7-14.3-32-32-32z%20m-44%20402H396V494h440v326z'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/download.svg.mjs
var iconDownload = "data:image/svg+xml,%3csvg%20width='11'%20height='17'%20viewBox='0%200%2011%2017'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.13023%2014.4401C9.3928%2014.4401%209.64461%2014.5444%209.83027%2014.73C10.0159%2014.9157%2010.1202%2015.1675%2010.1202%2015.4301C10.1202%2015.6926%2010.0159%2015.9445%209.83027%2016.1301C9.64461%2016.3158%209.3928%2016.4201%209.13023%2016.4201H1.87023C1.60767%2016.4201%201.35586%2016.3158%201.1702%2016.1301C0.984536%2015.9445%200.880234%2015.6926%200.880234%2015.4301C0.880234%2015.1675%200.984536%2014.9157%201.1702%2014.73C1.35586%2014.5444%201.60767%2014.4401%201.87023%2014.4401H9.13023ZM5.50023%200.580078C5.7628%200.580078%206.01461%200.684381%206.20027%200.870042C6.38593%201.0557%206.49023%201.30751%206.49023%201.57008V8.59446L8.40027%206.51084C8.57111%206.32101%208.8087%206.20455%209.06339%206.18578C9.31808%206.16702%209.57018%206.2474%209.767%206.41014C9.96381%206.57287%2010.0901%206.80537%2010.1196%207.05905C10.149%207.31274%2010.0792%207.56798%209.92487%207.77144L9.86019%207.84932L6.23019%2011.8093C6.05448%2012.001%205.81039%2012.1159%205.55068%2012.1291C5.29096%2012.1423%205.03648%2012.0528%204.84221%2011.8799L4.77027%2011.8093L1.14027%207.84932C0.968705%207.66225%200.875545%207.41643%200.880038%207.16264C0.884531%206.90885%200.986334%206.66648%201.16442%206.4856C1.3425%206.30472%201.58325%206.19916%201.83694%206.19071C2.09063%206.18226%202.33788%206.27158%202.52759%206.44022L2.60019%206.51084L4.51023%208.59578V1.57008C4.51023%201.30751%204.61454%201.0557%204.8002%200.870042C4.98586%200.684381%205.23767%200.580078%205.50023%200.580078Z'%20fill='%23444444'%20/%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/ImagePreviewer/image-item.vue.mjs
import { defineComponent as defineComponent41, createElementBlock as createElementBlock39, openBlock as openBlock40, normalizeStyle as normalizeStyle9 } from "vue";
var _hoisted_136 = ["src"];
var _sfc_main41 = defineComponent41({
  __name: "image-item",
  props: {
    zoom: {
      type: Number,
      default: 1
    },
    rotate: {
      type: Number,
      default: 0
    },
    src: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock40(), createElementBlock39("img", {
        class: "image-preview",
        style: normalizeStyle9({
          transform: `scale(${props.zoom}) rotate(${props.rotate}deg)`
        }),
        src: props.src
      }, null, 12, _hoisted_136);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/ImagePreviewer/index.vue2.mjs
var _hoisted_137 = { class: "image-counter" };
var _sfc_main42 = defineComponent42({
  __name: "index",
  props: {
    imageList: { default: () => [] },
    currentImage: {}
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const imageFormatMap = /* @__PURE__ */ new Map([
      [1, "jpg"],
      [2, "gif"],
      [3, "png"],
      [4, "bmp"]
    ]);
    const emit = __emit;
    const zoom = ref30(1);
    const rotate = ref30(0);
    const minZoom = ref30(0.1);
    const currentImageIndex = ref30(0);
    const image = ref30();
    const ulRef = ref30();
    let startX = 0;
    const touchStore = {};
    let moveFlag = false;
    let twoTouchesFlag = false;
    let timer = null;
    watchEffect9(() => {
      currentImageIndex.value = props.imageList.findIndex((message) => {
        var _a3;
        return message.ID === ((_a3 = props == null ? void 0 : props.currentImage) == null ? void 0 : _a3.ID);
      });
    });
    const isNumber2 = (value) => {
      return typeof value === "number" && isFinite(value);
    };
    const handleTouchStart = (e) => {
      e.preventDefault();
      moveInit(e);
      twoTouchesInit(e);
    };
    const handleTouchMove = (e) => {
      e.preventDefault();
      moveFlag = true;
      if (e.touches && e.touches.length === 2) {
        twoTouchesFlag = true;
        handleTwoTouches(e);
      }
    };
    const handleTouchEnd = (e) => {
      var _a3;
      e.preventDefault();
      e.stopPropagation();
      let moveEndX = 0;
      let X = 0;
      if (twoTouchesFlag) {
        if (!timer) {
          twoTouchesFlag = false;
          delete touchStore.pageX2;
          delete touchStore.pageY2;
          timer = setTimeout(() => {
            timer = null;
          }, 200);
        }
        return;
      }
      if (timer === null) {
        switch (moveFlag) {
          case true:
            moveEndX = (_a3 = e == null ? void 0 : e.changedTouches[0]) == null ? void 0 : _a3.pageX;
            X = moveEndX - startX;
            if (X > 100) {
              goPrev();
            } else if (X < -100) {
              goNext();
            }
            break;
          case false:
            close3();
            break;
        }
        timer = setTimeout(() => {
          timer = null;
        }, 200);
      }
    };
    const handleTouchCancel = () => {
      twoTouchesFlag = false;
      delete touchStore.pageX1;
      delete touchStore.pageY1;
    };
    const handleWheel = (e) => {
      e.preventDefault();
      if (Math.abs(e.deltaX) !== 0 && Math.abs(e.deltaY) !== 0)
        return;
      let scale = zoom.value;
      scale += e.deltaY * (e.ctrlKey ? -0.01 : 2e-3);
      scale = Math.min(Math.max(0.125, scale), 4);
      zoom.value = scale;
    };
    const moveInit = (e) => {
      var _a3;
      startX = (_a3 = e == null ? void 0 : e.changedTouches[0]) == null ? void 0 : _a3.pageX;
      moveFlag = false;
    };
    const twoTouchesInit = (e) => {
      const touch1 = e == null ? void 0 : e.touches[0];
      const touch2 = e == null ? void 0 : e.touches[1];
      touchStore.pageX1 = touch1 == null ? void 0 : touch1.pageX;
      touchStore.pageY1 = touch1 == null ? void 0 : touch1.pageY;
      if (touch2) {
        touchStore.pageX2 = touch2 == null ? void 0 : touch2.pageX;
        touchStore.pageY2 = touch2 == null ? void 0 : touch2.pageY;
      }
    };
    const handleTwoTouches = (e) => {
      const touch1 = e == null ? void 0 : e.touches[0];
      const touch2 = e == null ? void 0 : e.touches[1];
      if (touch2) {
        if (!isNumber2(touchStore.pageX2)) {
          touchStore.pageX2 = touch2.pageX;
        }
        if (!isNumber2(touchStore.pageY2)) {
          touchStore.pageY2 = touch2.pageY;
        }
      }
      const getDistance = (startX2, startY, stopX, stopY) => {
        return Math.hypot(stopX - startX2, stopY - startY);
      };
      if (!isNumber2(touchStore.pageX1) || !isNumber2(touchStore.pageY1) || !isNumber2(touchStore.pageX2) || !isNumber2(touchStore.pageY2)) {
        return;
      }
      const touchZoom = getDistance(touch1.pageX, touch1.pageY, touch2.pageX, touch2.pageY) / getDistance(
        touchStore.pageX1,
        touchStore.pageY1,
        touchStore.pageX2,
        touchStore.pageY2
      );
      zoom.value = Math.min(Math.max(0.5, zoom.value * touchZoom), 4);
    };
    onMounted15(() => {
      (document == null ? void 0 : document.addEventListener) && (document == null ? void 0 : document.addEventListener("keydown", handleEsc));
    });
    const handleEsc = (e) => {
      e.preventDefault();
      if ((e == null ? void 0 : e.keyCode) === 27) {
        close3();
      }
    };
    const zoomIn = () => {
      zoom.value += 0.1;
    };
    const zoomOut = () => {
      zoom.value = zoom.value - 0.1 > minZoom.value ? zoom.value - 0.1 : minZoom.value;
    };
    const close3 = () => {
      emit("close");
    };
    const rotateLeft = () => {
      rotate.value -= 90;
    };
    const rotateRight = () => {
      rotate.value += 90;
    };
    const goNext = () => {
      currentImageIndex.value < props.imageList.length - 1 && currentImageIndex.value++;
      initStyle();
    };
    const goPrev = () => {
      currentImageIndex.value > 0 && currentImageIndex.value--;
      initStyle();
    };
    const initStyle = () => {
      zoom.value = 1;
      rotate.value = 0;
    };
    const getImageUrl = (message) => {
      var _a3, _b3, _c2, _d2;
      if (isPC) {
        return (_b3 = (_a3 = message == null ? void 0 : message.payload) == null ? void 0 : _a3.imageInfoArray[0]) == null ? void 0 : _b3.url;
      } else {
        return (_d2 = (_c2 = message == null ? void 0 : message.payload) == null ? void 0 : _c2.imageInfoArray[2]) == null ? void 0 : _d2.url;
      }
    };
    const save = () => {
      var _a3, _b3;
      const imageMessage = props.imageList[currentImageIndex.value];
      const imageSrc = (_b3 = (_a3 = imageMessage == null ? void 0 : imageMessage.payload) == null ? void 0 : _a3.imageInfoArray[0]) == null ? void 0 : _b3.url;
      if (!imageSrc) {
        Toast({
          message: Wt.t("component.图片 url 不存在"),
          type: TOAST_TYPE.ERROR
        });
        return;
      }
      switch (g()) {
        case "wechat":
          i.getSetting({
            success: (res) => {
              if (!(res == null ? void 0 : res.authSetting["scope.writePhotosAlbum"])) {
                i.authorize({
                  scope: "scope.writePhotosAlbum",
                  success() {
                    downloadImgInUni(imageSrc);
                  },
                  fail() {
                    i.showModal({
                      title: "您已拒绝获取相册权限",
                      content: "是否进入权限管理，调整授权？",
                      success: (res2) => {
                        if (res2.confirm) {
                          i.openSetting({
                            success: (res3) => {
                              console.log(res3.authSetting);
                            }
                          });
                        } else if (res2.cancel) {
                          return Toast({
                            message: Wt.t("component.已取消"),
                            type: TOAST_TYPE.ERROR
                          });
                        }
                      }
                    });
                  }
                });
              } else {
                downloadImgInUni(imageSrc);
              }
            },
            fail: () => {
              Toast({
                message: Wt.t("component.获取权限失败"),
                type: TOAST_TYPE.ERROR
              });
            }
          });
          break;
        case "app":
          downloadImgInUni(imageSrc);
          break;
        default:
          downloadImgInWeb(imageSrc);
          break;
      }
    };
    const downloadImgInUni = (src) => {
      i.showLoading({
        title: "大图提取中"
      });
      i.downloadFile({
        url: src,
        success: function(res) {
          i.hideLoading();
          i.saveImageToPhotosAlbum({
            filePath: res.tempFilePath,
            success: () => {
              Toast({
                message: Wt.t("component.已保存至相册"),
                type: TOAST_TYPE.SUCCESS
              });
            }
          });
        },
        fail: function() {
          i.hideLoading();
          Toast({
            message: Wt.t("component.图片下载失败"),
            type: TOAST_TYPE.ERROR
          });
        }
      });
    };
    const downloadImgInWeb = (src) => {
      var _a3;
      const option = {
        mode: "cors",
        headers: new Headers({
          "Content-Type": "application/x-www-form-urlencoded"
        })
      };
      const imageMessage = props.imageList[currentImageIndex.value];
      const imageFormat = (_a3 = imageMessage == null ? void 0 : imageMessage.payload) == null ? void 0 : _a3.imageFormat;
      if (!imageFormatMap.has(imageFormat)) {
        Toast({
          message: Wt.t("component.暂不支持下载此类型图片"),
          type: TOAST_TYPE.ERROR
        });
        return;
      }
      if (window.fetch) {
        fetch(src, option).then((res) => res.blob()).then((blob) => {
          const a = document.createElement("a");
          const url = window.URL.createObjectURL(blob);
          a.href = url;
          a.download = url + "." + imageFormatMap.get(imageFormat);
          a.click();
        });
      } else {
        const a = document.createElement("a");
        a.href = src;
        a.target = "_blank";
        a.download = src + "." + imageFormatMap.get(imageFormat);
        a.click();
      }
    };
    onUnmounted10(() => {
      (document == null ? void 0 : document.removeEventListener) && (document == null ? void 0 : document.removeEventListener("keydown", handleEsc));
    });
    return (_ctx, _cache) => {
      return openBlock41(), createElementBlock40("div", {
        class: normalizeClass27(["image-previewer", [unref40(isMobile) && "image-previewer-h5"]])
      }, [
        createElementVNode29("div", {
          ref_key: "image",
          ref: image,
          class: "image-wrapper",
          onTouchstart: withModifiers9(handleTouchStart, ["stop"]),
          onTouchmove: withModifiers9(handleTouchMove, ["stop"]),
          onTouchend: withModifiers9(handleTouchEnd, ["stop"]),
          onTouchcancel: withModifiers9(handleTouchCancel, ["stop"]),
          onWheel: withModifiers9(handleWheel, ["stop"])
        }, [
          createElementVNode29("ul", {
            ref_key: "ulRef",
            ref: ulRef,
            class: "image-list",
            style: normalizeStyle10({
              width: `${_ctx.imageList.length * 100}%`,
              transform: `translateX(-${unref40(currentImageIndex) * 100 / _ctx.imageList.length}%)`,
              transition: "0.5s"
            })
          }, [
            (openBlock41(true), createElementBlock40(Fragment12, null, renderList10(_ctx.imageList, (item, index3) => {
              return openBlock41(), createElementBlock40("li", {
                key: index3,
                class: "image-item"
              }, [
                createVNode21(_sfc_main41, {
                  zoom: unref40(zoom),
                  rotate: unref40(rotate),
                  src: getImageUrl(item),
                  messageItem: item,
                  class: normalizeClass27([unref40(isUniFrameWork) ? "image-item" : ""])
                }, null, 8, ["zoom", "rotate", "src", "messageItem", "class"])
              ]);
            }), 128))
          ], 4)
        ], 544),
        withDirectives3(createElementVNode29("div", {
          class: "icon icon-close",
          onClick: close3
        }, [
          createVNode21(Icon, {
            file: unref40(closeIcon2),
            width: "16px",
            height: "16px"
          }, null, 8, ["file"])
        ], 512), [
          [vShow3, unref40(isPC)]
        ]),
        unref40(isPC) && unref40(currentImageIndex) > 0 ? (openBlock41(), createElementBlock40("div", {
          key: 0,
          class: "image-button image-button-left",
          onClick: goPrev
        }, [
          createVNode21(Icon, { file: unref40(iconArrowLeft) }, null, 8, ["file"])
        ])) : createCommentVNode27("", true),
        unref40(isPC) && unref40(currentImageIndex) < _ctx.imageList.length - 1 ? (openBlock41(), createElementBlock40("div", {
          key: 1,
          class: "image-button image-button-right",
          onClick: goNext
        }, [
          createVNode21(Icon, { file: unref40(iconArrowLeft) }, null, 8, ["file"])
        ])) : createCommentVNode27("", true),
        createElementVNode29("div", {
          class: normalizeClass27(["actions-bar", unref40(isMobile) && "actions-bar-h5"])
        }, [
          unref40(isPC) ? (openBlock41(), createElementBlock40("div", {
            key: 0,
            class: "icon-zoom-in",
            onClick: zoomIn
          }, [
            createVNode21(Icon, {
              file: unref40(iconZoomIn),
              width: "27px",
              height: "27px"
            }, null, 8, ["file"])
          ])) : createCommentVNode27("", true),
          unref40(isPC) ? (openBlock41(), createElementBlock40("div", {
            key: 1,
            class: "icon-zoom-out",
            onClick: zoomOut
          }, [
            createVNode21(Icon, {
              file: unref40(iconZoomOut),
              width: "27px",
              height: "27px"
            }, null, 8, ["file"])
          ])) : createCommentVNode27("", true),
          unref40(isPC) ? (openBlock41(), createElementBlock40("div", {
            key: 2,
            class: "icon-refresh-left",
            onClick: rotateLeft
          }, [
            createVNode21(Icon, {
              file: unref40(iconRotateLeft),
              width: "27px",
              height: "27px"
            }, null, 8, ["file"])
          ])) : createCommentVNode27("", true),
          unref40(isPC) ? (openBlock41(), createElementBlock40("div", {
            key: 3,
            class: "icon-refresh-right",
            onClick: rotateRight
          }, [
            createVNode21(Icon, {
              file: unref40(iconRotateRight),
              width: "27px",
              height: "27px"
            }, null, 8, ["file"])
          ])) : createCommentVNode27("", true),
          createElementVNode29("span", _hoisted_137, toDisplayString29(unref40(currentImageIndex) + 1) + " / " + toDisplayString29(_ctx.imageList.length), 1)
        ], 2),
        createElementVNode29("div", {
          class: "save",
          onClick: withModifiers9(save, ["stop", "prevent"])
        }, [
          createVNode21(Icon, {
            file: unref40(iconDownload),
            width: "20px",
            height: "20px"
          }, null, 8, ["file"])
        ])
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/ImagePreviewer/index.vue.mjs
var ImagePreviewer = _export_sfc(_sfc_main42, [["__scopeId", "data-v-7614e4b7"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/ProgressMessage/index.vue2.mjs
import { defineComponent as defineComponent43, createElementBlock as createElementBlock41, openBlock as openBlock42, renderSlot as renderSlot9, createCommentVNode as createCommentVNode28, unref as unref41 } from "vue";
var _hoisted_138 = { class: "progress-message" };
var _hoisted_225 = {
  key: 0,
  class: "progress-container"
};
var _hoisted_313 = ["value"];
var _hoisted_49 = ["percent"];
var _sfc_main43 = defineComponent43({
  __name: "index",
  props: {
    content: { default: () => ({}) },
    messageItem: { default: () => ({}) }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock42(), createElementBlock41("div", _hoisted_138, [
        renderSlot9(_ctx.$slots, "default", {}, void 0, true),
        props.messageItem.status === "unSend" && props.messageItem.progress < 1 ? (openBlock42(), createElementBlock41("div", _hoisted_225, [
          !unref41(isUniFrameWork) ? (openBlock42(), createElementBlock41("progress", {
            key: 0,
            class: "progress",
            value: props.messageItem.progress,
            max: "1"
          }, null, 8, _hoisted_313)) : (openBlock42(), createElementBlock41("progress", {
            key: 1,
            activeColor: "#006EFF",
            class: "progress-common",
            percent: Math.round(props.messageItem.progress * 100)
          }, null, 8, _hoisted_49))
        ])) : createCommentVNode28("", true)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/ProgressMessage/index.vue.mjs
var ProgressMessage = _export_sfc(_sfc_main43, [["__scopeId", "data-v-8e1c1325"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/chatStorage.mjs
var __defProp5 = Object.defineProperty;
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField5 = (obj, key, value) => __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
var _ChatStorage = class _ChatStorage2 {
  constructor() {
    __publicField5(this, "chatStorage", null);
  }
  static getInstance() {
    if (!_ChatStorage2.instance) {
      _ChatStorage2.instance = new _ChatStorage2();
    }
    return _ChatStorage2.instance;
  }
  getChatStorage(key) {
    if (!this.chatStorage) {
      this.chatStorage = this.getChatStorageFromLocalStorage();
    }
    if (key) {
      return this.chatStorage[key];
    } else {
      throw new Error("No key provided");
    }
  }
  setChatStorage(key, value) {
    if (!this.chatStorage) {
      this.chatStorage = this.getChatStorageFromLocalStorage();
    }
    this.chatStorage[key] = value;
    try {
      if (isUniFrameWork) {
        i.setStorageSync(_ChatStorage2.CHAT_STORAGE_KEY, JSON.stringify(this.chatStorage));
      } else {
        localStorage.setItem(_ChatStorage2.CHAT_STORAGE_KEY, JSON.stringify(this.chatStorage));
      }
    } catch (error) {
      throw new Error("Fail to set chat storage");
    }
  }
  getChatStorageFromLocalStorage() {
    let chatStorageString = "";
    if (isUniFrameWork) {
      chatStorageString = i.getStorageSync(_ChatStorage2.CHAT_STORAGE_KEY) || "";
    } else {
      chatStorageString = localStorage.getItem(_ChatStorage2.CHAT_STORAGE_KEY) || "";
    }
    if (!chatStorageString) {
      return {};
    }
    try {
      this.chatStorage = JSON.parse(chatStorageString);
    } catch (error) {
      this.chatStorage = {};
    }
    return this.chatStorage;
  }
};
__publicField5(_ChatStorage, "instance", null);
__publicField5(_ChatStorage, "CHAT_STORAGE_KEY", "TUI_CHAT_STORAGE");
var ChatStorage = _ChatStorage;
var chatStorage = ChatStorage.getInstance();

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/utils/lodash.mjs
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  let leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (options && isObject(options)) {
    leading = "leading" in options ? true : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    leading,
    maxWait: wait,
    trailing
  });
}
function debounce(func, wait, options) {
  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = wait || 0;
  if (options && isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? Math.max(options.maxWait, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    const args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(Date.now());
  }
  function debounced() {
    const time = Date.now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type == "object" || type == "function");
}

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/index.vue2.mjs
var _hoisted_139 = {
  key: 0,
  class: "tui-chat-safe-tips"
};
var _hoisted_226 = ["id"];
var _hoisted_314 = { class: "message-item" };
var _hoisted_410 = ["onLongpress", "onContextmenu", "onTouchstart", "onTouchend", "onMouseover"];
var _hoisted_58 = { class: "delDialog-title" };
var _sfc_main44 = defineComponent44({
  __name: "index",
  props: {
    isGroup: { type: Boolean, default: false },
    groupID: { default: "" },
    isNotInGroup: { type: Boolean, default: false },
    isMultipleSelectMode: { type: Boolean, default: false }
  },
  emits: ["closeInputToolBar", "toggleMultipleSelectMode", "handleEditor"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    const props = __props;
    let groupType;
    let observer = null;
    const sentReceiptMessageIDSet = /* @__PURE__ */ new Set();
    const isOfficial = Jt.getData(o.APP, "isOfficial");
    const enabledEmojiPlugin = Jt.getData(o.APP, "enabledEmojiPlugin");
    const messageListRef = ref31();
    const messageToolListRef = ref31();
    const messageList = ref31();
    const allMessageList = ref31();
    const multipleSelectedMessageIDList = ref31([]);
    const isCompleted = ref31(false);
    const currentConversationID2 = ref31("");
    const currentLastMessage = ref31();
    const nextReqMessageID = ref31();
    const toggleID = ref31("");
    const TYPES = ref31(qt.TYPES);
    const isLongpressing = ref31(false);
    const messageTarget = ref31();
    const messageElementListRef = ref31();
    const targetMessageDom = ref31();
    const blinkMessageIDList = ref31([]);
    const scrollButtonInstanceRef = ref31();
    const isShowReadUserStatusPanel = ref31(false);
    const readStatusMessage = ref31();
    const beforeHistoryGetScrollHeight = ref31(0);
    const isTopMessageDom = ref31(false);
    const audioPlayedMapping = ref31({});
    const showImagePreview = ref31(false);
    const currentImagePreview = ref31();
    const imageMessageList = computed16(
      () => {
        var _a3;
        return (_a3 = messageList == null ? void 0 : messageList.value) == null ? void 0 : _a3.filter((item) => {
          return !item.isRevoked && !item.hasRiskContent && item.type === TYPES.value.MSG_IMAGE;
        });
      }
    );
    const reSendDialogShow = ref31(false);
    const resendMessageData = ref31();
    const isShowEmojiPlugin = computed16(() => {
      const msgPopMenuExtensionList = R.getExtensionList(E.TUIChat.EXTENSION.MSG_POP_MENU.EXT_ID, {
        enabledEmojiPlugin
      });
      return msgPopMenuExtensionList.some((item) => {
        return item.text === "TUIEmojiPlugin";
      });
    });
    onMounted16(() => {
      audioPlayedMapping.value = chatStorage.getChatStorage("audioPlayedMapping") || {};
      Jt.watch(o.CHAT, {
        messageList: onMessageListUpdated,
        messageSource: onMessageSourceUpdated,
        isCompleted: isCompletedUpdated
      });
      Jt.watch(o.CONV, {
        currentConversationID: onCurrentConversationIDUpdated
      });
      Jt.watch(o.CUSTOM, {
        isShowMessagePopMenu: isShowMessagePopMenuUpdated
      });
    });
    onMounted16(() => {
      var _a3;
      (_a3 = messageListRef.value) == null ? void 0 : _a3.addEventListener("scroll", handelScrollListScroll);
    });
    onUnmounted11(() => {
      var _a3;
      Jt.unwatch(o.CHAT, {
        messageList: onMessageListUpdated,
        messageSource: onMessageSourceUpdated,
        isCompleted: isCompletedUpdated
      });
      Jt.unwatch(o.CONV, {
        currentConversationID: onCurrentConversationIDUpdated
      });
      Jt.unwatch(o.CUSTOM, {
        isShowMessagePopMenu: isShowMessagePopMenuUpdated
      });
      (_a3 = messageListRef.value) == null ? void 0 : _a3.removeEventListener("scroll", handelScrollListScroll);
      if (Object.keys(audioPlayedMapping.value).length > 0) {
        chatStorage.setChatStorage("audioPlayedMapping", audioPlayedMapping.value);
      }
      sentReceiptMessageIDSet.clear();
      observer == null ? void 0 : observer.disconnect();
      observer = null;
    });
    async function onMessageListUpdated(list) {
      var _a3, _b3, _c2, _d2, _e2;
      observer == null ? void 0 : observer.disconnect();
      const oldLastMessage = currentLastMessage.value;
      let hasEmojiReaction = false;
      allMessageList.value = list;
      messageList.value = list.filter((message) => {
        var _a22;
        if (((_a22 = message.reactionList) == null ? void 0 : _a22.length) && !message.isDeleted) {
          hasEmojiReaction = true;
        }
        return !message.isDeleted;
      });
      if (!((_a3 = messageList.value) == null ? void 0 : _a3.length)) {
        currentLastMessage.value = {};
        return;
      }
      const newLastMessage = (_c2 = messageList.value) == null ? void 0 : _c2[((_b3 = messageList.value) == null ? void 0 : _b3.length) - 1];
      if (messageTarget.value) {
        if (((_d2 = messageList.value) == null ? void 0 : _d2.findIndex(
          (message) => {
            var _a22;
            return (message == null ? void 0 : message.ID) === ((_a22 = messageTarget.value) == null ? void 0 : _a22.ID);
          }
        )) >= 0) {
          const tempMessage = messageTarget.value;
          messageTarget.value = void 0;
          await scrollToPosition({ scrollToMessage: tempMessage });
          await blinkMessage(tempMessage == null ? void 0 : tempMessage.ID);
        }
      } else if (beforeHistoryGetScrollHeight.value) {
        await scrollToPosition({
          scrollToOffset: { bottom: beforeHistoryGetScrollHeight.value }
        });
        beforeHistoryGetScrollHeight.value = 0;
      } else if (((_e2 = scrollButtonInstanceRef.value) == null ? void 0 : _e2.isScrollButtonVisible) && (newLastMessage == null ? void 0 : newLastMessage.flow) === "in") {
        return;
      } else if ((newLastMessage == null ? void 0 : newLastMessage.ID) && JSON.stringify(oldLastMessage) !== JSON.stringify(newLastMessage)) {
        await scrollToPosition({ scrollToBottom: true });
      } else if (hasEmojiReaction && isCurrentListInBottomPosition()) {
        await scrollToPosition({ scrollToBottom: true });
      }
      currentLastMessage.value = Object.assign({}, newLastMessage);
      if (isEnabledMessageReadReceiptGlobal()) {
        nextTick5(() => bindIntersectionObserver());
      }
    }
    function isCurrentListInBottomPosition() {
      return messageListRef.value && typeof messageListRef.value.scrollTop === "number" && typeof messageListRef.value.scrollHeight === "number" && typeof messageListRef.value.clientHeight === "number" && Math.ceil(
        messageListRef.value.scrollTop + messageListRef.value.clientHeight
      ) >= messageListRef.value.scrollHeight;
    }
    async function scrollToPosition(config = {}) {
      return new Promise((resolve, reject) => {
        requestAnimationFrame(() => {
          var _a3, _b3, _c2;
          if (!messageListRef.value) {
            reject();
          }
          const container = messageListRef.value;
          if (config.scrollToBottom) {
            container.scrollTop = container.scrollHeight;
          } else if (config.scrollToMessage) {
            const targetMessageDom2 = (_a3 = messageElementListRef.value) == null ? void 0 : _a3.find(
              (dom) => {
                var _a22;
                return (dom == null ? void 0 : dom.id) === `tui-${(_a22 = config.scrollToMessage) == null ? void 0 : _a22.ID}`;
              }
            );
            if (targetMessageDom2 == null ? void 0 : targetMessageDom2.scrollIntoView) {
              targetMessageDom2.scrollIntoView({ behavior: "smooth", block: "nearest" });
            }
          } else if (config.scrollToOffset) {
            if ((_b3 = config.scrollToOffset) == null ? void 0 : _b3.top) {
              container.scrollTop = config.scrollToOffset.top;
            } else if ((_c2 = config.scrollToOffset) == null ? void 0 : _c2.bottom) {
              container.scrollTop = container.scrollHeight - config.scrollToOffset.bottom;
            }
          }
          resolve();
        });
      });
    }
    async function onMessageSourceUpdated(message) {
      var _a3;
      messageTarget.value = message;
      if (messageTarget.value) {
        if (((_a3 = messageList.value) == null ? void 0 : _a3.findIndex(
          (message2) => {
            var _a22;
            return (message2 == null ? void 0 : message2.ID) === ((_a22 = messageTarget.value) == null ? void 0 : _a22.ID);
          }
        )) >= 0) {
          const tempMessage = messageTarget.value;
          messageTarget.value = void 0;
          await scrollToPosition({ scrollToMessage: tempMessage });
          await blinkMessage(tempMessage == null ? void 0 : tempMessage.ID);
        }
      }
    }
    function isCompletedUpdated(flag) {
      isCompleted.value = flag;
    }
    function isShowMessagePopMenuUpdated(isShow) {
      if (!isShow) {
        toggleID.value = "";
      }
    }
    const onCurrentConversationIDUpdated = (conversationID) => {
      currentConversationID2.value = conversationID;
      if (!currentConversationID2.value) {
        messageList.value = [];
      }
      if (isEnabledMessageReadReceiptGlobal()) {
        const { groupProfile } = Jt.getConversationModel(conversationID) || {};
        groupType = groupProfile == null ? void 0 : groupProfile.type;
      }
      if (Object.keys(audioPlayedMapping.value).length > 0) {
        chatStorage.setChatStorage("audioPlayedMapping", audioPlayedMapping.value);
      }
    };
    const getHistoryMessageList = () => {
      var _a3;
      Qt.getMessageList().then((res) => {
        const { nextReqMessageID: ID } = res.data;
        nextReqMessageID.value = ID;
      });
      beforeHistoryGetScrollHeight.value = (_a3 = messageListRef.value) == null ? void 0 : _a3.scrollHeight;
    };
    const openComplaintLink = (type) => {
      window.open(type.url);
    };
    const handleImagePreview = (message) => {
      if (showImagePreview.value || currentImagePreview.value || isLongpressing.value) {
        return;
      }
      showImagePreview.value = true;
      currentImagePreview.value = message;
    };
    const onImagePreviewerClose = () => {
      showImagePreview.value = false;
      currentImagePreview.value = null;
    };
    const handleToggleMessageItem = (e, message, isLongpress = false) => {
      if (props.isMultipleSelectMode || props.isNotInGroup) {
        return;
      }
      if (isLongpress) {
        isLongpressing.value = true;
      }
      toggleID.value = message.ID;
      filterTopMessageDom(e.target);
    };
    const handleToggleMessageItemForPC = (e, message) => {
      var _a3;
      if (props.isMultipleSelectMode || props.isNotInGroup) {
        return;
      }
      if (isPC) {
        toggleID.value = message.ID;
        targetMessageDom.value = (_a3 = messageElementListRef.value) == null ? void 0 : _a3.find((dom) => (dom == null ? void 0 : dom.id) === `tui-${message.ID}`);
        nextTick5(() => {
          var _a22;
          const ignoreDomRefs = messageToolListRef.value && ((_a22 = messageToolListRef.value[0]) == null ? void 0 : _a22.messageToolDom);
          O.listen({
            domRefs: targetMessageDom.value,
            ignoreDomRefs,
            handler: closeChatPop,
            button: e.button
          });
          filterTopMessageDom(e.target);
        });
      }
    };
    function filterTopMessageDom(toggleMessageElement) {
      const chatElement = document.getElementById("tui-chat-main");
      const safeTop = 160;
      const messageElementRect = toggleMessageElement.getBoundingClientRect();
      const ChatElementRect = chatElement.getBoundingClientRect();
      isTopMessageDom.value = messageElementRect.top - ChatElementRect.top < safeTop ? true : false;
    }
    let timer;
    const handleH5LongPress = (e, message, type) => {
      if (props.isMultipleSelectMode || props.isNotInGroup) {
        return;
      }
      if (!isH5)
        return;
      function longPressHandler() {
        clearTimeout(timer);
        handleToggleMessageItem(e, message);
      }
      function touchStartHandler() {
        timer = setTimeout(longPressHandler, 500);
      }
      function touchEndHandler() {
        clearTimeout(timer);
      }
      switch (type) {
        case "touchstart":
          touchStartHandler();
          break;
        case "touchend":
          touchEndHandler();
          setTimeout(() => {
            isLongpressing.value = false;
          }, 200);
          break;
      }
    };
    const handleEdit = (message) => {
      emits("handleEditor", message, "reedit");
    };
    const resendMessage = (message) => {
      reSendDialogShow.value = true;
      resendMessageData.value = message;
    };
    const resendMessageConfirm = () => {
      reSendDialogShow.value = !reSendDialogShow.value;
      const messageModel = resendMessageData.value;
      messageModel.resendMessage();
    };
    function blinkMessage(messageID) {
      return new Promise((resolve) => {
        const index3 = blinkMessageIDList.value.indexOf(messageID);
        if (index3 < 0) {
          blinkMessageIDList.value.push(messageID);
          const timer2 = setTimeout(() => {
            blinkMessageIDList.value.splice(blinkMessageIDList.value.indexOf(messageID), 1);
            clearTimeout(timer2);
            resolve();
          }, 3e3);
        }
      });
    }
    async function scrollToLatestMessage() {
      const { scrollHeight } = await P("#messageScrollList");
      const { height } = await T("#messageScrollList");
      if (messageListRef.value) {
        messageListRef.value.scrollTop = scrollHeight - height;
      }
    }
    const handelScrollListScroll = throttle(function(e) {
      var _a3;
      (_a3 = scrollButtonInstanceRef.value) == null ? void 0 : _a3.judgeScrollOverOneScreen(e);
    }, 150, { leading: true });
    async function bindIntersectionObserver() {
      var _a3;
      if (!messageList.value || !messageListRef.value || messageList.value.length === 0) {
        return;
      }
      if (groupType === TYPES.value.GRP_AVCHATROOM || groupType === TYPES.value.GRP_COMMUNITY) {
        return;
      }
      const mappingFromIDToMessage = {};
      observer == null ? void 0 : observer.disconnect();
      observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          var _a22;
          const { isIntersecting, target } = entry;
          if (isIntersecting) {
            const { msgDom, msgModel } = mappingFromIDToMessage[target.id];
            if (msgModel && !((_a22 = msgModel.readReceiptInfo) == null ? void 0 : _a22.isPeerRead) && !sentReceiptMessageIDSet.has(msgModel.ID)) {
              Qt.sendMessageReadReceipt([msgModel]);
              sentReceiptMessageIDSet.add(msgModel.ID);
              observer == null ? void 0 : observer.unobserve(msgDom);
            }
          }
        });
      }, {
        root: messageListRef.value,
        threshold: 0.7
      });
      const arrayOfMessageLi = (_a3 = messageListRef.value) == null ? void 0 : _a3.querySelectorAll(".message-li");
      if (arrayOfMessageLi) {
        for (let i2 = 0; i2 < (arrayOfMessageLi == null ? void 0 : arrayOfMessageLi.length); ++i2) {
          const messageElement = arrayOfMessageLi[i2];
          const matchingMessage = messageList.value.find((message) => {
            return messageElement.id.slice(4) === message.ID;
          });
          if (matchingMessage && matchingMessage.needReadReceipt && matchingMessage.flow === "in") {
            mappingFromIDToMessage[messageElement.id] = {
              msgDom: messageElement,
              msgModel: matchingMessage
            };
            observer == null ? void 0 : observer.observe(messageElement);
          }
        }
      }
    }
    function setReadReceiptPanelVisible(visible, message) {
      if (visible && props.isNotInGroup) {
        return;
      }
      if (!visible) {
        readStatusMessage.value = void 0;
      } else {
        readStatusMessage.value = message;
      }
      isShowReadUserStatusPanel.value = visible;
    }
    function closeChatPop() {
      toggleID.value = "";
    }
    function onMessageListBackgroundClick() {
      emits("closeInputToolBar");
    }
    watch14(() => props.isMultipleSelectMode, (newValue) => {
      if (!newValue) {
        changeSelectMessageIDList({
          type: "clearAll",
          messageID: ""
        });
      }
    });
    function changeSelectMessageIDList({ type, messageID }) {
      if (type === "clearAll") {
        multipleSelectedMessageIDList.value = [];
      } else if (type === "add" && !multipleSelectedMessageIDList.value.includes(messageID)) {
        multipleSelectedMessageIDList.value.push(messageID);
      } else if (type === "remove") {
        multipleSelectedMessageIDList.value = multipleSelectedMessageIDList.value.filter((id) => id !== messageID);
      }
    }
    function mergeForwardMessage() {
      Jt.update(o.CUSTOM, "multipleForwardMessageID", {
        isMergeForward: true,
        messageIDList: multipleSelectedMessageIDList.value
      });
    }
    function oneByOneForwardMessage() {
      Jt.update(o.CUSTOM, "multipleForwardMessageID", {
        isMergeForward: false,
        messageIDList: multipleSelectedMessageIDList.value
      });
    }
    function setAudioPlayed(messageID) {
      audioPlayedMapping.value = {
        ...audioPlayedMapping.value,
        [messageID]: true
      };
    }
    __expose({
      oneByOneForwardMessage,
      mergeForwardMessage,
      scrollToLatestMessage
    });
    return (_ctx, _cache) => {
      const _component_TUIEmojiPlugin = resolveComponent("TUIEmojiPlugin");
      return openBlock43(), createElementBlock42("div", {
        class: normalizeClass28(["tui-chat", [unref42(isH5) ? "tui-chat-h5" : ""]])
      }, [
        createElementVNode30("div", {
          id: "tui-chat-main",
          class: "tui-chat-main",
          onClick: closeChatPop
        }, [
          unref42(isOfficial) ? (openBlock43(), createElementBlock42("div", _hoisted_139, [
            createElementVNode30("span", null, toDisplayString30(unref42(Wt).t(
              "TUIChat.【安全提示】本 APP 仅用于体验腾讯云即时通信 IM 产品功能，不可用于业务洽谈与拓展。请勿轻信汇款、中奖等涉及钱款的信息，勿轻易拨打陌生电话，谨防上当受骗。"
            )), 1),
            createElementVNode30("a", {
              onClick: _cache[0] || (_cache[0] = ($event) => openComplaintLink(unref42(Link).complaint))
            }, toDisplayString30(unref42(Wt).t("TUIChat.点此投诉")), 1)
          ])) : createCommentVNode29("", true),
          _ctx.isGroup ? (openBlock43(), createBlock9(MessageGroupApplication, {
            key: props.groupID,
            groupID: props.groupID
          }, null, 8, ["groupID"])) : createCommentVNode29("", true),
          createElementVNode30("ul", {
            id: "messageScrollList",
            ref_key: "messageListRef",
            ref: messageListRef,
            class: "tui-message-list",
            onClick: onMessageListBackgroundClick
          }, [
            !unref42(isCompleted) ? (openBlock43(), createElementBlock42("p", {
              key: 0,
              class: "message-more",
              onClick: getHistoryMessageList
            }, toDisplayString30(unref42(Wt).t("TUIChat.查看更多")), 1)) : createCommentVNode29("", true),
            (openBlock43(true), createElementBlock42(Fragment13, null, renderList11(unref42(messageList), (item, index3) => {
              return openBlock43(), createElementBlock42("li", {
                id: "tui-" + item.ID,
                key: item.ID,
                ref_for: true,
                ref_key: "messageElementListRef",
                ref: messageElementListRef,
                class: "message-li"
              }, [
                createVNode22(MessageTimestamp, {
                  currTime: item.time,
                  prevTime: index3 > 0 ? unref42(messageList)[index3 - 1].time : 0
                }, null, 8, ["currTime", "prevTime"]),
                createElementVNode30("div", _hoisted_314, [
                  item.type === unref42(TYPES).MSG_GRP_TIP || unref42(isCreateGroupCustomMessage)(item) ? (openBlock43(), createBlock9(MessageTip, {
                    key: 0,
                    content: item.getMessageContent(),
                    blinkMessageIDList: unref42(blinkMessageIDList),
                    onBlinkMessage: blinkMessage
                  }, null, 8, ["content", "blinkMessageIDList"])) : item.isRevoked ? (openBlock43(), createBlock9(MessageRevoked, {
                    key: 1,
                    isEdit: item.type === unref42(TYPES).MSG_TEXT,
                    messageItem: unref42(shallowCopyMessage)(item),
                    onMessageEdit: ($event) => handleEdit(item)
                  }, null, 8, ["isEdit", "messageItem", "onMessageEdit"])) : unref42(isPluginMessage)(item) ? (openBlock43(), createBlock9(MessagePlugin, {
                    key: 2,
                    message: unref42(deepCopy)(item),
                    blinkMessageIDList: unref42(blinkMessageIDList),
                    onResendMessage: resendMessage,
                    onHandleToggleMessageItem: handleToggleMessageItem,
                    onHandleH5LongPress: handleH5LongPress
                  }, null, 8, ["message", "blinkMessageIDList"])) : (openBlock43(), createElementBlock42("div", {
                    key: 3,
                    class: normalizeClass28({
                      "message-event-bind-div": true
                    }),
                    onLongpress: ($event) => handleToggleMessageItem($event, item, true),
                    onContextmenu: withModifiers10(($event) => handleToggleMessageItemForPC($event, item), ["prevent", "right"]),
                    onTouchstart: ($event) => handleH5LongPress($event, item, "touchstart"),
                    onTouchend: ($event) => handleH5LongPress($event, item, "touchend"),
                    onMouseover: ($event) => handleH5LongPress($event, item, "touchend")
                  }, [
                    createVNode22(MessageBubble, {
                      content: item.getMessageContent(),
                      isAudioPlayed: Boolean(unref42(audioPlayedMapping)[item.ID]),
                      blinkMessageIDList: unref42(blinkMessageIDList),
                      isMultipleSelectMode: _ctx.isMultipleSelectMode,
                      messageItem: JSON.parse(JSON.stringify(item)),
                      multipleSelectedMessageIDList: unref42(multipleSelectedMessageIDList),
                      onBlinkMessage: blinkMessage,
                      onResendMessage: ($event) => resendMessage(item),
                      onChangeSelectMessageIDList: changeSelectMessageIDList,
                      onSetReadReceiptPanelVisible: setReadReceiptPanelVisible
                    }, {
                      messageElement: withCtx9(() => [
                        item.type === unref42(TYPES).MSG_TEXT ? (openBlock43(), createBlock9(MessageText, {
                          key: 0,
                          content: item.getMessageContent()
                        }, null, 8, ["content"])) : item.type === unref42(TYPES).MSG_IMAGE ? (openBlock43(), createBlock9(ProgressMessage, {
                          key: 1,
                          content: item.getMessageContent(),
                          messageItem: item
                        }, {
                          default: withCtx9(() => [
                            createVNode22(MessageImage, {
                              content: item.getMessageContent(),
                              messageItem: item,
                              onPreviewImage: handleImagePreview
                            }, null, 8, ["content", "messageItem"])
                          ]),
                          _: 2
                        }, 1032, ["content", "messageItem"])) : item.type === unref42(TYPES).MSG_VIDEO ? (openBlock43(), createBlock9(ProgressMessage, {
                          key: 2,
                          content: item.getMessageContent(),
                          messageItem: item
                        }, {
                          default: withCtx9(() => [
                            createVNode22(MessageVideo, {
                              content: item.getMessageContent(),
                              messageItem: item
                            }, null, 8, ["content", "messageItem"])
                          ]),
                          _: 2
                        }, 1032, ["content", "messageItem"])) : item.type === unref42(TYPES).MSG_AUDIO ? (openBlock43(), createBlock9(MessageAudio, {
                          key: 3,
                          content: item.getMessageContent(),
                          messageItem: item,
                          onSetAudioPlayed: setAudioPlayed
                        }, null, 8, ["content", "messageItem"])) : item.type === unref42(TYPES).MSG_FILE ? (openBlock43(), createBlock9(ProgressMessage, {
                          key: 4,
                          content: item.getMessageContent(),
                          messageItem: item
                        }, {
                          default: withCtx9(() => [
                            createVNode22(MessageFile, {
                              content: item.getMessageContent(),
                              messageItem: item
                            }, null, 8, ["content", "messageItem"])
                          ]),
                          _: 2
                        }, 1032, ["content", "messageItem"])) : item.type === unref42(TYPES).MSG_MERGER ? (openBlock43(), createBlock9(MessageRecord, {
                          key: 5,
                          renderData: item.payload,
                          messageItem: item
                        }, null, 8, ["renderData", "messageItem"])) : item.type === unref42(TYPES).MSG_FACE ? (openBlock43(), createBlock9(MessageFace, {
                          key: 6,
                          content: item.getMessageContent()
                        }, null, 8, ["content"])) : item.type === unref42(TYPES).MSG_LOCATION ? (openBlock43(), createBlock9(MessageLocation, {
                          key: 7,
                          content: item.getMessageContent()
                        }, null, 8, ["content"])) : item.type === unref42(TYPES).MSG_CUSTOM ? (openBlock43(), createBlock9(MessageCustom, {
                          key: 8,
                          content: item.getMessageContent(),
                          messageItem: item
                        }, null, 8, ["content", "messageItem"])) : createCommentVNode29("", true)
                      ]),
                      TUIEmojiPlugin: withCtx9(() => [
                        unref42(isShowEmojiPlugin) && item.reactionList.length > 0 ? (openBlock43(), createBlock9(_component_TUIEmojiPlugin, {
                          key: 0,
                          type: "reaction-detail",
                          emojiConfig: unref42(emojiConfig),
                          message: unref42(shallowCopyMessage)(item)
                        }, null, 8, ["emojiConfig", "message"])) : createCommentVNode29("", true)
                      ]),
                      _: 2
                    }, 1032, ["content", "isAudioPlayed", "blinkMessageIDList", "isMultipleSelectMode", "messageItem", "multipleSelectedMessageIDList", "onResendMessage"])
                  ], 40, _hoisted_410)),
                  item.ID === unref42(toggleID) ? (openBlock43(), createBlock9(MessageTool, {
                    key: 4,
                    ref_for: true,
                    ref_key: "messageToolListRef",
                    ref: messageToolListRef,
                    class: normalizeClass28({
                      "message-tool": true,
                      "message-tool-out": item.flow === "out",
                      "message-tool-in": item.flow === "in",
                      "message-tool-bottom": unref42(isTopMessageDom)
                    }),
                    messageItem: item,
                    isMultipleSelectMode: _ctx.isMultipleSelectMode,
                    onToggleMultipleSelectMode: _cache[1] || (_cache[1] = () => emits("toggleMultipleSelectMode"))
                  }, {
                    TUIEmojiPlugin: withCtx9(() => _cache[4] || (_cache[4] = [])),
                    _: 2
                  }, 1032, ["class", "messageItem", "isMultipleSelectMode"])) : createCommentVNode29("", true)
                ])
              ], 8, _hoisted_226);
            }), 128))
          ], 512),
          createVNode22(ScrollButton, {
            ref_key: "scrollButtonInstanceRef",
            ref: scrollButtonInstanceRef,
            onScrollToLatestMessage: scrollToLatestMessage
          }, null, 512),
          unref42(reSendDialogShow) ? (openBlock43(), createBlock9(Dialog, {
            key: 2,
            class: "resend-dialog",
            show: unref42(reSendDialogShow),
            isH5: !unref42(isPC),
            center: true,
            isHeaderShow: unref42(isPC),
            onSubmit: _cache[2] || (_cache[2] = ($event) => resendMessageConfirm()),
            "onUpdate:show": _cache[3] || (_cache[3] = (e) => reSendDialogShow.value = e)
          }, {
            default: withCtx9(() => [
              createElementVNode30("p", _hoisted_58, toDisplayString30(unref42(Wt).t("TUIChat.确认重发该消息？")), 1)
            ]),
            _: 1
          }, 8, ["show", "isH5", "isHeaderShow"])) : createCommentVNode29("", true),
          unref42(showImagePreview) ? (openBlock43(), createBlock9(ImagePreviewer, {
            key: 3,
            currentImage: unref42(currentImagePreview),
            imageList: unref42(imageMessageList),
            onClose: onImagePreviewerClose
          }, null, 8, ["currentImage", "imageList"])) : createCommentVNode29("", true),
          unref42(isShowReadUserStatusPanel) ? (openBlock43(), createBlock9(ReadReceiptPanel, {
            key: 4,
            message: Object.assign({}, unref42(readStatusMessage)),
            onSetReadReceiptPanelVisible: setReadReceiptPanelVisible
          }, null, 8, ["message"])) : createCommentVNode29("", true)
        ])
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-list/index.vue.mjs
var MessageList = _export_sfc(_sfc_main44, [["__scopeId", "data-v-82829db6"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/index.vue2.mjs
import { defineComponent as defineComponent50, ref as ref37, createElementBlock as createElementBlock48, openBlock as openBlock49, createElementVNode as createElementVNode34, createVNode as createVNode24, normalizeClass as normalizeClass34, unref as unref48, createBlock as createBlock11, createCommentVNode as createCommentVNode35 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-editor.vue2.mjs
import { defineComponent as defineComponent45, toRefs as toRefs4, ref as ref32, onMounted as onMounted17, onUnmounted as onUnmounted12, watch as watch15, createElementBlock as createElementBlock43, openBlock as openBlock44, normalizeClass as normalizeClass29, unref as unref43, createCommentVNode as createCommentVNode30, toDisplayString as toDisplayString31, withKeys } from "vue";

// D:/code/web/node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      if (this.content[i2] === key)
        return i2;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content = self.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f2) {
    for (var i2 = 0; i2 < this.content.length; i2 += 2)
      f2(this.content[i2], this.content[i2 + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size)
      return this;
    return new OrderedMap(map.content.concat(this.subtract(map).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size)
      return this;
    return new OrderedMap(this.subtract(map).content.concat(map.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i2 = 0; i2 < map.content.length; i2 += 2)
      result = result.remove(map.content[i2]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// D:/code/web/node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i2 = 0; ; i2++) {
    if (i2 == a.childCount || i2 == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i2), childB = b.child(i2);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
var Fragment14 = class _Fragment {
  /**
  @internal
  */
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i2 = 0; i2 < content.length; i2++)
        this.size += content[i2].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from, to, f2, nodeStart = 0, parent) {
    for (let i2 = 0, pos = 0; pos < to; i2++) {
      let child = this.content[i2], end = pos + child.nodeSize;
      if (end > from && f2(child, nodeStart + pos, parent || null, i2) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f2, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f2) {
    this.nodesBetween(0, this.size, f2);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i2 = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i2 = 1;
    }
    for (; i2 < other.content.length; i2++)
      content.push(other.content[i2]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from, to = this.size) {
    if (from == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from)
      for (let i2 = 0, pos = 0; pos < to; i2++) {
        let child = this.content[i2], end = pos + child.nodeSize;
        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
    return new _Fragment(result, size);
  }
  /**
  @internal
  */
  cutByIndex(from, to) {
    if (from == to)
      return _Fragment.empty;
    if (from == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index3, node) {
    let current = this.content[index3];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy2[index3] = node;
    return new _Fragment(copy2, size);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i2 = 0; i2 < this.content.length; i2++)
      if (!this.content[i2].eq(other.content[i2]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index3) {
    let found2 = this.content[index3];
    if (!found2)
      throw new RangeError("Index " + index3 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index3) {
    return this.content[index3] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f2) {
    for (let i2 = 0, p = 0; i2 < this.content.length; i2++) {
      let child = this.content[i2];
      f2(child, p, i2);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos, round = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i2 = 0, curPos = 0; ; i2++) {
      let cur = this.child(i2), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos || round > 0)
          return retIndex(i2 + 1, end);
        return retIndex(i2, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size = 0;
    for (let i2 = 0; i2 < array.length; i2++) {
      let node = array[i2];
      size += node.nodeSize;
      if (i2 && node.isText && array[i2 - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i2);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array, size);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment14.empty = new Fragment14([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index3, offset) {
  found.index = index3;
  found.offset = offset;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (!compareDeep(a[i2], b[i2]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i2 = 0; i2 < set.length; i2++) {
      let other = set[i2];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i2);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i2);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i2 = 0; i2 < set.length; i2++)
      if (this.eq(set[i2]))
        return set.slice(0, i2).concat(set.slice(i2 + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i2 = 0; i2 < set.length; i2++)
      if (this.eq(set[i2]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (!a[i2].eq(b[i2]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark.none;
    if (marks instanceof _Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from, to) {
    return new _Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment14.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment14.empty, 0, 0);
function removeRange(content, from, to) {
  let { index: index3, offset } = content.findIndex(from), child = content.maybeChild(index3);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }
  if (index3 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index3, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index3, offset } = content.findIndex(dist), child = content.maybeChild(index3);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index3, index3, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index3, child.copy(inner));
}
function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}
function replaceOuter($from, $to, slice, depth) {
  let index3 = $from.index(depth), node = $from.node(depth);
  if (index3 == $to.index(depth) && depth < $from.depth - slice.openStart) {
    let inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index3, inner));
  } else if (!slice.content.size) {
    return close2(node, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close2(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice, $from);
    return close2(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i2 = startIndex; i2 < endIndex; i2++)
    addNode(node.child(i2), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close2(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close2(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close2(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close2(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment14(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close2(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment14(content);
}
function prepareSliceForReplace(slice, $along) {
  let extra = $along.depth - slice.openStart, parent = $along.node(extra);
  let node = parent.copy(slice.content);
  for (let i2 = extra - 1; i2 >= 0; i2--)
    node = $along.node(i2).copy(Fragment14.from(node));
  return {
    start: node.resolveNoCache(slice.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index3 = this.index(this.depth);
    if (index3 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index3);
    return dOff ? parent.child(index3).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index3 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index3).cut(0, dOff);
    return index3 == 0 ? null : this.parent.child(index3 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index3, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i2 = 0; i2 < index3; i2++)
      pos += node.child(i2).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index3 = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index3).marks;
    let main = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i2 = 0; i2 < marks.length; i2++)
      if (marks[i2].type.spec.inclusive === false && (!other || !marks[i2].isInSet(other.marks)))
        marks = marks[i2--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i2 = 0; i2 < marks.length; i2++)
      if (marks[i2].type.spec.inclusive === false && (!next || !marks[i2].isInSet(next.marks)))
        marks = marks[i2--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i2 = 1; i2 <= this.depth; i2++)
      str += (str ? "/" : "") + this.node(i2).type.name + "_" + this.index(i2 - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index: index3, offset } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset;
      path.push(node, index3, start + offset);
      if (!rem)
        break;
      node = node.child(index3);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    let cache = resolveCache.get(doc3);
    if (cache) {
      for (let i2 = 0; i2 < cache.elts.length; i2++) {
        let elt = cache.elts[i2];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc3, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc3, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
};
var ResolveCache = class {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
};
var resolveCacheSize = 12;
var resolveCache = /* @__PURE__ */ new WeakMap();
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node2 = class _Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment14.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index3) {
    return this.content.child(index3);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index3) {
    return this.content.maybeChild(index3);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f2) {
    this.content.forEach(f2);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from, to, f2, startPos = 0) {
    this.content.nodesBetween(from, to, f2, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f2) {
    this.nodesBetween(0, this.content.size, f2);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from, to, blockSeparator, leafText) {
    return this.content.textBetween(from, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from, to = this.content.size) {
    if (from == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from, to = this.content.size, includeParents = false) {
    if (from == to)
      return Slice.empty;
    let $from = this.resolve(from), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from, to, slice) {
    return replace(this.resolve(from), this.resolve(to), slice);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index3, offset } = node.content.findIndex(pos);
      node = node.maybeChild(index3);
      if (!node)
        return null;
      if (offset == pos || node.isText)
        return node;
      pos -= offset + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index3, offset } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index3), index: index3, offset };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index3, offset } = this.content.findIndex(pos);
    if (offset < pos)
      return { node: this.content.child(index3), index: index3, offset };
    let node = this.content.child(index3 - 1);
    return { node, index: index3 - 1, offset: offset - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from, to, type) {
    let found2 = false;
    if (to > from)
      this.nodesBetween(from, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index3) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index3);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from, to, replacement = Fragment14.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i2 = start; i2 < end; i2++)
      if (!this.type.allowsMarks(replacement.child(i2).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark.none;
    for (let i2 = 0; i2 < this.marks.length; i2++) {
      let mark = this.marks[i2];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment14.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node2.prototype.text = void 0;
var TextNode = class _TextNode extends Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from, to) {
    return this.text.slice(from, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from = 0, to = this.text.length) {
    if (from == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i2 = marks.length - 1; i2 >= 0; i2--)
    str = marks[i2].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i2 = 0; i2 < this.next.length; i2++)
      if (this.next[i2].type == type)
        return this.next[i2].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i2 = start; cur && i2 < end; i2++)
      cur = cur.matchType(frag.child(i2).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i2 = 0; i2 < this.next.length; i2++) {
      let { type } = this.next[i2];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i2 = 0; i2 < this.next.length; i2++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i2].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment14.from(types.map((tp) => tp.createAndFill()));
      for (let i2 = 0; i2 < match.next.length; i2++) {
        let { type, next } = match.next[i2];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i2 = 0; i2 < this.wrapCache.length; i2 += 2)
      if (this.wrapCache[i2] == target)
        return this.wrapCache[i2 + 1];
    let computed24 = this.computeWrapping(target);
    this.wrapCache.push(target, computed24);
    return computed24;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i2 = 0; i2 < match.next.length; i2++) {
        let { type, next } = match.next[i2];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i2 = 0; i2 < m.next.length; i2++)
        if (seen.indexOf(m.next[i2].next) == -1)
          scan(m.next[i2].next);
    }
    scan(this);
    return seen.map((m, i2) => {
      let out = i2 + (m.validEnd ? "*" : " ") + " ";
      for (let i3 = 0; i3 < m.next.length; i3++)
        out += (i3 ? ", " : "") + m.next[i3].type.name + "->" + seen.indexOf(m.next[i3].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min = parseNum(stream), max = min;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max = parseNum(stream);
    else
      max = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min, max, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from, to, term) {
    let edge2 = { term, to };
    nfa2[from].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);
    } else if (expr2.type == "seq") {
      for (let i2 = 0; ; i2++) {
        let next = compile(expr2.exprs[i2], from);
        if (i2 == expr2.exprs.length - 1)
          return next;
        connect(next, from = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from)].concat(compile(expr2.expr, from));
    } else if (expr2.type == "range") {
      let cur = from;
      for (let i2 = 0; i2 < expr2.min; i2++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i2 = expr2.min; i2 < expr2.max; i2++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i2 = 0; i2 < edges.length; i2++) {
      let { term, to } = edges[i2];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i2 = 0; i2 < out.length; i2++)
          if (out[i2][0] == term)
            set = out[i2][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i2 = 0; i2 < out.length; i2++) {
      let states2 = out[i2][1].sort(cmp);
      state.next.push({ type: out[i2][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i2 = 0, work = [match]; i2 < work.length; i2++) {
    let state = work[i2], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node2(this, this.computeAttrs(attrs), Fragment14.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment14.from(content);
    this.checkContent(content);
    return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment14.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment14.empty, true);
    if (!after)
      return null;
    return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i2 = 0; i2 < content.childCount; i2++)
      if (!this.allowsMarks(content.child(i2).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i2 = 0; i2 < marks.length; i2++)
      if (!this.allowsMarkType(marks[i2].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i2 = 0; i2 < marks.length; i2++) {
      if (!this.allowsMarkType(marks[i2].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i2);
      } else if (copy2) {
        copy2.push(marks[i2]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
var Attribute = class {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i2 = 0; i2 < set.length; i2++)
      if (set[i2].type == this) {
        set = set.slice(0, i2).concat(set.slice(i2 + 1));
        i2--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i2 = 0; i2 < set.length; i2++)
      if (set[i2].type == this)
        return set[i2];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node2.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i2 = 0; i2 < marks.length; i2++) {
    let name = marks[i2], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i2] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
var DOMParser = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i2 = after ? this.tags.indexOf(after) + 1 : 0; i2 < this.tags.length; i2++) {
      let rule = this.tags[i2];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i2 = after ? this.styles.indexOf(after) + 1 : 0; i2 < this.styles.length; i2++) {
      let rule = this.styles[i2], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i2 = 0;
      for (; i2 < result.length; i2++) {
        let next = result[i2], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i2, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment14.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment14.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment14.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks);
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out:
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom, marks);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom, marks);
          break out;
        }
        let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
        if (innerMarks)
          this.addAll(dom, innerMarks);
        if (sync)
          this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        let innerMarks = this.readStyles(dom, marks);
        if (innerMarks)
          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
      }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i2 = 0; i2 < this.parser.matchedStyles.length; i2++) {
        let name = this.parser.matchedStyles[i2], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks)) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index3 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index3) {
      this.findAtPoint(parent, index3);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index3);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks) {
    let route, sync;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i2 = 0; i2 < route.length; i2++)
      marks = this.enterInner(route[i2], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark.none;
      for (let m of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m) => {
      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i2 = this.nodes.length - 1;
    if (i2 > this.open) {
      for (; i2 > this.open; i2--)
        this.nodes[i2 - 1].content.push(this.nodes[i2].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i2 = this.open; i2 >= 0; i2--) {
      if (this.nodes[i2] == to) {
        this.open = i2;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i2].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i2 = this.open; i2 >= 0; i2--) {
      let content = this.nodes[i2].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i2)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].node == parent && this.find[i2].offset == offset)
          this.find[i2].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node))
          this.find[i2].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].pos == null && parent.nodeType == 1 && parent.contains(this.find[i2].node)) {
          let pos = content.compareDocumentPosition(this.find[i2].node);
          if (pos & (before ? 2 : 4))
            this.find[i2].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i2 = 0; i2 < this.find.length; i2++) {
        if (this.find[i2].node == textNode)
          this.find[i2].pos = this.currentPos - (textNode.nodeValue.length - this.find[i2].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i2, depth) => {
      for (; i2 >= 0; i2--) {
        let part = parts[i2];
        if (part == "") {
          if (i2 == parts.length - 1 || i2 == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i2 - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i2 = 0; i2 < match.edgeCount; i2++) {
        let { type, next } = match.edge(i2);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i2 = node.marks.length - 1; i2 >= 0; i2--) {
      let wrap2 = this.serializeMark(node.marks[i2], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc3, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}
var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i2 = 0; i2 < value.length; i2++)
            scan(value[i2]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc3.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i2 = start; i2 < structure.length; i2++) {
    let child = structure[i2];
    if (child === 0) {
      if (i2 < structure.length - 1 || i2 > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}

// D:/code/web/node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index3, offset) {
  return index3 + offset * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index3 = recoverIndex(value);
    if (!this.inverted)
      for (let i2 = 0; i2 < index3; i2++)
        diff += this.ranges[i2 * 3 + 2] - this.ranges[i2 * 3 + 1];
    return this.ranges[index3 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
      let start = this.ranges[i2] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i2 / 3, pos - start);
        let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index3 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0; i2 < this.ranges.length; i2 += 3) {
      let start = this.ranges[i2] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i2 + oldIndex], end = start + oldSize;
      if (pos <= end && i2 == index3 * 3)
        return true;
      diff += this.ranges[i2 + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f2) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i2 = 0, diff = 0; i2 < this.ranges.length; i2 += 3) {
      let start = this.ranges[i2], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i2 + oldIndex], newSize = this.ranges[i2 + newIndex];
      f2(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from = 0, to = this.maps.length) {
    return new _Mapping(this._maps, this.mirror, from, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i2 = 0, startSize = this._maps.length; i2 < mapping._maps.length; i2++) {
      let mirr = mapping.getMirror(i2);
      this.appendMap(mapping._maps[i2], mirr != null && mirr < i2 ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i2 = 0; i2 < this.mirror.length; i2++)
        if (this.mirror[i2] == n)
          return this.mirror[i2 + (i2 % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i2 = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i2 >= 0; i2--) {
      let mirr = mapping.getMirror(i2);
      this.appendMap(mapping._maps[i2].invert(), mirr != null && mirr > i2 ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i2 = this.from; i2 < this.to; i2++)
      pos = this._maps[i2].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i2 = this.from; i2 < this.to; i2++) {
      let map = this._maps[i2], result = map.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i2);
        if (corr != null && corr > i2 && corr < this.to) {
          i2 = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from, to, slice) {
    try {
      return _StepResult.ok(doc3.replace(from, to, slice));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f2, parent) {
  let mapped = [];
  for (let i2 = 0; i2 < fragment.childCount; i2++) {
    let child = fragment.child(i2);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f2, child));
    if (child.isInline)
      child = f2(child, parent, i2);
    mapped.push(child);
  }
  return Fragment14.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new _AddMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment14.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i2 = 0; i2 < node.marks.length; i2++)
          if (!node.marks[i2].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i2]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment14.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from, to, slice, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.slice = slice;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from, to) {
  let $from = doc3.resolve(from), dist = to - from, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr, from, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i2 = 0; i2 < marks.length; i2++) {
        if (!marks[i2].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i2]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i2]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i2 = 0; i2 < toRemove.length; i2++) {
        let style2 = toRemove[i2], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i2 = 0; i2 < node.childCount; i2++) {
    let child = node.child(i2), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice;
        while (m = newline.exec(child.text)) {
          if (!slice)
            slice = new Slice(Fragment14.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment14.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i2 = replSteps.length - 1; i2 >= 0; i2--)
    tr.step(replSteps[i2]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index3 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index3, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index3, endIndex))
      break;
  }
  return null;
}
function lift(tr, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment14.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment14.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment14.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment14.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i2 = startIndex; innerMatch && i2 < endIndex; i2++)
    innerMatch = innerMatch.matchType(parent.child(i2).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr, range, wrappers) {
  let content = Fragment14.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--) {
    if (content.size) {
      let match = wrappers[i2].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment14.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
  }
  let start = range.start, end = range.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr, from, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr, node, pos, mapFrom);
      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment14.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);
        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
      tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index3 = $pos.index();
  return $pos.parent.canReplaceWith(index3, index3 + 1, type);
}
function setNodeMarkup(tr, pos, type, attrs, marks) {
  let node = tr.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment14.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i2 = depth - 2; d > base2; d--, i2--) {
    let node = $pos.node(d), index4 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index4, node.childCount);
    let overrideChild = typesAfter && typesAfter[i2 + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i2] || node;
    if (!node.canReplace(index4 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index3 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment14.empty, after = Fragment14.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i2 = depth - 1; d > e; d--, i2--) {
    before = Fragment14.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i2];
    after = Fragment14.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index3 = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b) {
  if (!b.content.size)
    a.type.compatibleContent(b.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i2 = 0; i2 < b.childCount; i2++) {
    let child = b.child(i2);
    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index3 = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index3++;
      after = $pos.node(d).maybeChild(index3);
    } else {
      before = $pos.node(d).maybeChild(index3 - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index3, index3 + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr.doc.type.schema;
  let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr.steps.length;
  if (convertNewlines === false) {
    let $after = tr.doc.resolve(pos + depth);
    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr.doc.resolve(start);
    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
  }
  return tr;
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index3 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
        return $pos.before(d + 1);
      if (index3 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index3 = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
        return $pos.after(d + 1);
      if (index3 < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice) {
  let $pos = doc3.resolve(pos);
  if (!slice.content.size)
    return pos;
  let content = slice.content;
  for (let i2 = 0; i2 < slice.openStart; i2++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from, to = from, slice = Slice.empty) {
  if (from == to && !slice.size)
    return null;
  let $from = doc3.resolve(from), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}
function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment14.empty;
    for (let i2 = 0; i2 <= $from.depth; i2++) {
      let node = $from.node(i2);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i2))
      });
    }
    for (let i2 = $from.depth; i2 > 0; i2--)
      this.placed = Fragment14.from($from.node(i2).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
    if (slice.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment14.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i2 = 0; i2 < wrap2.length; i2++)
        this.openFrontierNode(wrap2[i2]);
    let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
    let openStart = slice.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i2 = 0; i2 < inject.childCount; i2++)
        add.push(inject.child(i2));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment14.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i2 = 0, cur = fragment; i2 < openEndCount; i2++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i2 = Math.min(this.depth, $to.depth); i2 >= 0; i2--) {
        let { match, type } = this.frontier[i2];
        let dropInner = i2 < $to.depth && $to.end(i2 + 1) == $to.pos + ($to.depth - (i2 + 1));
        let fit = contentAfterFits($to, i2, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i2 - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i2, fit, move: dropInner ? $to.doc.resolve($to.after(i2 + 1)) : $to };
      }
  }
  close($to) {
    let close3 = this.findCloseLevel($to);
    if (!close3)
      return null;
    while (this.depth > close3.depth)
      this.closeFrontierNode();
    if (close3.fit.childCount)
      this.placed = addToFragment(this.placed, close3.depth, close3.fit);
    $to = close3.move;
    for (let d = close3.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment14.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment14.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i2 = 0; i2 < depth; i2++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment14.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index3 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index3 == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index3);
  return fit && !invalidMarks(type, node.content, index3) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i2 = start; i2 < fragment.childCount; i2++)
    if (!type.allowsMarks(fragment.child(i2).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr, from, to, slice) {
  if (!slice.size)
    return tr.deleteRange(from, to);
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return tr.step(new ReplaceStep(from, to, slice));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice.openStart;
  for (let content = slice.content, i2 = 0; ; i2++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i2 == slice.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i2 = 0; i2 < targetDepths.length; i2++) {
      let targetDepth = targetDepths[(i2 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index3, index3, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i2 = targetDepths.length - 1; i2 >= 0; i2--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i2];
    if (depth < 0)
      continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment14.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from, to, node) {
  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    let point = insertPoint(tr.doc, from, node.type);
    if (point != null)
      from = to = point;
  }
  tr.replaceRange(from, to, new Slice(Fragment14.from(node), 0, 0));
}
function deleteRange(tr, from, to) {
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i2 = 0; i2 < covered.length; i2++) {
    let depth = covered[i2], last = i2 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr.delete($from.before(d), to);
  }
  tr.delete(from, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment14.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from, to = from, slice = Slice.empty) {
    let step = replaceStep(this.doc, from, to, slice);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from, to, content) {
    return this.replace(from, to, new Slice(Fragment14.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from, to) {
    return this.replace(from, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from, to, slice) {
    replaceRange(this, from, to, slice);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from, to, node) {
    replaceRangeWith(this, from, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from, to) {
    deleteRange(this, from, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from, to = from, type, attrs = null) {
    setBlockType(this, from, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark)) {
      let node = this.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from, to, mark) {
    addMark(this, from, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from, to, mark) {
    removeMark(this, from, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// D:/code/web/node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++)
      if (ranges[i2].$from.pos != ranges[i2].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i2 = 0; i2 < content.openEnd; i2++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let { $from, $to } = ranges[i2], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i2 ? Slice.empty : content);
      if (i2 == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let { $from, $to } = ranges[i2], mapping = tr.mapping.slice(mapFrom);
      let from = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i2) {
        tr.deleteRange(from, to);
      } else {
        tr.replaceRangeWith(from, to, node);
        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment14.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from) {
    return new _NodeSelection(doc3.resolve(from));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index3, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i2 = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i2 < node.childCount : i2 >= 0; i2 += dir) {
    let child = node.child(i2);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map = tr.mapping.maps[last], end;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice) {
    this.selection.replace(this, slice);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from, to) {
    let schema = this.doc.type.schema;
    if (from == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from;
      to = to == null ? from : to;
      if (!text)
        return this.deleteRange(from, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f2, self) {
  return !self || !f2 ? f2 : f2.bind(self);
}
var FieldDesc = class {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  /**
  @internal
  */
  filterTransaction(tr, ignore = -1) {
    for (let i2 = 0; i2 < this.config.plugins.length; i2++)
      if (i2 != ignore) {
        let plugin = this.config.plugins[i2];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i2 = 0; i2 < this.config.plugins.length; i2++) {
        let plugin = this.config.plugins[i2];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i2].n : 0, oldState = seen ? seen[i2].state : this;
          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i2)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i2 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i2] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i2 = 0; i2 < fields.length; i2++) {
      let field = fields[i2];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new _EditorState($config);
    for (let i2 = 0; i2 < $config.fields.length; i2++)
      instance[$config.fields[i2].name] = $config.fields[i2].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new _EditorState($config);
    for (let i2 = 0; i2 < fields.length; i2++) {
      let name = fields[i2].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i2].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node2.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
};
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// D:/code/web/node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index3 = 0; ; index3++) {
    node = node.previousSibling;
    if (!node)
      return index3;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false")
        return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset) {
  for (; ; ) {
    if (node.nodeType == 3 && offset)
      return node;
    if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset) {
  for (; ; ) {
    if (node.nodeType == 3 && offset < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset, parent) {
  for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index3 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index3 == 0;
    atEnd = atEnd && index3 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i2 = 0; i2 < stack.length; i2++) {
    let { dom, top, left } = stack[i2];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i2 = 0; i2 < len; i2++) {
    range.setEnd(node, i2 + 1);
    range.setStart(node, i2);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i2 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias);
}
function posFromCaret(view, node, offset, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i2 = startI; ; ) {
      let child = element.childNodes[i2];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i2 = (i2 + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset = Math.min(offset, node.childNodes.length);
      if (offset < node.childNodes.length) {
        let next = node.childNodes[offset], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset++;
      }
    }
    let prev;
    if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset--;
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset, offset), side);
      if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node.nodeValue.length) {
        from--;
        takeSide = 1;
      } else if (side < 0) {
        from--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
      let before = node.childNodes[offset - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset < nodeSize(node)) {
      let after = node.childNodes[offset];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
    let before = node.childNodes[offset - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset < nodeSize(node)) {
    let after = node.childNodes[offset];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f2) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f2();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i2 = 0; i2 < boxes.length; i2++) {
        let box = boxes[i2];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size = 0;
    for (let i2 = 0; i2 < this.children.length; i2++)
      size += this.children[i2].size;
    return size;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i2 = 0; i2 < this.children.length; i2++)
      this.children[i2].destroy();
  }
  posBeforeChild(child) {
    for (let i2 = 0, pos = this.posAtStart; ; i2++) {
      let cur = this.children[i2];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = offset + child.size;
      if (offset == pos && end != offset) {
        while (!child.border && child.children.length) {
          for (let i3 = 0; i3 < child.children.length; i3++) {
            let inner = child.children[i3];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset - child.border);
      offset = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i2 = 0, offset = 0;
    for (let curPos = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset)
      return this.children[i2].domFromPos(offset - this.children[i2].border, side);
    for (let prev; i2 && !(prev = this.children[i2 - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i2--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i2--, enter2 = false) {
        prev = i2 ? this.children[i2 - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i2++, enter2 = false) {
        next = i2 < this.children.length ? this.children[i2] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset = base2, i2 = 0; ; i2++) {
      let child = this.children[i2], end = offset + child.size;
      if (fromOffset == -1 && from <= end) {
        let childBase = offset + child.border;
        if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from, to, childBase);
        from = offset;
        for (let j = i2; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i2 == this.children.length - 1)) {
        to = end;
        for (let j = i2 + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset = end;
    }
    return { node: this.contentDOM, from, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i2 = 0, offset = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = offset + child.size;
      if (from > offset && to < end)
        return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);
      offset = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset && node.nodeValue[offset - 1] == "\n");
        if (brKludge && offset == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from, to) {
    for (let offset = 0, i2 = 0; i2 < this.children.length; i2++) {
      let child = this.children[i2], end = offset + child.size;
      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
        let startInside = offset + child.border, endInside = end - child.border;
        if (from >= startInside && to <= endInside) {
          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  isText(text) {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self)
          return pos;
        if (self.parent)
          return self.parent.posBeforeChild(self);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset ? this.size : 0);
    return this.posAtStart + offset;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from, to) {
    super.markDirty(from, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from > 0)
      nodes = replaceNodes(nodes, 0, from, view);
    for (let i2 = 0; i2 < nodes.length; i2++)
      nodes[i2].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
        let child = this.children[i2];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment14.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i2, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i2 == this.node.childCount ? Mark.none : this.node.child(i2).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i2) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i2))
        ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i2, off))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset, this.node.text.length);
    return super.localPosFromDOM(dom, offset, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from, to, view) {
    let node = this.node.cut(from, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from, to) {
    super.markDirty(from, to);
    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i2 = 0; i2 < descs.length; i2++) {
    let desc = descs[i2], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i2 = 0; i2 < outerDeco.length; i2++) {
    let attrs = outerDeco[i2].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i2 = 0; i2 < curComputed.length; i2++) {
    let deco = curComputed[i2], prev = prevComputed[i2];
    if (i2) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i2 = 0; i2 < prevList.length; i2++)
      if (curList.indexOf(prevList[i2]) == -1)
        dom.classList.remove(prevList[i2]);
    for (let i2 = 0; i2 < curList.length; i2++)
      if (prevList.indexOf(curList[i2]) == -1)
        dom.classList.add(curList[i2]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i2 = 0; i2 < a.length; i2++)
    if (!a[i2].type.eq(b[i2].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i2 = start; i2 < end; i2++)
      this.top.children[i2].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i2 = this.index; i2 < Math.min(this.index + 3, this.top.children.length); i2++) {
        let next = this.top.children[i2];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i2;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index3) {
    let found2 = -1, targetDesc;
    if (index3 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index3 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i2 = this.index, e = Math.min(this.top.children.length, i2 + 5); i2 < e; i2++) {
        let child = this.top.children[i2];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i2;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index3, view) {
    let child = this.top.children[index3];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index3);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i2 = this.index; i2 < this.top.children.length; i2++) {
            if (this.top.children[i2] == desc)
              return i2;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index3, pos) {
    for (let i2 = this.index; i2 < this.top.children.length; i2++) {
      let next = this.top.children[i2];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index3)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i2);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i2);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next = curDesc.children[descI - 1];
          if (next instanceof MarkViewDesc) {
            curDesc = next;
            descI = next.children.length;
          } else {
            desc = next;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node = desc.node;
      if (!node)
        continue;
      if (node != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset = 0;
  if (locals.length == 0) {
    for (let i2 = 0; i2 < parent.childCount; i2++) {
      let child = parent.child(i2);
      onNode(child, locals, deco.forChild(offset, child), i2);
      offset += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i2 = 0; i2 < widgets.length; i2++)
          onWidget(widgets[i2], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index3;
    if (restNode) {
      index3 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index3 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i2 = 0; i2 < active.length; i2++)
      if (active[i2].to <= offset)
        active.splice(i2--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
      active.push(locals[decoIndex++]);
    let end = offset + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i2 = 0; i2 < active.length; i2++)
        if (active[i2].to < cutAt)
          cutAt = active[i2].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset);
        child = child.cut(0, cutAt - offset);
        end = cutAt;
        index3 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset, child), index3);
    offset = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from, to) {
  for (let i2 = 0, pos = 0; i2 < frag.childCount && pos <= to; ) {
    let child = frag.child(i2++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i2 < frag.childCount) {
      let next = frag.child(i2++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from)
        return childStart + found2;
      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from, to, view, replacement) {
  let result = [];
  for (let i2 = 0, off = 0; i2 < nodes.length; i2++) {
    let child = nodes[i2], start = off, end = off += child.size;
    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from)
        result.push(child.slice(0, from - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to)
        result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min = head, max = head;
      for (let i2 = 0; i2 < domSel.rangeCount; i2++) {
        let range = domSel.getRangeAt(i2);
        min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min < 0)
        return null;
      [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];
      $head = doc3.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc3.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset } = view.docView.domFromPos(pos, 0);
  let after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  let before = offset ? node.childNodes[offset - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setStart(node.parentNode, domIndex(node) + 1);
  else
    range.setStart(node, 0);
  range.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f2) => f2(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))
    force = true;
  for (; ; ) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset) {
  while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset < node.childNodes.length) {
    let next = node.childNodes[offset];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset = 0;
  }
}
function textNodeBefore(node, offset) {
  while (node && !offset && !hasBlockDesc(node)) {
    offset = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset) {
    let next = node.childNodes[offset - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset)) {
      node = after;
      offset = 0;
    } else if (before = textNodeBefore(node, offset)) {
      node = before;
      offset = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed24 = getComputedStyle(view.dom).direction;
  return computed24 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice) {
  view.someProp("transformCopied", (f2) => {
    slice = f2(slice, view);
  });
  let context = [], { content, openStart, openEnd } = slice;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i2 = needsWrap.length - 1; i2 >= 0; i2--) {
      let wrapper = doc3.createElement(needsWrap[i2]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f2) => f2(slice, view)) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return { dom: wrap2, text, slice };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f2) => {
      text = f2(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment14.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f2) => f2(text, $context, plainText, view));
    if (parsed) {
      slice = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f2) => {
      html = f2(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i2 = +sliceData[3]; i2 > 0; i2--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice = Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
    if (slice.openStart || slice.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice = closeSlice(slice, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f2) => {
    slice = f2(slice, view);
  });
  return slice;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment14.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from = 0) {
  for (let i2 = wrap2.length - 1; i2 >= from; i2--)
    node = wrap2[i2].create(null, Fragment14.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment14.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment14.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from, to, depth + 1, openEnd);
  if (depth >= from)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment14.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart)
    slice = new Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  if (openEnd < slice.openEnd)
    slice = new Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  return slice;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
var _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap2)
    for (let i2 = 0; i2 < wrap2.length; i2++)
      elt = elt.querySelector(wrap2[i2]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i2 = 0; i2 < nodes.length; i2++) {
    let node = nodes[i2];
    if (node.childNodes.length == 1 && node.textContent == " " && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice, context) {
  if (!slice.size)
    return slice;
  let schema = slice.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice;
  }
  let { content, openStart, openEnd } = slice;
  for (let i2 = array.length - 2; i2 >= 0; i2 -= 2) {
    let type = schema.nodes[array[i2]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment14.from(type.create(array[i2 + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f2) => f2(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f2) => f2(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f2) => f2(view, sel.$from.pos, sel.$to.pos, text)))
      view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    if (view.someProp(propName, (f2) => i2 > $pos.depth ? f2(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f2(view, pos, $pos.node(i2), $pos.before(i2), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i2 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i2);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f2) => f2(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f2) => f2(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f2) => f2(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i2 = $pos.depth + 1; i2 > 0; i2--) {
    let node = i2 > $pos.depth ? $pos.nodeAfter : $pos.node(i2);
    let nodePos = $pos.before(i2);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {
          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !view.state.selection.empty)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f2) => f2(view, event, slice || Slice.empty)))
    return true;
  if (!slice)
    return false;
  let singleNode = sliceSingleNode(slice);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice, move, node) {
    this.slice = slice;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice, !event[dragCopyModifier], node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice = dragging && dragging.slice;
  if (slice) {
    view.someProp("transformPasted", (f2) => {
      slice = f2(slice, view);
    });
  } else {
    slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f2) => f2(view, event, slice || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice)
    return;
  event.preventDefault();
  let insertPos = slice ? dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr);
    else
      tr.deleteSelection();
  }
  let pos = tr.mapping.map(insertPos);
  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode)
    tr.replaceRangeWith(pos, pos, slice.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset, pos - offset, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset, oldOffset) {
    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
    return from >= to ? null : new Decoration(from, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset, oldOffset) {
    let from = mapping.mapResult(span.from + oldOffset, 1);
    if (from.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from.pos)
      return null;
    return new Decoration(from.pos - offset, to.pos - offset, this);
  }
  valid(node, span) {
    let { index: index3, offset } = node.content.findIndex(span.from), child;
    return offset == span.from && !(child = node.child(index3)).isText && offset + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from, to, type) {
    this.from = from;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from, to) {
    return new _Decoration(from, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset = 0) {
    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset, oldOffset) {
    return this.type.map(mapping, this, offset, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from, to, attrs, spec) {
    return new _Decoration(from, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from, to, attrs, spec) {
    return new _Decoration(from, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start, end, result, offset, predicate) {
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let span = this.local[i2];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset, span.to + offset));
    }
    for (let i2 = 0; i2 < this.children.length; i2 += 3) {
      if (this.children[i2] < end && this.children[i2 + 1] > start) {
        let childOff = this.children[i2] + 1;
        this.children[i2 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset, oldOffset, options) {
    let newLocal;
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let mapped = this.local[i2].map(mapping, offset, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i2].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset) {
    let children, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
    for (let i2 = 0; i2 < local.length; i2++)
      if (!local[i2].type.valid(doc3, local[i2]))
        local.splice(i2--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset) {
    let children = this.children, local = this.local;
    for (let i2 = 0; i2 < children.length; i2 += 3) {
      let found2;
      let from = children[i2] + offset, to = children[i2 + 1] + offset;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i2 + 2].removeInner(found2, from + 1);
      if (removed != empty) {
        children[i2 + 2] = removed;
      } else {
        children.splice(i2, 3);
        i2 -= 3;
      }
    }
    if (local.length) {
      for (let i2 = 0, span; i2 < decorations.length; i2++)
        if (span = decorations[i2]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new _DecorationSet(local, children) : empty;
  }
  forChild(offset, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i2 = 0; i2 < this.children.length; i2 += 3)
      if (this.children[i2] >= offset) {
        if (this.children[i2] == offset)
          child = this.children[i2 + 2];
        break;
      }
    let start = offset + 1, end = start + node.content.size;
    for (let i2 = 0; i2 < this.local.length; i2++) {
      let dec = this.local[i2];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from < to)
          (local || (local = [])).push(dec.copy(from, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i2 = 0; i2 < this.local.length; i2++)
      if (!this.local[i2].eq(other.local[i2]))
        return false;
    for (let i2 = 0; i2 < this.children.length; i2 += 3)
      if (this.children[i2] != other.children[i2] || this.children[i2 + 1] != other.children[i2 + 1] || !this.children[i2 + 2].eq(other.children[i2 + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i2 = 0; i2 < this.local.length; i2++) {
      if (!(this.local[i2].type instanceof InlineType))
        result.push(this.local[i2]);
    }
    return result;
  }
  forEachSet(f2) {
    f2(this);
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i2 = 0; i2 < this.members.length; i2++) {
      let result = this.members[i2].forChild(offset, child);
      if (result == empty)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i2 = 0; i2 < this.members.length; i2++)
      if (!this.members[i2].eq(other.members[i2]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i2 = 0; i2 < this.members.length; i2++) {
      let locals = this.members[i2].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f2) {
    for (let i2 = 0; i2 < this.members.length; i2++)
      this.members[i2].forEachSet(f2);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i2 = 0, baseOffset = oldOffset; i2 < mapping.maps.length; i2++) {
    let moved = 0;
    mapping.maps[i2].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i3 = 0; i3 < children.length; i3 += 3) {
        let end = children[i3 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i3] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i3 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i3] += dSize;
          children[i3 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i2].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] < 0) {
      if (children[i2 + 1] == -2) {
        mustRebuild = true;
        children[i2 + 1] = -1;
        continue;
      }
      let from = mapping.map(oldChildren[i2] + oldOffset), fromLocal = from - offset;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i2 + 1] + oldOffset, -1), toLocal = to - offset;
      let { index: index3, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index3);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i2 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i2] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i2] = fromLocal;
          children[i2 + 1] = toLocal;
          children[i2 + 2] = mapped;
        } else {
          children[i2 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i2 = 0; i2 < children.length; i2 += 3)
      if (children[i2 + 1] < 0) {
        children.splice(i2, 3);
        i2 -= 3;
      }
    for (let i2 = 0, j = 0; i2 < built.children.length; i2 += 3) {
      let from = built.children[i2];
      while (j < children.length && children[j] < from)
        j += 3;
      children.splice(j, 0, built.children[i2], built.children[i2 + 1], built.children[i2 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset) {
  if (!offset || !spans.length)
    return spans;
  let result = [];
  for (let i2 = 0; i2 < spans.length; i2++) {
    let span = spans[i2];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i2 = 0; i2 < set.local.length; i2++) {
      let mapped = set.local[i2].map(mapping, offset, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i2].spec);
    }
    for (let i2 = 0; i2 < set.children.length; i2 += 3)
      gather(set.children[i2 + 2], set.children[i2] + oldOffset2 + 1);
  }
  for (let i2 = 0; i2 < children.length; i2 += 3)
    if (children[i2 + 1] == -1)
      gather(children[i2 + 2], oldChildren[i2] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf)
    return null;
  let end = offset + node.nodeSize, found2 = null;
  for (let i2 = 0, span; i2 < spans.length; i2++) {
    if ((span = spans[i2]) && span.from > offset && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i2] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i2 = 0; i2 < array.length; i2++)
    if (array[i2] != null)
      result.push(array[i2]);
  return result;
}
function buildTree(spans, node, offset, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (let i2 = 0; i2 < locals.length; i2++)
    if (!locals[i2].type.valid(node, locals[i2])) {
      if (options.onRemove)
        options.onRemove(locals[i2].spec);
      locals.splice(i2--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i2 = 0; i2 < working.length - 1; i2++) {
    let span = working[i2];
    if (span.from != span.to)
      for (let j = i2 + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i2] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i2, deco) {
  while (i2 < array.length && byPos(deco, array[i2]) > 0)
    i2++;
  array.splice(i2, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f2) => {
    let result = f2(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i2 = 0; i2 < mutations.length; i2++)
        this.queue.push(mutations[i2]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i2 = 0; i2 < take.length; i2++)
          this.queue.push(take[i2]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i2 = 0; i2 < mutations.length; i2++) {
        let result = this.registerMutation(mutations[i2], added);
        if (result) {
          from = from < 0 ? result.from : Math.min(result.from, from);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from > -1 || newSel) {
      if (from > -1) {
        view.docView.markDirty(from, to);
        checkCSS(view);
      }
      this.handleDOMChange(from, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
        let node = mut.addedNodes[i2];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i2 = 0; i2 < mut.addedNodes.length; i2++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i2];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    let anchor2 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from, head: head + from };
  }
  return { doc: doc3, sel, from, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from);
  let shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr2 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      tr = view.state.tr;
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f2) => f2(view, chFrom, chTo, text)))
        return;
      tr = view.state.tr.insertText(text, chFrom, chTo);
    }
  }
  if (!tr)
    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    let sel2 = resolveSelection(view, tr.doc, parse.sel);
    if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
      tr.setSelection(sel2);
  }
  if (storedMarks)
    tr.ensureMarks(storedMarks);
  if (compositionID)
    tr.setMeta("composition", compositionID);
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i2 = 0; i2 < prevMarks.length; i2++)
    added = prevMarks[i2].removeFromSet(added);
  for (let i2 = 0; i2 < curMarks.length; i2++)
    removed = curMarks[i2].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i2 = 0; i2 < prev.childCount; i2++)
    updated.push(update(prev.child(i2)));
  if (Fragment14.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a3;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a3 = this.dragging) === null || _a3 === void 0 ? void 0 : _a3.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode))
      ;
    else if (this.someProp("handleScrollToSelection", (f2) => f2(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
        let plugin = this.directPlugins[i2];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i2 = 0; i2 < this.state.plugins.length; i2++) {
        let plugin = this.state.plugins[i2];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i2 = 0; i2 < this.pluginViews.length; i2++) {
        let pluginView = this.pluginViews[i2];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f2) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f2 ? f2(prop) : prop))
      return value;
    for (let i2 = 0; i2 < this.directPlugins.length; i2++) {
      let prop2 = this.directPlugins[i2].props[propName];
      if (prop2 != null && (value = f2 ? f2(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i2 = 0; i2 < plugins.length; i2++) {
        let prop2 = plugins[i2].props[propName];
        if (prop2 != null && (value = f2 ? f2(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice) {
    return serializeForClipboard(this, slice);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(tr) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr);
    else
      this.updateState(this.state.apply(tr));
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// D:/code/web/node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i2 = 0; i2 < 10; i2++)
  base[48 + i2] = base[96 + i2] = String(i2);
var i2;
for (i2 = 1; i2 <= 24; i2++)
  base[i2 + 111] = "F" + i2;
var i2;
for (i2 = 65; i2 <= 90; i2++) {
  base[i2] = String.fromCharCode(i2 + 32);
  shift[i2] = String.fromCharCode(i2);
}
var i2;
for (code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}

// D:/code/web/node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i2 = 0; i2 < parts.length - 1; i2++) {
    let mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map)
    copy2[normalizeKeyName(prop)] = map[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// D:/code/web/node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
var joinTextblockForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr = state.tr.step(step);
    tr.setSelection(TextSelection.create(tr.doc, beforePos));
    dispatch(tr.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      if ($pos.index(i2) > 0)
        return $pos.doc.resolve($pos.before(i2 + 1));
      if ($pos.node(i2).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i2 = $pos.depth - 1; i2 >= 0; i2--) {
      let parent = $pos.node(i2);
      if ($pos.index(i2) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i2 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state.tr.join(point);
    if (nodeSel)
      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i2 = 0; i2 < match.edgeCount; i2++) {
    let { type } = match.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        let splitType = splitNode && splitNode($to.parent, atEnd, $from);
        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr.deleteSelection();
    let splitPos = tr.mapping.map($from.pos);
    let can = canSplit(tr.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr.doc, splitPos, types.length, types);
    }
    tr.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index3 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index3, index3 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment14.empty;
      for (let i2 = conn.length - 1; i2 >= 0; i2--)
        wrap2 = Fragment14.from(conn[i2].create(null, wrap2));
      wrap2 = Fragment14.from(before.copy(wrap2));
      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))
        tr.join($joinAt.pos);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment14.empty;
        for (let i2 = wrap2.length - 1; i2 >= 0; i2--)
          end = Fragment14.from(wrap2[i2].copy(end));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i2 = 0; i2 < state.selection.ranges.length && !applicable; i2++) {
      let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i2];
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index3 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state.tr;
      for (let i2 = 0; i2 < state.selection.ranges.length; i2++) {
        let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i2];
        tr.setBlockType(from, to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i2 = 0; i2 < commands2.length; i2++)
      if (commands2[i2](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// D:/code/web/node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr, range, listType, attrs))
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc3 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc3.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap2)
    return false;
  if (tr)
    doWrapInList(tr, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  let content = Fragment14.empty;
  for (let i2 = wrappers.length - 1; i2 >= 0; i2--)
    content = Fragment14.from(wrappers[i2].type.create(wrappers[i2].attrs, content));
  tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i2 = 0; i2 < wrappers.length; i2++)
    if (wrappers[i2].type == listType)
      found2 = i2 + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i2 = range.startIndex, e = range.endIndex, first2 = true; i2 < e; i2++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i2).nodeSize;
  }
  return tr;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment14.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr.lift(range, target);
  let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);
  if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr.join($after.pos);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr = state.tr, list = range.parent;
  for (let pos = range.end, i2 = range.endIndex - 1, e = range.startIndex; i2 > e; i2--) {
    pos -= list.child(i2).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment14.empty : Fragment14.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment14.empty : Fragment14.from(list.copy(Fragment14.empty))).append(atEnd ? Fragment14.empty : Fragment14.from(list.copy(Fragment14.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment14.from(nestedBefore ? itemType.create() : null);
      let slice = new Slice(Fragment14.from(itemType.create(null, Fragment14.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// D:/code/web/node_modules/@tiptap/core/dist/index.js
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props = this.buildProps(tr);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command3]) => {
      const method = (...args) => {
        const callback = command3(...args)(props);
        if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command3]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr, shouldDispatch);
          const callback = command3(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run2
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr = startTr || state.tr;
    const props = this.buildProps(tr, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command3]) => {
      return [name, (...args) => command3(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr, dispatch)
    };
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command3]) => {
          return [name, (...args) => command3(...args)(props)];
        }));
      }
    };
    return props;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a3;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a3 = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a3 === void 0 ? void 0 : _a3.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraNodeFields = extensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
      linebreakReplacement: callOrReturn(getExtensionField(extension, "linebreakReplacement", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a4;
        return [extensionAttribute.name, { default: (_a4 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a4 === void 0 ? void 0 : _a4.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node) => renderHTML({
        node,
        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const extraMarkFields = extensions.reduce((fields, e) => {
      const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a4;
        return [extensionAttribute.name, { default: (_a4 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a4 === void 0 ? void 0 : _a4.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index3) => {
    var _a3, _b3;
    const chunk = ((_b3 = (_a3 = node.type.spec).toText) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, {
      node,
      pos,
      parent,
      index: index3
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text, find) => {
  if (isRegExp(find)) {
    return find.exec(text);
  }
  const inputRuleMatch = find(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a3;
  const { editor, from, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from);
  if (
    // check for code node
    $from.parent.type.spec.code || !!((_a3 = $from.nodeBefore || $from.nodeAfter) === null || _a3 === void 0 ? void 0 : _a3.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range = {
      from: from - (match[0].length - text.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from,
      to,
      text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr, prev, state) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment14.from(text), state.schema);
            }
            const { from } = simulatedInputMeta;
            const to = from + text.length;
            run$1({
              editor,
              from,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from, to, text) {
        return run$1({
          editor,
          from,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Mark2 = class _Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Mark(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr.removeStoredMark(removeMark2);
      }
      tr.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr);
      return true;
    }
    return false;
  }
};
function isNumber(value) {
  return typeof value === "number";
}
var pasteRuleMatcherHandler = (text, find, event) => {
  if (isRegExp(find)) {
    return [...text.matchAll(find)];
  }
  const matches2 = find(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run(config) {
  const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "￼");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a3;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a3 = event.clipboardData) === null || _a3 === void 0 ? void 0 : _a3.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({ state, from, to, rule, pasteEvt }) => {
    const tr = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr
    });
    const handler = run({
      editor,
      state: chainableState,
      from: Math.max(from - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a3;
          dragSourceElement = ((_a3 = view.dom.parentElement) === null || _a3 === void 0 ? void 0 : _a3.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a3;
            const html = (_a3 = event.clipboardData) === null || _a3 === void 0 ? void 0 : _a3.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment14.from(text), state.schema);
          }
          const { from: from2 } = simulatedPasteMeta;
          const to2 = from2 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from2,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from) || !to || from === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  const filtered = items.filter((el, index3) => items.indexOf(el) !== index3);
  return Array.from(new Set(filtered));
}
var ExtensionManager = class _ExtensionManager {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = _ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Returns a flattened and sorted extension list while
   * also checking for duplicated extensions and warns the user.
   * @param extensions An array of Tiptap extensions
   * @returns An flattened and sorted array of Tiptap extensions
   */
  static resolve(extensions) {
    const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  /**
   * Create a flattened array of extensions by traversing the `addExtensions` field.
   * @param extensions An array of Tiptap extensions
   * @returns A flattened array of Tiptap extensions
   */
  static flatten(extensions) {
    return extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  /**
   * Sort extensions by priority.
   * @param extensions An array of Tiptap extensions
   * @returns A sorted array of Tiptap extensions by priority
   */
  static sort(extensions) {
    const defaultPriority = 100;
    return extensions.sort((a, b) => {
      const priorityA = getExtensionField(a, "priority") || defaultPriority;
      const priorityB = getExtensionField(b, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = _ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node, view, getPos, decorations, innerDecorations) => {
        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
        return addNodeView()({
          // pass-through
          node,
          view,
          getPos,
          decorations,
          innerDecorations,
          // tiptap-specific
          editor,
          extension,
          HTMLAttributes
        });
      };
      return [extension.name, nodeview];
    }));
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    this.extensions.forEach((extension) => {
      var _a3;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a3 = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a3 !== void 0 ? _a3 : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
};
var Extension = class _Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Extension({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function getTextBetween(startNode, range, options) {
  const { from, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from, to, (node, pos, parent, index3) => {
    var _a3;
    if (node.isBlock && pos > from) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index: index3,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a3 = node === null || node === void 0 ? void 0 : node.text) === null || _a3 === void 0 ? void 0 : _a3.slice(Math.max(from, pos) - pos, to - pos);
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));
}
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from, to };
            return getTextBetween(doc3, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a3;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a3 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a3 === void 0 ? void 0 : _a3.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
var clearNodes = () => ({ state, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr.deleteRange(originRange.from, originRange.to);
  const newPos = tr.mapping.map(targetPos);
  tr.insert(newPos, contentSlice.content);
  tr.setSelection(new TextSelection(tr.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr, dispatch }) => {
  const { from, to } = range;
  if (dispatch) {
    tr.delete(from, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a3;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a3 = start.node.marks[0]) === null || _a3 === void 0 ? void 0 : _a3.attrs);
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr;
  const { $from, from, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i2 = 0; i2 < items.length; i2 += 1) {
    if (items[i2](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min = 0, max = 0) {
  return Math.min(Math.max(value, min), max);
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn) => (props) => {
  return items.every((item, index3) => fn(item, { ...props, index: index3 }));
};
var insertContent = (value, options) => ({ tr, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i2 = children.length - 1; i2 >= 0; i2 -= 1) {
    const child = children[i2];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  if (content instanceof Node2 || content instanceof Fragment14) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment14.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
      }
    }
    const parser = DOMParser.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd2(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map = tr.mapping.maps[last];
  let end = 0;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
  var _a3;
  if (dispatch) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        },
        errorOnInvalidContent: (_a3 = options.errorOnInvalidContent) !== null && _a3 !== void 0 ? _a3 : editor.options.enableContentCheck
      });
    } catch (e) {
      editor.emit("contentError", {
        editor,
        error: e,
        disableCollaboration: () => {
          if (editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
      return false;
    }
    let { from, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment14) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr.insertText(newContent, from, to);
    } else {
      newContent = content;
      tr.replaceWith(from, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd2(tr, tr.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr.setMeta("applyInputRules", { from, text: newContent });
    }
    if (options.applyPasteRules) {
      tr.setMeta("applyPasteRules", { from, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ state, dispatch, tr }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i2 = 0; i2 < parts.length - 1; i2 += 1) {
    const mod = parts[i2];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f2) => f2(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr.mapping);
    if (newStep && dispatch) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr, dispatch }) => {
  if (dispatch) {
    tr.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr, dispatch }) => {
  if (dispatch) {
    const selection = new AllSelection(tr.doc);
    tr.setSelection(selection);
  }
  return true;
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
function createDocument(content, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
var setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr, dispatch, commands: commands2 }) => {
  var _a3, _b3;
  const { doc: doc3 } = tr;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: (_a3 = options.errorOnInvalidContent) !== null && _a3 !== void 0 ? _a3 : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr.setMeta("preventUpdate", !emitUpdate);
  }
  return commands2.insertContentAt({ from: 0, to: doc3.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: (_b3 = options.errorOnInvalidContent) !== null && _b3 !== void 0 ? _b3 : editor.options.enableContentCheck
  });
};
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function defaultBlockAt2(match) {
  for (let i2 = 0; i2 < match.edgeCount; i2 += 1) {
    const { type } = match.edge(i2);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i2 = $pos.depth; i2 > 0; i2 -= 1) {
    const node = $pos.node(i2);
    if (predicate(node)) {
      return {
        pos: i2 > 0 ? $pos.before(i2) : 0,
        start: $pos.start(i2),
        depth: i2,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getText2(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item) => {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(...node.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {
  var _a3;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a3 = node.text) !== null && _a3 !== void 0 ? _a3 : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function canSetMark(state, tr, newMarkType) {
  var _a3;
  const { selection } = tr;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a3 = state.storedMarks) !== null && _a3 !== void 0 ? _a3 : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range) => {
        const from = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr, type);
};
var setMeta = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType2(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr;
    const from = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from);
    tr.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr;
    const { from, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr.deleteSelection();
      }
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor }) => {
  var _a3;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment14.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment14.from($from.node(d).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a3 = type.contentMatch.defaultType) === null || _a3 === void 0 ? void 0 : _a3.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment14.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
var joinListForwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const after = tr.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands2.setNode(toggleType, attributesToCopy);
  }
  return commands2.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i2 = 0; i2 < plugins.length; i2 += 1) {
    const plugin = plugins[i2];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
  var _a3;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from, to } = selection;
    const attrs = (_a3 = $from.marks().find((mark) => mark.type === type)) === null || _a3 === void 0 ? void 0 : _a3.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from = range.from;
      to = range.to;
    }
    tr.removeMark(from, to, type);
  } else {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      const from = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr.selection.empty) {
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from, to, (node, pos) => {
          if (pos < from && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr.addMark(trimmedFrom2, trimmedTo2, markType.create({
                    ...mark.attrs,
                    ...attributes
                  }));
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var commands = Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear: createParagraphNear2,
  cut,
  deleteCurrentNode,
  deleteNode,
  deleteRange: deleteRange2,
  deleteSelection: deleteSelection2,
  enter,
  exitCode: exitCode2,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinBackward: joinBackward2,
  joinDown: joinDown2,
  joinForward: joinForward2,
  joinItemBackward,
  joinItemForward,
  joinTextblockBackward: joinTextblockBackward2,
  joinTextblockForward: joinTextblockForward2,
  joinUp: joinUp2,
  keyboardShortcut,
  lift: lift3,
  liftEmptyBlock: liftEmptyBlock2,
  liftListItem: liftListItem2,
  newlineInCode: newlineInCode2,
  resetAttributes,
  scrollIntoView,
  selectAll: selectAll2,
  selectNodeBackward: selectNodeBackward2,
  selectNodeForward: selectNodeForward2,
  selectParentNode: selectParentNode2,
  selectTextblockEnd: selectTextblockEnd2,
  selectTextblockStart: selectTextblockStart2,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem: sinkListItem2,
  splitBlock: splitBlock2,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn: wrapIn2,
  wrapInList: wrapInList2
});
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey = new PluginKey("focusEvents");
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands2.command(({ tr }) => {
        const { selection, doc: doc3 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr2) => tr2.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty = isNodeEmpty(newState.doc);
          if (!isEmpty) {
            return;
          }
          const tr = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var index = Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Drop,
  Editable,
  FocusEvents,
  Keymap,
  Paste,
  Tabindex,
  focusEventsPluginKey
});
var NodePos = class _NodePos {
  get name() {
    return this.node.type.name;
  }
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a3;
    return (_a3 = this.actualDepth) !== null && _a3 !== void 0 ? _a3 : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index3 = 0; index3 < attrKeys.length; index3 += 1) {
            const key = attrKeys[index3];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr } = this.editor.state;
    tr.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr);
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));
    this.on("paste", ({ event, slice }) => this.options.onPaste(event, slice));
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.view.state;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = prevPlugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a3, _b3;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b3 = (_a3 = this.options.coreExtensionOptions) === null || _a3 === void 0 ? void 0 : _a3.clipboardTextSerializer) === null || _b3 === void 0 ? void 0 : _b3.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView() {
    var _a3;
    let doc3;
    try {
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if (this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
    }
    const selection = resolveFocusPosition(doc3, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a3 = this.options.editorProps) === null || _a3 === void 0 ? void 0 : _a3.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc3,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a3;
        return (_a3 = this.capturedTransaction) === null || _a3 === void 0 ? void 0 : _a3.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.emit("beforeTransaction", {
      editor: this,
      transaction,
      nextState: state
    });
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Get the number of characters for the current document.
   *
   * @deprecated
   */
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    if (this.view) {
      const dom = this.view.dom;
      if (dom && dom.editor) {
        delete dom.editor;
      }
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a3;
    return !((_a3 = this.view) === null || _a3 === void 0 ? void 0 : _a3.docView);
  }
  $node(selector, attributes) {
    var _a3;
    return ((_a3 = this.$doc) === null || _a3 === void 0 ? void 0 : _a3.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a3;
    return ((_a3 = this.$doc) === null || _a3 === void 0 ? void 0 : _a3.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr } = state;
      const start = range.from;
      let end = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr.insertText(lastChar, start + match[0].length - 1);
        tr.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start : start - 1;
        tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));
      }
      tr.scrollIntoView();
    }
  });
}
var Node3 = class _Node {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new _Node(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
};
function escapeForRegEx(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// D:/code/web/node_modules/@tiptap/extension-document/dist/index.js
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+"
});

// D:/code/web/node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node3.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});

// D:/code/web/node_modules/@tiptap/extension-placeholder/dist/index.js
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something …",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty = !node.isLeaf && isNodeEmpty(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});

// D:/code/web/node_modules/@tiptap/extension-text/dist/index.js
var Text = Node3.create({
  name: "text",
  group: "inline"
});

// D:/code/web/node_modules/@tiptap/suggestion/dist/index.js
function findSuggestionMatch(config) {
  var _a3;
  const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position } = config;
  const allowSpaces = allowSpacesOption && !allowToIncludeChar;
  const escapedChar = escapeForRegEx(char);
  const suffix = new RegExp(`\\s${escapedChar}$`);
  const prefix = startOfLine ? "^" : "";
  const finalEscapedChar = allowToIncludeChar ? "" : escapedChar;
  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${finalEscapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${finalEscapedChar}]*`, "gm");
  const text = ((_a3 = $position.nodeBefore) === null || _a3 === void 0 ? void 0 : _a3.isText) && $position.nodeBefore.text;
  if (!text) {
    return null;
  }
  const textFrom = $position.pos - text.length;
  const match = Array.from(text.matchAll(regexp)).pop();
  if (!match || match.input === void 0 || match.index === void 0) {
    return null;
  }
  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from = textFrom + match.index;
  let to = from + match[0].length;
  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {
    match[0] += " ";
    to += 1;
  }
  if (from < $position.pos && to >= $position.pos) {
    return {
      range: {
        from,
        to
      },
      query: match[0].slice(char.length),
      text: match[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({ pluginKey = SuggestionPluginKey, editor, char = "@", allowSpaces = false, allowToIncludeChar = false, allowedPrefixes = [" "], startOfLine = false, decorationTag = "span", decorationClass = "suggestion", command: command3 = () => null, items = () => [], render: render3 = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch }) {
  let props;
  const renderer = render3 === null || render3 === void 0 ? void 0 : render3();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a3, _b3, _c2, _d2, _e2, _f2, _g;
          const prev = (_a3 = this.key) === null || _a3 === void 0 ? void 0 : _a3.getState(prevState);
          const next = (_b3 = this.key) === null || _b3 === void 0 ? void 0 : _b3.getState(view.state);
          const moved = prev.active && next.active && prev.range.from !== next.range.from;
          const started = !prev.active && next.active;
          const stopped = prev.active && !next.active;
          const changed = !started && !stopped && prev.query !== next.query;
          const handleStart = started || moved && changed;
          const handleChange = changed || moved;
          const handleExit = stopped || moved && changed;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              return command3({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for popper.js or tippy.js
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a4;
              const { decorationId } = (_a4 = this.key) === null || _a4 === void 0 ? void 0 : _a4.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c2 = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c2 === void 0 ? void 0 : _c2.call(renderer, props);
          }
          if (handleChange) {
            (_d2 = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d2 === void 0 ? void 0 : _d2.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e2 = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e2 === void 0 ? void 0 : _e2.call(renderer, props);
          }
          if (handleChange) {
            (_f2 = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f2 === void 0 ? void 0 : _f2.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a3;
          if (!props) {
            return;
          }
          (_a3 = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a3 === void 0 ? void 0 : _a3.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, _oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty: empty2, from } = selection;
        const next = { ...prev };
        next.composing = composing;
        if (isEditable && (empty2 || editor.view.composing)) {
          if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          const match = findSuggestionMatch$1({
            char,
            allowSpaces,
            allowToIncludeChar,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match && allow({
            editor,
            state,
            range: match.range,
            isActive: prev.active
          })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match.range;
            next.query = match.query;
            next.text = match.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        if (!next.active) {
          next.decorationId = null;
          next.range = { from: 0, to: 0 };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a3;
        const { active, range } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a3 = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a3 === void 0 ? void 0 : _a3.call(renderer, { view, event, range })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range, decorationId } = plugin.getState(state);
        if (!active) {
          return null;
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range.from, range.to, {
            nodeName: decorationTag,
            class: decorationClass,
            "data-decoration-id": decorationId
          })
        ]);
      }
    }
  });
  return plugin;
}

// D:/code/web/node_modules/@tiptap/extension-mention/dist/index.js
var MentionPluginKey = new PluginKey("mention");
var Mention = Node3.create({
  name: "mention",
  priority: 101,
  addOptions() {
    return {
      HTMLAttributes: {},
      renderText({ options, node }) {
        var _a3;
        return `${options.suggestion.char}${(_a3 = node.attrs.label) !== null && _a3 !== void 0 ? _a3 : node.attrs.id}`;
      },
      deleteTriggerWithBackspace: false,
      renderHTML({ options, node }) {
        var _a3;
        return [
          "span",
          mergeAttributes(this.HTMLAttributes, options.HTMLAttributes),
          `${options.suggestion.char}${(_a3 = node.attrs.label) !== null && _a3 !== void 0 ? _a3 : node.attrs.id}`
        ];
      },
      suggestion: {
        char: "@",
        pluginKey: MentionPluginKey,
        command: ({ editor, range, props }) => {
          var _a3, _b3, _c2;
          const nodeAfter = editor.view.state.selection.$to.nodeAfter;
          const overrideSpace = (_a3 = nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.text) === null || _a3 === void 0 ? void 0 : _a3.startsWith(" ");
          if (overrideSpace) {
            range.to += 1;
          }
          editor.chain().focus().insertContentAt(range, [
            {
              type: this.name,
              attrs: props
            },
            {
              type: "text",
              text: " "
            }
          ]).run();
          (_c2 = (_b3 = editor.view.dom.ownerDocument.defaultView) === null || _b3 === void 0 ? void 0 : _b3.getSelection()) === null || _c2 === void 0 ? void 0 : _c2.collapseToEnd();
        },
        allow: ({ state, range }) => {
          const $from = state.doc.resolve(range.from);
          const type = state.schema.nodes[this.name];
          const allow = !!$from.parent.type.contentMatch.matchType(type);
          return allow;
        }
      }
    };
  },
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      },
      label: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-label"),
        renderHTML: (attributes) => {
          if (!attributes.label) {
            return {};
          }
          return {
            "data-label": attributes.label
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `span[data-type="${this.name}"]`
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    if (this.options.renderLabel !== void 0) {
      console.warn("renderLabel is deprecated use renderText and renderHTML instead");
      return [
        "span",
        mergeAttributes({ "data-type": this.name }, this.options.HTMLAttributes, HTMLAttributes),
        this.options.renderLabel({
          options: this.options,
          node
        })
      ];
    }
    const mergedOptions = { ...this.options };
    mergedOptions.HTMLAttributes = mergeAttributes({ "data-type": this.name }, this.options.HTMLAttributes, HTMLAttributes);
    const html = this.options.renderHTML({
      options: mergedOptions,
      node
    });
    if (typeof html === "string") {
      return [
        "span",
        mergeAttributes({ "data-type": this.name }, this.options.HTMLAttributes, HTMLAttributes),
        html
      ];
    }
    return html;
  },
  renderText({ node }) {
    if (this.options.renderLabel !== void 0) {
      console.warn("renderLabel is deprecated use renderText and renderHTML instead");
      return this.options.renderLabel({
        options: this.options,
        node
      });
    }
    return this.options.renderText({
      options: this.options,
      node
    });
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr, state }) => {
        let isMention = false;
        const { selection } = state;
        const { empty: empty2, anchor } = selection;
        if (!empty2) {
          return false;
        }
        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
          if (node.type.name === this.name) {
            isMention = true;
            tr.insertText(this.options.deleteTriggerWithBackspace ? "" : this.options.suggestion.char || "", pos, pos + node.nodeSize);
            return false;
          }
        });
        return isMention;
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      Suggestion({
        editor: this.editor,
        ...this.options.suggestion
      })
    ];
  }
});

// D:/code/web/node_modules/@tiptap/extension-image/dist/index.js
var inputRegex = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image2 = Node3.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-file.mjs
var CustomImage = Image2.extend({
  name: "custom-image",
  addAttributes() {
    return {
      ...Image2.config.addAttributes(),
      class: {
        default: "image",
        rendered: false
      }
    };
  },
  addCommands() {
    return {
      setImage: (options) => ({ tr, commands: commands2 }) => {
        var _a3, _b3, _c2;
        if (((_c2 = (_b3 = (_a3 = tr.selection) == null ? void 0 : _a3.node) == null ? void 0 : _b3.type) == null ? void 0 : _c2.name) == "custom-image") {
          return commands2.updateAttributes("custom-image", options);
        } else {
          return commands2.insertContent({
            type: this.name,
            attrs: options
          });
        }
      }
    };
  },
  renderHTML({ node, HTMLAttributes }) {
    var _a3;
    HTMLAttributes.class = (((_a3 = node.attrs.class) == null ? void 0 : _a3.includes("custom-image-")) ? "" : "custom-image-") + node.attrs.class;
    return [
      "img",
      HTMLAttributes
    ];
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-at/index.mjs
var currentConversationID = "";
var memberList = [];
var allMemberList = [];
var showMemberList = [];
var selectedIndex = 0;
var isGroup = false;
var command2;
var all = {
  userID: qt.TYPES.MSG_AT_ALL,
  nick: "所有人",
  isAll: true,
  avatar: "https://web.sdk.qcloud.com/im/assets/images/at.svg"
};
Jt.watch(o.CONV, {
  currentConversationID: (id) => {
    if (id !== currentConversationID) {
      currentConversationID = id;
      if (currentConversationID == null ? void 0 : currentConversationID.startsWith("GROUP")) {
        isGroup = true;
      } else {
        isGroup = false;
        memberList = [];
        allMemberList = [];
        showMemberList = [];
      }
    }
  }
});
Jt.watch(o.CUSTOM, {
  memberList: (list) => {
    if (isGroup && Array.isArray(list)) {
      memberList = list;
      allMemberList = [all, ...memberList];
      showMemberList = allMemberList;
    }
  }
});
var MessageInputAtSuggestion = () => {
  return {
    allowedPrefixes: null,
    items: (props) => {
      if (!isGroup) {
        return;
      }
      const queryResult = allMemberList == null ? void 0 : allMemberList.filter(
        (item) => {
          var _a3, _b3, _c2, _d2, _e2, _f2;
          return ((_c2 = (_a3 = item == null ? void 0 : item.nick) == null ? void 0 : _a3.toLowerCase()) == null ? void 0 : _c2.startsWith((_b3 = props == null ? void 0 : props.query) == null ? void 0 : _b3.toLowerCase())) || ((_f2 = (_d2 = item == null ? void 0 : item.userID) == null ? void 0 : _d2.toLowerCase()) == null ? void 0 : _f2.startsWith((_e2 = props == null ? void 0 : props.query) == null ? void 0 : _e2.toLowerCase()));
        }
      );
      showMemberList = (queryResult == null ? void 0 : queryResult.length) ? queryResult : allMemberList;
      i.setShowMemberList(showMemberList);
      return showMemberList;
    },
    render: () => {
      return {
        onStart: (props) => {
          if (!isGroup) {
            return;
          }
          i.toggleAtList(true);
          if (!(props == null ? void 0 : props.clientRect)) {
            return;
          }
          const rect = props == null ? void 0 : props.clientRect();
          if ((rect == null ? void 0 : rect.left) && (rect == null ? void 0 : rect.top) && !isH5) {
            i.handleAtListPosition({
              left: rect == null ? void 0 : rect.left,
              top: rect == null ? void 0 : rect.top
            });
          }
          command2 = props.command;
        },
        onUpdate(props) {
          if (!isGroup) {
            return;
          }
          if (!(props == null ? void 0 : props.clientRect)) {
            return;
          }
          const rect = props == null ? void 0 : props.clientRect();
          if ((rect == null ? void 0 : rect.left) && (rect == null ? void 0 : rect.top) && !isH5) {
            i.handleAtListPosition({
              left: rect == null ? void 0 : rect.left,
              top: rect == null ? void 0 : rect.top
            });
          }
        },
        onKeyDown(props) {
          var _a3, _b3;
          if (!isGroup) {
            return;
          }
          if (props.event.key === "Enter") {
            (_a3 = props.event) == null ? void 0 : _a3.stopPropagation();
            (_b3 = props.event) == null ? void 0 : _b3.preventDefault();
          }
          if (props.event.key === "Escape") {
            i.toggleAtList(false);
            showMemberList = allMemberList;
            return true;
          }
          if ((props == null ? void 0 : props.event.key) === "ArrowUp") {
            upHandler();
            return true;
          }
          if ((props == null ? void 0 : props.event.key) === "ArrowDown") {
            downHandler();
            return true;
          }
          if ((props == null ? void 0 : props.event.key) === "Enter") {
            enterHandler();
            return true;
          }
          return false;
        },
        onExit() {
          if (!isGroup) {
            return;
          }
          i.toggleAtList(false);
          showMemberList = allMemberList;
          i.handleAtListPosition({
            left: 0,
            top: 0
          });
        }
      };
    }
  };
};
var upHandler = () => {
  if (!(showMemberList == null ? void 0 : showMemberList.length))
    return;
  selectedIndex = (selectedIndex + (showMemberList == null ? void 0 : showMemberList.length) - 1) % (showMemberList == null ? void 0 : showMemberList.length);
  i.setCurrentSelectIndex(selectedIndex);
};
var downHandler = () => {
  if (!(showMemberList == null ? void 0 : showMemberList.length))
    return;
  selectedIndex = (selectedIndex + 1) % (showMemberList == null ? void 0 : showMemberList.length);
  i.setCurrentSelectIndex(selectedIndex);
};
var enterHandler = () => {
  selectItem(selectedIndex);
};
var selectItem = (index3) => {
  if (!(showMemberList == null ? void 0 : showMemberList.length))
    return;
  const item = showMemberList[index3];
  if (item) {
    command2 && command2({
      id: item == null ? void 0 : item.userID,
      label: (item == null ? void 0 : item.nick) || (item == null ? void 0 : item.userID)
    });
  }
};
i.selectItem = selectItem;

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/utils/riseInput.mjs
var ua = navigator.userAgent;
function getScrollTypeByPlatform() {
  if (f) {
    if (/Safari\//.test(ua) || /IOS 11_[0-3]\D/.test(ua)) {
      return 0;
    }
    return 1;
  }
  return 2;
}
function riseInput(input, target) {
  const scrollType = getScrollTypeByPlatform();
  let scrollTimer;
  if (!target) {
    target = input;
  }
  const scrollIntoView2 = () => {
    if (scrollType === 0)
      return;
    if (scrollType === 1) {
      document.body.scrollTop = document.body.scrollHeight;
    } else {
      target == null ? void 0 : target.scrollIntoView(false);
    }
  };
  input.addEventListener("focus", () => {
    const timer = setTimeout(() => {
      scrollIntoView2();
      clearTimeout(timer);
    }, 300);
    scrollTimer = setTimeout(scrollIntoView2, 1e3);
  });
  input.addEventListener("blur", () => {
    clearTimeout(scrollTimer);
    if (scrollType && f) {
      const timer = setTimeout(() => {
        document.body.scrollIntoView();
        clearTimeout(timer);
      });
    }
  });
}

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/conversationDraft.mjs
var __defProp6 = Object.defineProperty;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField6 = (obj, key, value) => __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
var _ConversationDraftManager = class _ConversationDraftManager2 {
  constructor() {
    __publicField6(this, "quoteMessageMap", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    if (!_ConversationDraftManager2.instance) {
      _ConversationDraftManager2.instance = new _ConversationDraftManager2();
    }
    return _ConversationDraftManager2.instance;
  }
  setStore(conversationID, draftContent, abstract, quoteMessage) {
    var _a3, _b3;
    if (conversationID && (this.isEditorNotEmpty(draftContent) || ((_a3 = quoteMessage == null ? void 0 : quoteMessage.message) == null ? void 0 : _a3.ID))) {
      let additionalDraftInfo = {};
      if ((_b3 = quoteMessage == null ? void 0 : quoteMessage.message) == null ? void 0 : _b3.ID) {
        this.quoteMessageMap.set(quoteMessage.message.ID, quoteMessage.message);
        additionalDraftInfo = { messageID: quoteMessage.message.ID, type: quoteMessage.type };
      }
      const draftParams = {
        conversationID,
        draftInfo: {
          html: draftContent,
          abstract,
          ...additionalDraftInfo
        }
      };
      Xt.setConversationDraft(draftParams);
      Jt.update(o.CHAT, "quoteMessage", { message: void 0, type: "quote" });
    }
  }
  getStore(conversationID, setEditorContentCallback) {
    const conversation = Jt.getConversationModel(conversationID);
    if (!conversation) {
      return;
    }
    if (conversation.conversationID && conversation.draftText) {
      const draftObject = JSONToObject(conversation.draftText);
      Jt.update(o.CHAT, "quoteMessage", { message: this.quoteMessageMap.get(draftObject.messageID) || void 0, type: draftObject.type });
      setEditorContentCallback(draftObject.html);
    }
    Xt.setConversationDraft({ conversationID: conversation.conversationID });
  }
  generateAbstract(editorContent) {
    let abstract = "";
    editorContent == null ? void 0 : editorContent.forEach((item) => {
      switch (item.type) {
        case "text":
          abstract += transformTextWithKeysToEmojiNames(item.payload.text || "");
          break;
        case "image":
          abstract += Wt.t("TUIChat.图片");
          break;
        case "video":
          abstract += Wt.t("TUIChat.视频");
          break;
        case "file":
          abstract += Wt.t("TUIChat.文件");
          break;
      }
    });
    return abstract;
  }
  isEditorNotEmpty(editorHTML) {
    return editorHTML && !editorHTML.includes("is-empty") && editorHTML !== "<p></p>";
  }
};
__publicField6(_ConversationDraftManager, "instance", null);
var ConversationDraftManager = _ConversationDraftManager;
var DraftManager = ConversationDraftManager.getInstance();

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-editor.vue2.mjs
var _hoisted_140 = {
  key: 0,
  class: "message-input-mute"
};
var _hoisted_227 = ["contenteditable"];
var _sfc_main45 = defineComponent45({
  __name: "message-input-editor",
  props: {
    placeholder: {
      type: String,
      default: "this is placeholder"
    },
    replayOrReferenceMessage: {
      type: Object,
      default: () => ({})
    },
    isMuted: {
      type: Boolean,
      default: true
    },
    muteText: {
      type: String,
      default: ""
    },
    enableInput: {
      type: Boolean,
      default: true
    },
    enableAt: {
      type: Boolean,
      default: true
    },
    enableDragUpload: {
      type: Boolean,
      default: true
    },
    enableTyping: {
      type: Boolean,
      default: true
    }
  },
  emits: ["sendMessage", "onTyping", "onAt"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { placeholder, enableAt, enableDragUpload, enableTyping } = toRefs4(props);
    const isEditorEmpty = ref32(true);
    const isEditorBlur = ref32(true);
    const isC2C = ref32(false);
    const currentConversationID2 = ref32("");
    const currentQuoteMessage = ref32();
    const editorDom = ref32();
    let editor = null;
    const fileMap = /* @__PURE__ */ new Map();
    const DisableDefaultEnter = Extension.create({
      addKeyboardShortcuts() {
        return {
          Enter: () => true
        };
      }
    });
    function onCurrentConversationIDUpdated(conversationID) {
      if (currentConversationID2.value !== conversationID) {
        if (currentConversationID2.value) {
          DraftManager.setStore(
            currentConversationID2.value,
            getEditorHTML(),
            DraftManager.generateAbstract(getEditorContent()),
            currentQuoteMessage.value
          );
        }
        resetEditor();
        if (conversationID) {
          DraftManager.getStore(conversationID, setEditorContent);
        }
      }
      currentConversationID2.value = conversationID;
    }
    function onQuoteMessageUpdated(options) {
      currentQuoteMessage.value = options;
    }
    onMounted17(() => {
      editor = isPC ? new Editor({
        element: editorDom.value,
        extensions: [
          Document,
          Paragraph,
          Text,
          DisableDefaultEnter,
          Placeholder.configure({
            emptyEditorClass: "is-editor-empty",
            placeholder: placeholder.value
          }),
          Mention.configure({
            HTMLAttributes: {
              class: "mention"
            },
            suggestion: enableAt.value && MessageInputAtSuggestion()
          }),
          CustomImage.configure({
            inline: true,
            allowBase64: true
          })
        ],
        autofocus: !isH5,
        editable: true,
        injectCSS: false,
        editorProps: {
          transformPastedText() {
            return "";
          }
        },
        // handle input editor typing (only in C2C and enable typing)
        onUpdate({ editor: editor2, transaction }) {
          var _a3, _b3;
          if (!enableTyping.value || !isC2C.value)
            return;
          isEditorBlur.value = !editor2.isFocused;
          if (((_b3 = (_a3 = transaction == null ? void 0 : transaction.doc) == null ? void 0 : _a3.content) == null ? void 0 : _b3.size) > 2) {
            isEditorEmpty.value = false;
          } else {
            isEditorEmpty.value = true;
          }
        },
        onFocus() {
          var _a3;
          if (isH5 && ((_a3 = document == null ? void 0 : document.getElementById("app")) == null ? void 0 : _a3.style)) {
            const keyboardHeight = document.body.scrollHeight - window.innerHeight;
            document.getElementById("app").style.marginBottom = `${keyboardHeight}px`;
            document.getElementById("app").style.height = `calc(100% - ${keyboardHeight}px)`;
          }
          if (!enableTyping.value || !isC2C.value)
            return;
          isEditorBlur.value = true;
        },
        onBlur() {
          var _a3;
          if (isH5 && ((_a3 = document == null ? void 0 : document.getElementById("app")) == null ? void 0 : _a3.style)) {
            document.getElementById("app").style.marginBottom = ``;
            document.getElementById("app").style.height = `100%`;
          }
          if (!enableTyping.value || !isC2C.value)
            return;
          isEditorBlur.value = true;
        }
      }) : null;
      if (isH5) {
        const targetBottomDom = document.querySelector(".message-input-toolbar") || editorDom.value;
        riseInput(editorDom.value, targetBottomDom);
      }
      Jt.watch(o.CONV, {
        currentConversationID: onCurrentConversationIDUpdated
      });
      Jt.watch(o.CHAT, {
        quoteMessage: onQuoteMessageUpdated
      });
    });
    onUnmounted12(() => {
      Jt.unwatch(o.CONV, {
        currentConversationID: onCurrentConversationIDUpdated
      });
      Jt.unwatch(o.CHAT, {
        quoteMessage: onQuoteMessageUpdated
      });
      fileMap.clear();
    });
    function handleEnter(e) {
      var _a3;
      if (isH5) {
        return;
      }
      e == null ? void 0 : e.preventDefault();
      e == null ? void 0 : e.stopPropagation();
      if (e.keyCode === 13 && e.ctrlKey) {
        (_a3 = editor == null ? void 0 : editor.commands) == null ? void 0 : _a3.insertContent("<p></p>");
      } else if (e.keyCode === 13) {
        emits("sendMessage");
      }
    }
    function handleH5Input(e) {
      var _a3;
      if (isH5) {
        e.data === "@" && emits("onAt", true);
        isEditorEmpty.value = ((_a3 = editorDom.value) == null ? void 0 : _a3.childNodes) ? false : true;
      }
    }
    function handleH5Blur() {
      isH5 && (isEditorBlur.value = true);
    }
    function handleH5Focus() {
      isH5 && (isEditorBlur.value = false);
    }
    function insertAt(atInfo) {
      var _a3;
      const mentionText = document.createElement("span");
      mentionText.innerHTML = atInfo.label;
      mentionText.className = "mention";
      mentionText.id = atInfo.id;
      (_a3 = editorDom.value) == null ? void 0 : _a3.appendChild(mentionText);
    }
    function handlePCFileDrop(e) {
      isPC && handleFileDropOrPaste(e, "drop");
    }
    function handlePaste(e) {
      if (!e.clipboardData) {
        return;
      }
      if (isPC && e.clipboardData.files.length) {
        handleFileDropOrPaste(e, "paste");
      } else {
        handlePasteText(e);
        scrollToCaret(editorDom.value);
      }
    }
    function handlePasteText(e) {
      var _a3, _b3;
      e.preventDefault();
      const html = (_a3 = e.clipboardData) == null ? void 0 : _a3.getData("text/html");
      const text = ((_b3 = e.clipboardData) == null ? void 0 : _b3.getData("text/plain")) || "";
      if (!html) {
        const renderArray = parseTextToRenderArray(text);
        insertEditorContent(renderArray);
      }
    }
    async function handleFileDropOrPaste(e, type) {
      var _a3, _b3, _c2;
      e.preventDefault();
      e.stopPropagation();
      if (!enableDragUpload.value && type === "drop") {
        return;
      }
      if (type === "drop" && e.dataTransfer || type === "paste" && e.clipboardData) {
        const files = type === "drop" ? (_a3 = e == null ? void 0 : e.dataTransfer) == null ? void 0 : _a3.files : (_b3 = e == null ? void 0 : e.clipboardData) == null ? void 0 : _b3.files;
        for (let i2 = 0; i2 < files.length; i2++) {
          const file = files[i2];
          const isImage = file.type.startsWith("image/");
          const fileSrc = isImage ? URL.createObjectURL(file) : await drawFileCanvasToImageUrl(file);
          (_c2 = editor == null ? void 0 : editor.commands) == null ? void 0 : _c2.insertContent({
            type: "custom-image",
            attrs: {
              src: fileSrc,
              alt: file == null ? void 0 : file.name,
              class: isImage ? "normal" : "file"
            }
          });
          fileMap.set(fileSrc, file);
          if (i2 === files.length - 1) {
            setTimeout(() => {
              var _a22, _b22;
              (_a22 = editor == null ? void 0 : editor.commands) == null ? void 0 : _a22.focus("end");
              (_b22 = editor == null ? void 0 : editor.commands) == null ? void 0 : _b22.scrollIntoView();
            }, 10);
          }
        }
      }
    }
    const fileIconDomMap = /* @__PURE__ */ new Map();
    const addImageProcess = (src, type) => {
      return new Promise((resolve, reject) => {
        if (fileIconDomMap.has(type)) {
          resolve(fileIconDomMap.get(type));
        } else {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.onload = () => {
            fileIconDomMap.set(type, img);
            resolve(img);
          };
          img.onerror = reject;
          img.src = src;
        }
      });
    };
    const drawFileCanvasToImageUrl = async (file) => {
      const { name, type } = file;
      const canvas = document.createElement("canvas");
      const width = 160;
      const height = 50;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      const scale = window.devicePixelRatio;
      canvas.width = Math.floor(width * scale);
      canvas.height = Math.floor(height * scale);
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return "";
      }
      ctx.scale(scale, scale);
      const { iconSrc, iconType } = handleFileIconForShow(type);
      const img = await addImageProcess(iconSrc, iconType);
      ctx == null ? void 0 : ctx.drawImage(img, 10, 10, 30, 30);
      const nameForShow = handleNameForShow(name);
      ctx.fillText(nameForShow, 45, 22);
      const dataURL = canvas.toDataURL();
      return dataURL;
    };
    const handleFileIconForShow = (type) => {
      const urlBase = "https://web.sdk.qcloud.com/component/TUIKit/assets/file-";
      const fileTypes = [
        "image",
        "pdf",
        "text",
        "ppt",
        "presentation",
        "sheet",
        "zip",
        "word",
        "video",
        "unknown"
      ];
      let url = "";
      let iconType = "";
      fileTypes.forEach((typeName) => {
        if (type.includes(typeName)) {
          url = urlBase + typeName + ".svg";
          iconType = typeName;
        }
      });
      return {
        iconSrc: url ? url : urlBase + "unknown.svg",
        iconType: iconType ? iconType : "unknown"
      };
    };
    const handleNameForShow = (value) => {
      if (!value) {
        return value;
      }
      let res = "";
      let length = 0;
      for (let i2 = 0; i2 < (value == null ? void 0 : value.length); i2++) {
        if (length > 16) {
          res += "...";
          break;
        }
        res += value[i2];
        if (/[a-z]|[0-9]|[,;.!@#-+/\\$%^*()<>?:"'{}~]/i.test(value[i2])) {
          length += 1;
        } else {
          length += 2;
        }
      }
      return res;
    };
    function getEditorContent() {
      return isPC ? parsePCEditorContent() : parseH5EditorContent();
    }
    function parsePCEditorContent() {
      var _a3, _b3;
      const editorJSON = editor == null ? void 0 : editor.getJSON();
      const content = [];
      handleEditorContent(editorJSON, content);
      if (content.length > 0 && content[content.length - 1] && content[content.length - 1].type === "text" && ((_b3 = (_a3 = content[content.length - 1].payload) == null ? void 0 : _a3.text) == null ? void 0 : _b3.endsWith("\n"))) {
        const text = content[content.length - 1].payload.text || "";
        content[content.length - 1].payload.text = text == null ? void 0 : text.substring(
          0,
          text.lastIndexOf("\n")
        );
      }
      return content;
    }
    function handleEditorContent(root, content) {
      var _a3;
      if (!root || !root.type) {
        return;
      }
      if (root.type !== "text" && root.type !== "custom-image" && root.type !== "mention") {
        if (root.type === "paragraph") {
          handleEditorNode(root, content);
        }
        if ((_a3 = root.content) == null ? void 0 : _a3.length) {
          root.content.forEach((item) => {
            handleEditorContent(item, content);
          });
        }
        return;
      } else {
        handleEditorNode(root, content);
      }
    }
    function handleEditorNode(node, content) {
      var _a3, _b3, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
      if (node.type === "paragraph") {
        if (content.length > 0 && content[content.length - 1] && ((_a3 = content[content.length - 1]) == null ? void 0 : _a3.type) === "text") {
          content[content.length - 1].payload.text += "\n";
        }
      } else if (node.type === "text" || node.type === "custom-image" && ((_c2 = (_b3 = node == null ? void 0 : node.attrs) == null ? void 0 : _b3.class) == null ? void 0 : _c2.includes("emoji"))) {
        const text = node.type === "text" ? node == null ? void 0 : node.text : (_d2 = node == null ? void 0 : node.attrs) == null ? void 0 : _d2.alt;
        if (content.length > 0 && content[content.length - 1] && ((_e2 = content[content.length - 1]) == null ? void 0 : _e2.type) === "text") {
          content[content.length - 1].payload.text += text;
        } else {
          content.push({
            type: "text",
            payload: { text }
          });
        }
      } else if (node.type === "custom-image" && ((_g = (_f2 = node == null ? void 0 : node.attrs) == null ? void 0 : _f2.class) == null ? void 0 : _g.includes("normal"))) {
        content.push({
          type: "image",
          payload: { file: fileMap == null ? void 0 : fileMap.get((_h = node == null ? void 0 : node.attrs) == null ? void 0 : _h.src) }
        });
      } else if (node.type === "custom-image" && ((_j = (_i = node == null ? void 0 : node.attrs) == null ? void 0 : _i.class) == null ? void 0 : _j.includes("file"))) {
        const file = fileMap == null ? void 0 : fileMap.get((_k = node == null ? void 0 : node.attrs) == null ? void 0 : _k.src);
        content.push({
          type: ((_l = file == null ? void 0 : file.type) == null ? void 0 : _l.includes("video")) ? "video" : "file",
          payload: { file }
        });
      } else if (node.type === "mention") {
        const text = "@" + ((_m = node == null ? void 0 : node.attrs) == null ? void 0 : _m.label) + " ";
        if (content.length > 0 && content[content.length - 1] && ((_n = content[content.length - 1]) == null ? void 0 : _n.type) === "text") {
          content[content.length - 1].payload.text += text;
        } else {
          content.push({
            type: "text",
            payload: { text }
          });
        }
        if ((_p = (_o = content[content.length - 1]) == null ? void 0 : _o.payload) == null ? void 0 : _p.atUserList) {
          (_t = (_r = (_q = content[content.length - 1]) == null ? void 0 : _q.payload) == null ? void 0 : _r.atUserList) == null ? void 0 : _t.push((_s = node == null ? void 0 : node.attrs) == null ? void 0 : _s.id);
        } else {
          content[content.length - 1].payload.atUserList = [(_u = node == null ? void 0 : node.attrs) == null ? void 0 : _u.id];
        }
      }
    }
    function parseH5EditorContent() {
      var _a3, _b3, _c2;
      const root = editorDom.value;
      let text = "";
      const atUserList = [];
      try {
        for (const child of root.childNodes) {
          if (child.nodeName === "#text" || child.nodeName === "SPAN" || ((_a3 = child.classList) == null ? void 0 : _a3.contains("custom-image-emoji")) || ((_b3 = child.classList) == null ? void 0 : _b3.contains("mention"))) {
            text += child.nodeValue || child.alt || child.innerHTML || "";
            if (((_c2 = child.classList) == null ? void 0 : _c2.contains("mention")) && child.id && !(atUserList == null ? void 0 : atUserList.includes(child.id))) {
              atUserList.push(child.id);
            }
          }
        }
      } catch (error) {
        if (error instanceof Error) {
          throw error;
        }
      }
      return [
        {
          type: "text",
          payload: {
            text,
            atUserList
          }
        }
      ];
    }
    function addEmoji(emojiData) {
      var _a3, _b3, _c2, _d2, _e2;
      if (isPC) {
        (_a3 = editor == null ? void 0 : editor.commands) == null ? void 0 : _a3.insertContent({
          type: "custom-image",
          attrs: {
            src: emojiData == null ? void 0 : emojiData.url,
            alt: emojiData == null ? void 0 : emojiData.emoji.key,
            title: emojiData == null ? void 0 : emojiData.emoji.key,
            class: "emoji"
          }
        });
      } else {
        const emojiImgNode = document.createElement("img");
        emojiImgNode == null ? void 0 : emojiImgNode.setAttribute("src", emojiData == null ? void 0 : emojiData.url);
        emojiImgNode == null ? void 0 : emojiImgNode.setAttribute("class", "custom-image custom-image-emoji");
        emojiImgNode == null ? void 0 : emojiImgNode.setAttribute("alt", emojiData == null ? void 0 : emojiData.emoji.key);
        emojiImgNode == null ? void 0 : emojiImgNode.setAttribute("title", emojiData == null ? void 0 : emojiData.emoji.key);
        emojiImgNode == null ? void 0 : emojiImgNode.setAttribute("width", "20px");
        emojiImgNode == null ? void 0 : emojiImgNode.setAttribute("height", "20px");
        (_b3 = editorDom.value) == null ? void 0 : _b3.appendChild(emojiImgNode);
        const spanNode = document.createElement("span");
        spanNode.contentEditable = "true";
        (_c2 = editorDom.value) == null ? void 0 : _c2.appendChild(spanNode);
      }
      if (!isH5) {
        (_d2 = editor == null ? void 0 : editor.commands) == null ? void 0 : _d2.focus();
        (_e2 = editor == null ? void 0 : editor.commands) == null ? void 0 : _e2.scrollIntoView();
      }
    }
    function blur2() {
      var _a3, _b3;
      isPC ? (_a3 = editor == null ? void 0 : editor.commands) == null ? void 0 : _a3.blur() : (_b3 = editorDom.value) == null ? void 0 : _b3.blur();
    }
    function resetEditor() {
      var _a3;
      (_a3 = editor == null ? void 0 : editor.commands) == null ? void 0 : _a3.clearContent(true);
      isEditorBlur.value = true;
      isEditorEmpty.value = true;
      isH5 && (editorDom.value.innerHTML = "");
    }
    function getEditorHTML() {
      if (isPC) {
        return editor == null ? void 0 : editor.getHTML();
      }
      return editorDom.value.innerHTML;
    }
    function setEditorContent(content) {
      var _a3;
      if (isPC) {
        (_a3 = editor == null ? void 0 : editor.commands) == null ? void 0 : _a3.setContent(content);
      } else {
        editorDom.value.innerHTML = content;
      }
    }
    function insertEditorContent(content) {
      const selection = window.getSelection();
      if (selection && selection.rangeCount) {
        const currentRange = selection.getRangeAt(0);
        content.forEach((item) => {
          const newNode = item.type === "image" ? createEmojiNode(item.emojiKey || "", item.content) : createTextNode(item.content);
          currentRange.insertNode(newNode);
          currentRange.setStartAfter(newNode);
          if (item.type === "image" && isH5) {
            const textNode = document.createElement("span");
            textNode.contentEditable = "true";
            currentRange.insertNode(textNode);
            currentRange.setStartAfter(textNode);
          }
        });
        currentRange.collapse(false);
        selection.removeAllRanges();
        selection.addRange(currentRange);
      }
    }
    function createTextNode(text) {
      return document.createTextNode(text);
    }
    function createEmojiNode(key, url) {
      const imgNode = document.createElement("img");
      imgNode.src = url;
      imgNode.alt = key || "";
      imgNode.classList.add("custom-image", "custom-image-emoji");
      imgNode.width = 20;
      imgNode.height = 20;
      return imgNode;
    }
    function scrollToCaret(el) {
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        const newRange = document.createRange();
        const emptyPlaceholder = "​";
        const textNode = document.createTextNode(emptyPlaceholder);
        newRange.setStart(range.startContainer, range.startOffset);
        newRange.insertNode(textNode);
        const rect = newRange.getBoundingClientRect();
        if (textNode.parentNode) {
          textNode.parentNode.removeChild(textNode);
        }
        el.scrollTop = rect.top - el.getBoundingClientRect().top;
      }
    }
    watch15(
      () => [isEditorEmpty.value, isEditorBlur.value],
      (newVal, oldVal) => {
        if (newVal !== oldVal) {
          emits("onTyping", isEditorEmpty.value, isEditorBlur.value);
        }
      },
      {
        immediate: true,
        deep: true
      }
    );
    __expose({
      getEditorContent,
      addEmoji,
      resetEditor,
      insertAt,
      setEditorContent,
      getEditorHTML,
      insertEditorContent,
      blur: blur2
    });
    return (_ctx, _cache) => {
      return openBlock44(), createElementBlock43("div", {
        class: normalizeClass29(["message-input-editor-container", unref43(isH5) && "message-input-editor-container-h5"])
      }, [
        __props.isMuted ? (openBlock44(), createElementBlock43("div", _hoisted_140, toDisplayString31(__props.muteText), 1)) : createCommentVNode30("", true),
        !__props.isMuted && __props.enableInput ? (openBlock44(), createElementBlock43("div", {
          key: 1,
          ref_key: "editorDom",
          ref: editorDom,
          class: "message-input-editor-area",
          contenteditable: unref43(isH5),
          onKeydown: withKeys(handleEnter, ["enter"]),
          onDrop: handlePCFileDrop,
          onPaste: handlePaste,
          onInput: handleH5Input,
          onBlur: handleH5Blur,
          onFocus: handleH5Focus
        }, null, 40, _hoisted_227)) : createCommentVNode30("", true)
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-editor.vue.mjs
var MessageInputEditor = _export_sfc(_sfc_main45, [["__scopeId", "data-v-704cb70e"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-at/index.vue2.mjs
import { defineComponent as defineComponent47, ref as ref34, watch as watch17, createBlock as createBlock10, openBlock as openBlock46, unref as unref45, withCtx as withCtx10, createElementVNode as createElementVNode32, normalizeClass as normalizeClass31, createElementBlock as createElementBlock45, createCommentVNode as createCommentVNode32, toDisplayString as toDisplayString33, Fragment as Fragment15, renderList as renderList12 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/BottomPopup/index.vue2.mjs
import { defineComponent as defineComponent46, ref as ref33, watch as watch16, nextTick as nextTick6, createElementBlock as createElementBlock44, createCommentVNode as createCommentVNode31, openBlock as openBlock45, renderSlot as renderSlot10, unref as unref44, normalizeClass as normalizeClass30, createElementVNode as createElementVNode31, withModifiers as withModifiers11, normalizeStyle as normalizeStyle11, toDisplayString as toDisplayString32 } from "vue";
var _hoisted_141 = { key: 0 };
var _hoisted_228 = {
  key: 0,
  class: "header"
};
var _hoisted_315 = {
  key: 0,
  class: "header-title"
};
var _hoisted_411 = {
  key: 1,
  class: "footer"
};
var _sfc_main46 = defineComponent46({
  __name: "index",
  props: {
    // Whether to display the bottom pop-up dialog box
    show: {
      type: Boolean,
      default: false
    },
    // Whether a mask layer is required, the default is true
    modal: {
      type: Boolean,
      default: true
    },
    // Popup box content area height (excluding mask), default is fit-content
    height: {
      type: String,
      default: "fit-content"
    },
    // Whether the pop-up dialog box can be closed by clicking outside, the default is true
    // uniapp only supports closing the pop-up dialog box by clicking the mask
    closeByClickOutside: {
      type: Boolean,
      default: true
    },
    // The rounded angle of the top border corners is 0px by default, i.e. right angle by default
    borderRadius: {
      type: String,
      default: "0px"
    },
    title: {
      type: String,
      default: ""
    },
    // Whether to display the top close button, not displayed by default
    showHeaderCloseButton: {
      type: Boolean,
      default: false
    },
    // Whether to display the submit button at the bottom, not displayed by default
    showFooterSubmitButton: {
      type: Boolean,
      default: false
    },
    // Bottom submit button text, only valid when showFooterSubmitButton is true
    submitButtonContent: {
      type: String,
      default: () => Wt.t("确定")
    }
  },
  emits: ["onOpen", "onClose", "onSubmit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const dialogRef = ref33();
    watch16(
      () => props.show,
      (newVal, oldVal) => {
        if (newVal === oldVal) {
          return;
        }
        switch (newVal) {
          case true:
            emits("onOpen", dialogRef);
            nextTick6(() => {
              if (isH5 && !isUniFrameWork) {
                if (props.closeByClickOutside) {
                  O.listen({
                    domRefs: dialogRef.value,
                    handler: closeBottomPopup
                  });
                }
              }
            });
            break;
          case false:
            emits("onClose", dialogRef);
            break;
        }
      }
    );
    const closeBottomPopup = () => {
      if (isUniFrameWork || isH5) {
        emits("onClose", dialogRef);
      }
    };
    const submit = () => {
      emits("onSubmit");
      closeBottomPopup();
    };
    return (_ctx, _cache) => {
      return props.show ? (openBlock45(), createElementBlock44("div", _hoisted_141, [
        !unref44(isPC) ? (openBlock45(), createElementBlock44("div", {
          key: 0,
          class: normalizeClass30([
            "bottom-popup",
            !unref44(isPC) && "bottom-popup-h5",
            !unref44(isPC) && props.modal && "bottom-popup-modal",
            unref44(isUniFrameWork) && "bottom-popup-uni"
          ]),
          onClick: closeBottomPopup
        }, [
          createElementVNode31("div", {
            ref_key: "dialogRef",
            ref: dialogRef,
            class: normalizeClass30(["bottom-popup-main", !unref44(isPC) && "bottom-popup-h5-main"]),
            style: normalizeStyle11({
              height: props.height,
              borderTopLeftRadius: props.borderRadius,
              borderTopRightRadius: props.borderRadius
            }),
            onClick: _cache[0] || (_cache[0] = withModifiers11(() => {
            }, ["stop"]))
          }, [
            __props.title || __props.showHeaderCloseButton ? (openBlock45(), createElementBlock44("div", _hoisted_228, [
              __props.title ? (openBlock45(), createElementBlock44("div", _hoisted_315, toDisplayString32(__props.title), 1)) : createCommentVNode31("", true),
              __props.showHeaderCloseButton ? (openBlock45(), createElementBlock44("div", {
                key: 1,
                class: "header-close",
                onClick: closeBottomPopup
              }, toDisplayString32(unref44(Wt).t("关闭")), 1)) : createCommentVNode31("", true)
            ])) : createCommentVNode31("", true),
            renderSlot10(_ctx.$slots, "default", {}, void 0, true),
            __props.showFooterSubmitButton ? (openBlock45(), createElementBlock44("div", _hoisted_411, [
              createElementVNode31("div", {
                class: "footer-submit",
                onClick: submit
              }, toDisplayString32(__props.submitButtonContent), 1)
            ])) : createCommentVNode31("", true)
          ], 6)
        ], 2)) : renderSlot10(_ctx.$slots, "default", { key: 1 }, void 0, true)
      ])) : createCommentVNode31("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/BottomPopup/index.vue.mjs
var BottomPopup = _export_sfc(_sfc_main46, [["__scopeId", "data-v-bd66b7e1"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-at/index.vue2.mjs
var _hoisted_143 = {
  ref: "dialog",
  class: "member-list"
};
var _hoisted_229 = {
  key: 0,
  class: "member-list-title"
};
var _hoisted_316 = { class: "title" };
var _hoisted_412 = { class: "member-list-box" };
var _hoisted_59 = ["onClick"];
var _hoisted_67 = ["src"];
var _hoisted_75 = { class: "member-list-box-body-name" };
var _sfc_main47 = defineComponent47({
  __name: "index",
  emits: ["onAtListOpen", "insertAt"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const emits = __emit;
    const MessageInputAt2 = ref34();
    const memberListItems = ref34();
    const showAtList = ref34(false);
    const memberList2 = ref34();
    const allMemberList2 = ref34();
    const showMemberList2 = ref34();
    const isGroup2 = ref34(false);
    const position = ref34({
      left: 0,
      top: 0
    });
    const selectedIndex2 = ref34(0);
    const currentConversationID2 = ref34("");
    const all2 = {
      userID: qt.TYPES.MSG_AT_ALL,
      nick: "所有人",
      isAll: true,
      avatar: "https://web.sdk.qcloud.com/im/assets/images/at.svg"
    };
    Jt.watch(o.CONV, {
      currentConversationID: (id) => {
        var _a3, _b3;
        if (id !== currentConversationID2.value) {
          currentConversationID2.value = id;
          memberList2.value = [];
          allMemberList2.value = [];
          showMemberList2.value = [];
          isGroup2.value = false;
          Jt.update(o.CUSTOM, "memberList", memberList2.value);
          if ((_a3 = currentConversationID2 == null ? void 0 : currentConversationID2.value) == null ? void 0 : _a3.startsWith("GROUP")) {
            isGroup2.value = true;
            const groupID = (_b3 = currentConversationID2 == null ? void 0 : currentConversationID2.value) == null ? void 0 : _b3.substring(5);
            es.switchGroup(groupID);
          } else {
            es.switchGroup("");
          }
        }
      }
    });
    Jt.watch(o.GRP, {
      currentGroupMemberList: (list) => {
        memberList2.value = list;
        allMemberList2.value = [all2, ...memberList2.value];
        showMemberList2.value = allMemberList2.value;
        Jt.update(o.CUSTOM, "memberList", memberList2.value);
      }
    });
    const toggleAtList = (show) => {
      if (!isGroup2.value) {
        return;
      }
      showAtList.value = show;
      if (showAtList.value) {
        emits("onAtListOpen");
      }
    };
    const handleAtListPosition = (positionData) => {
      position.value = positionData;
    };
    const setCurrentSelectIndex = (index3) => {
      var _a3, _b3;
      selectedIndex2.value = index3;
      (_b3 = (_a3 = memberListItems.value) == null ? void 0 : _a3[selectedIndex2.value]) == null ? void 0 : _b3.scrollIntoView(false);
    };
    const setShowMemberList = (list) => {
      showMemberList2.value = list;
    };
    i.toggleAtList = toggleAtList;
    i.handleAtListPosition = handleAtListPosition;
    i.setCurrentSelectIndex = setCurrentSelectIndex;
    i.setShowMemberList = setShowMemberList;
    __expose({
      toggleAtList
    });
    watch17(
      () => [position.value, MessageInputAt2 == null ? void 0 : MessageInputAt2.value],
      () => {
        var _a3;
        if (isH5 || !(MessageInputAt2 == null ? void 0 : MessageInputAt2.value) || !((_a3 = MessageInputAt2 == null ? void 0 : MessageInputAt2.value) == null ? void 0 : _a3.style)) {
          return;
        }
        MessageInputAt2.value.style.left = position.value.left + "px";
        MessageInputAt2.value.style.top = position.value.top - MessageInputAt2.value.clientHeight + "px";
      }
    );
    const closeAt = () => {
      showAtList.value = false;
      showMemberList2.value = allMemberList2.value;
      position.value = {
        left: 0,
        top: 0
      };
    };
    const selectItem2 = (index3) => {
      var _a3;
      if (isPC && i.selectItem) {
        i.selectItem(index3);
      } else {
        if ((_a3 = showMemberList2 == null ? void 0 : showMemberList2.value) == null ? void 0 : _a3.length) {
          const item = showMemberList2 == null ? void 0 : showMemberList2.value[index3];
          emits("insertAt", {
            id: item == null ? void 0 : item.userID,
            label: (item == null ? void 0 : item.nick) || (item == null ? void 0 : item.userID)
          });
        }
      }
      closeAt();
    };
    const handleMemberAvatar = (item) => {
      return (item == null ? void 0 : item.avatar) || "https://web.sdk.qcloud.com/component/TUIKit/assets/avatar_21.png";
    };
    const handleMemberName = (item) => {
      return (item == null ? void 0 : item.nick) ? item == null ? void 0 : item.nick : item == null ? void 0 : item.userID;
    };
    return (_ctx, _cache) => {
      return openBlock46(), createBlock10(BottomPopup, {
        show: unref45(showAtList),
        onOnClose: closeAt
      }, {
        default: withCtx10(() => [
          createElementVNode32("div", {
            ref_key: "MessageInputAt",
            ref: MessageInputAt2,
            class: normalizeClass31([unref45(isPC) ? "message-input-at" : "message-input-at-h5"])
          }, [
            createElementVNode32("div", _hoisted_143, [
              !unref45(isPC) ? (openBlock46(), createElementBlock45("header", _hoisted_229, [
                createElementVNode32("span", _hoisted_316, toDisplayString33(unref45(Wt).t("TUIChat.选择提醒的人")), 1)
              ])) : createCommentVNode32("", true),
              createElementVNode32("ul", _hoisted_412, [
                (openBlock46(true), createElementBlock45(Fragment15, null, renderList12(unref45(showMemberList2), (item, index3) => {
                  return openBlock46(), createElementBlock45("li", {
                    key: index3,
                    ref_for: true,
                    ref_key: "memberListItems",
                    ref: memberListItems,
                    class: normalizeClass31(["member-list-box-body", [index3 === unref45(selectedIndex2) && "selected"]]),
                    onClick: ($event) => selectItem2(index3)
                  }, [
                    createElementVNode32("img", {
                      class: "member-list-box-body-avatar",
                      src: handleMemberAvatar(item)
                    }, null, 8, _hoisted_67),
                    createElementVNode32("span", _hoisted_75, toDisplayString33(handleMemberName(item)), 1)
                  ], 10, _hoisted_59);
                }), 128))
              ])
            ], 512)
          ], 2)
        ]),
        _: 1
      }, 8, ["show"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-at/index.vue.mjs
var MessageInputAt = _export_sfc(_sfc_main47, [["__scopeId", "data-v-15902586"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-button.vue2.mjs
import { defineComponent as defineComponent48, ref as ref35, createElementBlock as createElementBlock46, openBlock as openBlock47, normalizeClass as normalizeClass32, unref as unref46, createCommentVNode as createCommentVNode33, createTextVNode as createTextVNode2, toDisplayString as toDisplayString34 } from "vue";
var _hoisted_144 = {
  key: 0,
  class: "message-input-button-hover"
};
var _sfc_main48 = defineComponent48({
  __name: "message-input-button",
  props: {
    enableSend: {
      type: Boolean,
      default: true
    }
  },
  emits: ["sendMessage"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const displayHover = ref35(ChatConfig.getChatType() !== E.TUIChat.TYPE.ROOM);
    const emits = __emit;
    const sendMessage = () => {
      emits("sendMessage");
    };
    return (_ctx, _cache) => {
      return openBlock47(), createElementBlock46("div", {
        class: normalizeClass32(["message-input-button", !unref46(isPC) && "message-input-button-h5"])
      }, [
        props.enableSend ? (openBlock47(), createElementBlock46("button", {
          key: 0,
          class: "message-input-button-cont",
          "data-type": "text",
          disabled: false,
          onClick: sendMessage
        }, [
          unref46(displayHover) ? (openBlock47(), createElementBlock46("p", _hoisted_144, toDisplayString34(unref46(Wt).t("TUIChat.按Enter发送，Ctrl+Enter换行")), 1)) : createCommentVNode33("", true),
          createTextVNode2(" " + toDisplayString34(unref46(Wt).t("发送")), 1)
        ])) : createCommentVNode33("", true)
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-button.vue.mjs
var MessageInputButton = _export_sfc(_sfc_main48, [["__scopeId", "data-v-6684de24"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-quote/index.vue2.mjs
import { defineComponent as defineComponent49, ref as ref36, onMounted as onMounted18, onUnmounted as onUnmounted13, computed as computed17, createElementBlock as createElementBlock47, createCommentVNode as createCommentVNode34, unref as unref47, openBlock as openBlock48, normalizeClass as normalizeClass33, createElementVNode as createElementVNode33, createVNode as createVNode23, toDisplayString as toDisplayString35 } from "vue";
var _hoisted_145 = { class: "input-quote-content" };
var _hoisted_230 = { class: "max-one-line" };
var _sfc_main49 = defineComponent49({
  __name: "index",
  props: {
    displayType: { default: "editor" }
  },
  setup(__props) {
    const props = __props;
    const TYPES = qt.TYPES;
    const quoteMessage = ref36();
    onMounted18(() => {
      Jt.watch(o.CHAT, {
        quoteMessage: onQuoteMessageUpdated
      });
    });
    onUnmounted13(() => {
      Jt.unwatch(o.CHAT, {
        quoteMessage: onQuoteMessageUpdated
      });
    });
    const quoteContentText = computed17(() => {
      var _a3, _b3;
      let _quoteContentText;
      switch ((_a3 = quoteMessage.value) == null ? void 0 : _a3.type) {
        case TYPES.MSG_TEXT:
          _quoteContentText = transformTextWithKeysToEmojiNames((_b3 = quoteMessage.value.payload) == null ? void 0 : _b3.text);
          break;
        case TYPES.MSG_IMAGE:
          _quoteContentText = Wt.t("TUIChat.图片");
          break;
        case TYPES.MSG_AUDIO:
          _quoteContentText = Wt.t("TUIChat.语音");
          break;
        case TYPES.MSG_VIDEO:
          _quoteContentText = Wt.t("TUIChat.视频");
          break;
        case TYPES.MSG_FILE:
          _quoteContentText = Wt.t("TUIChat.文件");
          break;
        case TYPES.MSG_CUSTOM:
          _quoteContentText = Wt.t("TUIChat.自定义");
          break;
        case TYPES.MSG_FACE:
          _quoteContentText = Wt.t("TUIChat.表情");
          break;
        case TYPES.MSG_MERGER:
          _quoteContentText = Wt.t("TUIChat.聊天记录");
          break;
        default:
          _quoteContentText = Wt.t("TUIChat.消息");
          break;
      }
      return _quoteContentText;
    });
    function cancelQuote() {
      Jt.update(o.CHAT, "quoteMessage", { message: void 0, type: "quote" });
    }
    function onQuoteMessageUpdated(options) {
      if ((options == null ? void 0 : options.message) && (options == null ? void 0 : options.type) === "quote") {
        quoteMessage.value = options.message;
      } else {
        quoteMessage.value = void 0;
      }
    }
    return (_ctx, _cache) => {
      return Boolean(unref47(quoteMessage)) && props.displayType !== "audio" ? (openBlock48(), createElementBlock47("div", {
        key: 0,
        class: normalizeClass33({
          "input-quote-container": true,
          "input-quote-container-uni": unref47(isUniFrameWork),
          "input-quote-container-h5": unref47(isH5)
        })
      }, [
        createElementVNode33("div", _hoisted_145, [
          createElementVNode33("div", _hoisted_230, toDisplayString35(unref47(quoteMessage).nick || unref47(quoteMessage).from) + ": " + toDisplayString35(unref47(quoteContentText)), 1),
          createVNode23(Icon, {
            class: "input-quote-close-icon",
            file: unref47(closeIcon2),
            width: "11px",
            height: "11px",
            onOnClick: cancelQuote
          }, null, 8, ["file"])
        ])
      ], 2)) : createCommentVNode34("", true);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/message-input-quote/index.vue.mjs
var MessageInputQuote = _export_sfc(_sfc_main49, [["__scopeId", "data-v-0495652d"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/sendMessage.mjs
var sendMessageErrorCodeMap = /* @__PURE__ */ new Map([
  [3123, "文本包含本地审核拦截词"],
  [4004, "图片消息失败,无效的图片格式"],
  [4005, "文件消息失败,禁止发送违规封禁的文件"],
  [7004, "文件不存在,请检查文件路径是否正确"],
  [7005, "文件大小超出了限制,如果上传文件,最大限制是100MB"],
  [8001, "消息长度超出限制,消息长度不要超过12K"],
  [80001, "消息或者资料中文本存在敏感内容,发送失败"],
  [80004, "消息中图片存在敏感内容,发送失败"],
  [10017, "您已被禁止聊天"]
]);
var sendMessages = async (messageList, currentConversation) => {
  if (Jt.getData(o.CHAT, "messageSource")) {
    Jt.update(o.CHAT, "messageSource", void 0);
  }
  messageList == null ? void 0 : messageList.forEach(async (content) => {
    var _a3, _b3, _c2, _d2, _e2, _f2, _g;
    try {
      const options = {
        to: ((_a3 = currentConversation == null ? void 0 : currentConversation.groupProfile) == null ? void 0 : _a3.groupID) || ((_b3 = currentConversation == null ? void 0 : currentConversation.userProfile) == null ? void 0 : _b3.userID),
        conversationType: currentConversation == null ? void 0 : currentConversation.type,
        payload: {},
        needReadReceipt: isEnabledMessageReadReceiptGlobal()
      };
      let textMessageContent;
      const sendMessageOptions = {
        offlinePushInfo: {}
      };
      const offlinePushInfoCreateParams = {
        conversation: currentConversation,
        payload: content.payload,
        messageType: ""
      };
      switch (content == null ? void 0 : content.type) {
        case "text":
          textMessageContent = JSON.parse(JSON.stringify((_c2 = content.payload) == null ? void 0 : _c2.text));
          if (!textMessageContent) {
            break;
          }
          options.payload = {
            text: textMessageContent
          };
          offlinePushInfoCreateParams.messageType = qt.TYPES.MSG_TEXT;
          sendMessageOptions.offlinePushInfo = OfflinePushInfoManager2.create(offlinePushInfoCreateParams);
          if ((_d2 = content.payload) == null ? void 0 : _d2.atUserList) {
            options.payload.atUserList = content.payload.atUserList;
            await Qt.sendTextAtMessage(options, sendMessageOptions);
          } else {
            await Qt.sendTextMessage(options, sendMessageOptions);
          }
          break;
        case "image":
          options.payload = {
            file: (_e2 = content.payload) == null ? void 0 : _e2.file
          };
          offlinePushInfoCreateParams.messageType = qt.TYPES.MSG_IMAGE;
          sendMessageOptions.offlinePushInfo = OfflinePushInfoManager2.create(offlinePushInfoCreateParams);
          await Qt.sendImageMessage(options, sendMessageOptions);
          break;
        case "video":
          options.payload = {
            file: (_f2 = content.payload) == null ? void 0 : _f2.file
          };
          offlinePushInfoCreateParams.messageType = qt.TYPES.MSG_VIDEO;
          sendMessageOptions.offlinePushInfo = OfflinePushInfoManager2.create(offlinePushInfoCreateParams);
          await Qt.sendVideoMessage(options, sendMessageOptions);
          break;
        case "file":
          options.payload = {
            file: (_g = content.payload) == null ? void 0 : _g.file
          };
          offlinePushInfoCreateParams.messageType = qt.TYPES.MSG_FILE;
          sendMessageOptions.offlinePushInfo = OfflinePushInfoManager2.create(offlinePushInfoCreateParams);
          await Qt.sendFileMessage(options, sendMessageOptions);
          break;
        default:
          break;
      }
      enableSampleTaskStatus("sendMessage");
    } catch (error) {
      Toast({
        message: sendMessageErrorCodeMap.get(error == null ? void 0 : error.code) ? Wt.t(`TUIChat.${sendMessageErrorCodeMap.get(error.code)}`) : error == null ? void 0 : error.message,
        type: TOAST_TYPE.ERROR
      });
      if (Jt.getData(o.CHAT, "quoteMessage")) {
        Jt.update(o.CHAT, "quoteMessage", {});
      }
    }
  });
};
var sendTyping = (inputContentEmpty, inputBlur) => {
  if (!inputContentEmpty && !inputBlur) {
    Qt.enterTypingState();
  } else {
    Qt.leaveTypingState();
  }
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/index.vue2.mjs
var _hoisted_146 = { class: "message-input-wrapper" };
var _sfc_main50 = defineComponent50({
  __name: "index",
  props: {
    placeholder: {
      type: String,
      default: "this is placeholder"
    },
    isMuted: {
      type: Boolean,
      default: true
    },
    muteText: {
      type: String,
      default: ""
    },
    enableInput: {
      type: Boolean,
      default: true
    },
    enableAt: {
      type: Boolean,
      default: true
    },
    enableDragUpload: {
      type: Boolean,
      default: true
    },
    enableTyping: {
      type: Boolean,
      default: true
    }
  },
  emits: ["sendMessage", "resetReplyOrReference", "onTyping"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const editor = ref37();
    const messageInputAtRef = ref37();
    const currentConversation = ref37();
    Jt.watch(o.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const onTyping = (inputContentEmpty, inputBlur) => {
      sendTyping(inputContentEmpty, inputBlur);
    };
    const onAt = (show) => {
      var _a3;
      (_a3 = messageInputAtRef.value) == null ? void 0 : _a3.toggleAtList(show);
    };
    const sendMessage = async () => {
      var _a3, _b3;
      const _editorContentList = (_a3 = editor.value) == null ? void 0 : _a3.getEditorContent();
      if (!_editorContentList || !currentConversation.value)
        return;
      const editorContentList = _editorContentList.map((editor2) => {
        if (editor2.type === "text") {
          editor2.payload.text = transformTextWithEmojiNamesToKeys(editor2.payload.text);
        }
        return editor2;
      });
      await sendMessages(
        editorContentList,
        currentConversation.value
      );
      emit("sendMessage");
      (_b3 = editor.value) == null ? void 0 : _b3.resetEditor();
    };
    const insertEmoji = (emoji) => {
      var _a3;
      (_a3 = editor.value) == null ? void 0 : _a3.addEmoji(emoji);
    };
    const onAtListOpen = () => {
      var _a3;
      if (isH5) {
        (_a3 = editor.value) == null ? void 0 : _a3.blur();
      }
    };
    const insertAt = (atInfo) => {
      var _a3, _b3;
      ((_a3 = editor == null ? void 0 : editor.value) == null ? void 0 : _a3.insertAt) && ((_b3 = editor == null ? void 0 : editor.value) == null ? void 0 : _b3.insertAt(atInfo));
    };
    const reEdit = (content) => {
      var _a3, _b3;
      (_a3 = editor.value) == null ? void 0 : _a3.resetEditor();
      (_b3 = editor.value) == null ? void 0 : _b3.setEditorContent(content);
    };
    __expose({
      insertEmoji,
      reEdit
    });
    return (_ctx, _cache) => {
      return openBlock49(), createElementBlock48("div", _hoisted_146, [
        createElementVNode34("div", {
          class: normalizeClass34(["message-input-container", !unref48(isPC) && "message-input-container-h5"])
        }, [
          createVNode24(MessageInputEditor, {
            ref_key: "editor",
            ref: editor,
            placeholder: props.placeholder,
            isMuted: props.isMuted,
            muteText: props.muteText,
            enableInput: props.enableInput,
            enableAt: props.enableAt,
            enableTyping: props.enableTyping,
            enableDragUpload: props.enableDragUpload,
            onSendMessage: sendMessage,
            onOnTyping: onTyping,
            onOnAt: onAt
          }, null, 8, ["placeholder", "isMuted", "muteText", "enableInput", "enableAt", "enableTyping", "enableDragUpload"]),
          !props.isMuted ? (openBlock49(), createBlock11(MessageInputButton, {
            key: 0,
            onSendMessage: sendMessage
          })) : createCommentVNode35("", true),
          props.enableAt ? (openBlock49(), createBlock11(MessageInputAt, {
            key: 1,
            ref_key: "messageInputAtRef",
            ref: messageInputAtRef,
            onInsertAt: insertAt,
            onOnAtListOpen: onAtListOpen
          }, null, 512)) : createCommentVNode35("", true)
        ], 2),
        createVNode24(MessageInputQuote)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input/index.vue.mjs
var MessageInput = _export_sfc(_sfc_main50, [["__scopeId", "data-v-bf6a3af8"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/mulitple-select-panel/index.vue2.mjs
import { defineComponent as defineComponent51, ref as ref38, createElementBlock as createElementBlock49, openBlock as openBlock50, normalizeClass as normalizeClass35, unref as unref49, createElementVNode as createElementVNode35, createVNode as createVNode25, toDisplayString as toDisplayString36 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/forward-each.svg.mjs
var ForwardEachIcon = "data:image/svg+xml,%3csvg%20width='80'%20height='80'%20viewBox='0%200%2080%2080'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;'%3e%3ccircle%20id='&%23230;&%23164;&%23173;&%23229;&%23156;&%23134;&%23229;&%23189;&%23162;'%20cx='40'%20cy='40'%20r='38'%20stroke='%23444444'%20stroke-width='4'/%3e%3cpath%20id='&%23232;&%23183;&%23175;&%23229;&%23190;&%23132;'%20d='M22.0393%2054.5694C25.1584%2049.9724%2029.3723%2046.8567%2034.5689%2045.3912L34.5713%2045.3906C37.381%2044.6019%2039.8194%2044.5066%2041.2294%2044.5448L43.1752%2044.5974V46.544V53.6663L57.7786%2038.3558L43.2517%2023.0584V30.4668V32.3974L41.3223%2032.4655C34.455%2032.7081%2029.5325%2034.9563%2026.3318%2038.9079C25.0376%2040.5119%2024.0004%2042.4338%2023.2662%2044.6457L22.0393%2054.5694ZM22.0393%2054.5694C21.9839%2053.499%2021.9695%2052.0473%2022.1147%2050.3923C22.2993%2048.3257%2022.6869%2046.3923%2023.2661%2044.6461L22.0393%2054.5694Z'%20stroke='%23444444'%20stroke-width='4'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/forward-merge.svg.mjs
var ForwardMergeIcon = "data:image/svg+xml,%3csvg%20width='80'%20height='80'%20viewBox='0%200%2080%2080'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;'%3e%3cpath%20id='&%23232;&%23183;&%23175;&%23229;&%23190;&%23132;'%20d='M21.7586%2047.8445C24.2492%2044.3734%2027.5657%2042.0119%2031.6213%2040.8833L31.6233%2040.8827C33.8865%2040.2558%2035.8501%2040.18%2036.9868%2040.2104L38.6862%2040.2558V41.9558V47.2029L50.0059%2035.4911L38.7474%2023.7914V29.2632V30.9495L37.0622%2031.0082C31.5917%2031.1989%2027.6967%2032.965%2025.1719%2036.041C24.1502%2037.2907%2023.3303%2038.7892%2022.7494%2040.5163L21.7586%2047.8445ZM21.7586%2047.8445C21.733%2047.0661%2021.7407%2046.0942%2021.837%2045.0106C21.9836%2043.392%2022.291%2041.8801%2022.7493%2040.5166L21.7586%2047.8445Z'%20stroke='%23444444'%20stroke-width='3.49206'/%3e%3cpath%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M43.5636%2047.6924C43.5636%2047.1401%2044.0113%2046.6924%2044.5636%2046.6924H59C59.5522%2046.6924%2060%2047.1401%2060%2047.6924V49.7949C60%2050.3472%2059.5522%2050.7949%2059%2050.7949H44.5636C44.0113%2050.7949%2043.5636%2050.3472%2043.5636%2049.7949V47.6924Z'%20fill='%23444444'/%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;_2'%20x='20.1455'%20y='54.8975'%20width='39.8545'%20height='4.10256'%20rx='1'%20fill='%23444444'/%3e%3ccircle%20id='&%23230;&%23164;&%23173;&%23229;&%23156;&%23134;&%23229;&%23189;&%23162;'%20cx='40'%20cy='40'%20r='38'%20stroke='%23444444'%20stroke-width='4'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/add-circle.svg.mjs
var AddIcon = "data:image/svg+xml,%3csvg%20width='56'%20height='57'%20viewBox='0%200%2056%2057'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%204'%3e%3ccircle%20id='&%23230;&%23164;&%23173;&%23229;&%23156;&%23134;&%23229;&%23189;&%23162;&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%2027'%20cx='28'%20cy='28.8535'%20r='26'%20stroke='%23444444'%20stroke-width='4'/%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%208'%20x='15'%20y='27.8535'%20width='26'%20height='4'%20rx='1'%20fill='%23444444'/%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%208_2'%20x='26'%20y='42.8535'%20width='26'%20height='4'%20rx='1'%20transform='rotate(-90%2026%2042.8535)'%20fill='%23444444'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/mulitple-select-panel/index.vue2.mjs
var _sfc_main51 = defineComponent51({
  __name: "index",
  emits: ["oneByOneForwardMessage", "mergeForwardMessage", "toggleMultipleSelectMode"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const iconSize = ref38(isMobile ? "25px" : "30px");
    function oneByOneForwardMessage() {
      emits("oneByOneForwardMessage");
    }
    function mergeForwardMessage() {
      emits("mergeForwardMessage");
    }
    function cancelMultipleSelect() {
      emits("toggleMultipleSelectMode");
    }
    return (_ctx, _cache) => {
      return openBlock50(), createElementBlock49("div", {
        class: normalizeClass35({
          "mulitple-select-panel": true,
          "mulitple-select-panel-mobile": unref49(isMobile)
        })
      }, [
        createElementVNode35("div", {
          class: "forward-button",
          onClick: oneByOneForwardMessage
        }, [
          createVNode25(Icon, {
            file: unref49(ForwardEachIcon),
            size: unref49(iconSize)
          }, null, 8, ["file", "size"]),
          createElementVNode35("span", {
            class: normalizeClass35({
              "forward-button-text": true,
              "forward-button-text-mobile": unref49(isMobile)
            })
          }, toDisplayString36(unref49(Wt).t("TUIChat.逐条转发")), 3)
        ]),
        createElementVNode35("div", {
          class: "forward-button",
          onClick: mergeForwardMessage
        }, [
          createVNode25(Icon, {
            file: unref49(ForwardMergeIcon),
            size: unref49(iconSize)
          }, null, 8, ["file", "size"]),
          createElementVNode35("span", {
            class: normalizeClass35({
              "forward-button-text": true,
              "forward-button-text-mobile": unref49(isMobile)
            })
          }, toDisplayString36(unref49(Wt).t("TUIChat.合并转发")), 3)
        ]),
        createElementVNode35("div", {
          class: "forward-button",
          onClick: cancelMultipleSelect
        }, [
          createVNode25(Icon, {
            class: "cancel-button-icon",
            file: unref49(AddIcon),
            size: unref49(iconSize)
          }, null, 8, ["file", "size"]),
          createElementVNode35("span", {
            class: normalizeClass35({
              "forward-button-text": true,
              "forward-button-text-mobile": unref49(isMobile)
            })
          }, toDisplayString36(unref49(Wt).t("TUIChat.取消")), 3)
        ])
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/mulitple-select-panel/index.vue.mjs
var MultipleSelectPanel = _export_sfc(_sfc_main51, [["__scopeId", "data-v-d2fa341d"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/forward/index.vue.mjs
import { defineComponent as defineComponent53, ref as ref40, onMounted as onMounted19, onUnmounted as onUnmounted14, createBlock as createBlock13, openBlock as openBlock52, unref as unref51, withCtx as withCtx11, createVNode as createVNode27 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Transfer/index.vue2.mjs
import { defineComponent as defineComponent52, ref as ref39, watchEffect as watchEffect10, computed as computed18, createElementBlock as createElementBlock50, openBlock as openBlock51, normalizeClass as normalizeClass36, unref as unref50, createCommentVNode as createCommentVNode36, createElementVNode as createElementVNode36, createVNode as createVNode26, toDisplayString as toDisplayString37, withKeys as withKeys2, createBlock as createBlock12, Fragment as Fragment16, renderList as renderList13, renderSlot as renderSlot11 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/selected.svg.mjs
var selectedIcon = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='16px'%20height='16px'%20viewBox='0%200%2016%2016'%20version='1.1'%3e%3ctitle%3e编组%2014%3c/title%3e%3cdefs%3e%3cfilter%20x='-10.6%25'%20y='-5.4%25'%20width='121.2%25'%20height='110.9%25'%20filterUnits='objectBoundingBox'%20id='filter-1'%3e%3cfeOffset%20dx='0'%20dy='7'%20in='SourceAlpha'%20result='shadowOffsetOuter1'%3e%3c/feOffset%3e%3cfeGaussianBlur%20stdDeviation='10'%20in='shadowOffsetOuter1'%20result='shadowBlurOuter1'%3e%3c/feGaussianBlur%3e%3cfeColorMatrix%20values='0%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200%200.1%200'%20type='matrix'%20in='shadowBlurOuter1'%20result='shadowMatrixOuter1'%3e%3c/feColorMatrix%3e%3cfeMerge%3e%3cfeMergeNode%20in='shadowMatrixOuter1'%3e%3c/feMergeNode%3e%3cfeMergeNode%20in='SourceGraphic'%3e%3c/feMergeNode%3e%3c/feMerge%3e%3c/filter%3e%3c/defs%3e%3cg%20id='new'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='自定义消息'%20transform='translate(-458.000000,%20-318.000000)'%3e%3cg%20id='编组-32'%20filter='url(%23filter-1)'%20transform='translate(44.000000,%2060.000000)'%3e%3cg%20id='编组-24'%20transform='translate(30.000000,%20250.000000)'%3e%3cg%20id='编组-14'%20transform='translate(384.000000,%208.000000)'%3e%3ccircle%20id='椭圆形'%20fill='%23006EFF'%20fill-rule='nonzero'%20cx='8'%20cy='8'%20r='8'%3e%3c/circle%3e%3cpolyline%20id='路径-4'%20stroke='%23FFFFFF'%20stroke-width='2'%20transform='translate(8.042641,%206.242641)%20rotate(-315.000000)%20translate(-8.042641,%20-6.242641)%20'%20points='6.04264069%2010.2426407%2010.0426407%2010.2426407%2010.0426407%202.24264069'%3e%3c/polyline%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/cancel.svg.mjs
var cancelIcon = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='16px'%20height='16px'%20viewBox='0%200%2016%2016'%20version='1.1'%3e%3ctitle%3e清除%3c/title%3e%3cg%20id='页面-2备份'%20stroke='none'%20stroke-width='1'%20fill='none'%20fill-rule='evenodd'%3e%3cg%20id='创建群聊'%20transform='translate(-1243.000000,%20-413.000000)'%3e%3cg%20id='Group-1364'%20transform='translate(650.000000,%20343.000000)'%3e%3cg%20id='Group-1363'%20transform='translate(290.000000,%2046.000000)'%3e%3cg%20id='Group-1358'%20transform='translate(0.000000,%2024.000000)'%3e%3cg%20id='清除'%20transform='translate(303.000000,%200.000000)'%3e%3cpath%20d='M0,0%20L16,0%20L16,16%20L0,16%20L0,0%20Z'%20id='矩形'%3e%3c/path%3e%3cpath%20d='M1,8%20C1,11.8659999%204.13400006,15%208,15%20C11.8659999,15%2015,11.8659999%2015,8%20C15,4.13400006%2011.8659999,1%208,1%20L8,1%20C4.13400006,1%201,4.13400006%201,8%20Z'%20fill='%23999999'%3e%3c/path%3e%3cg%20id='编组'%20transform='translate(8.000000,%208.000000)%20rotate(-315.000000)%20translate(-8.000000,%20-8.000000)%20translate(4.000000,%204.000000)'%20fill='%23FFFFFF'%3e%3crect%20id='矩形备份'%20transform='translate(4.000000,%204.000000)%20rotate(-90.000000)%20translate(-4.000000,%20-4.000000)%20'%20x='1.8189894e-12'%20y='3.5'%20width='8'%20height='1'%20rx='0.5'%3e%3c/rect%3e%3crect%20id='矩形备份'%20transform='translate(4.000000,%204.000000)%20rotate(-360.000000)%20translate(-4.000000,%20-4.000000)%20'%20x='0'%20y='3.5'%20width='8'%20height='1'%20rx='0.5'%3e%3c/rect%3e%3c/g%3e%3crect%20id='矩形'%20x='0'%20y='0'%20width='16'%20height='16'%3e%3c/rect%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Transfer/index.vue2.mjs
var _hoisted_147 = {
  key: 0,
  class: "transfer-header transfer-h5-header"
};
var _hoisted_231 = { class: "title" };
var _hoisted_317 = { class: "main" };
var _hoisted_413 = { class: "left" };
var _hoisted_510 = { class: "transfer-header" };
var _hoisted_68 = ["value", "placeholder"];
var _hoisted_76 = ["placeholder", "value"];
var _hoisted_85 = { class: "transfer-left-main" };
var _hoisted_95 = { class: "transfer-list" };
var _hoisted_105 = {
  key: 1,
  class: "icon-unselected"
};
var _hoisted_1111 = { class: "select-all" };
var _hoisted_1211 = ["onClick"];
var _hoisted_1310 = ["src"];
var _hoisted_148 = { class: "name" };
var _hoisted_153 = { key: 0 };
var _hoisted_163 = { class: "right" };
var _hoisted_173 = {
  key: 0,
  class: "transfer-header"
};
var _hoisted_183 = {
  key: 1,
  class: "transfer-list"
};
var _hoisted_193 = {
  key: 0,
  class: "transfer-text"
};
var _hoisted_202 = { class: "transfer-list-item-content" };
var _hoisted_2110 = ["src"];
var _hoisted_2210 = {
  key: 0,
  class: "name"
};
var _hoisted_232 = ["onClick"];
var _hoisted_242 = { class: "transfer-right-footer" };
var _sfc_main52 = defineComponent52({
  __name: "index",
  props: {
    list: {
      type: Array,
      default: () => []
    },
    selectedList: {
      type: Array,
      default: () => []
    },
    isSearch: {
      type: Boolean,
      default: true
    },
    isRadio: {
      type: Boolean,
      default: false
    },
    isCustomItem: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: ""
    },
    resultShow: {
      type: Boolean,
      default: true
    },
    total: {
      type: Number,
      default: 0
    },
    isHiddenBackIcon: {
      type: Boolean,
      default: false
    }
  },
  emits: ["search", "submit", "cancel", "getMore"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const transferList = ref39([]);
    const transferTotal = ref39(0);
    const transferSelectedList = ref39([]);
    const isTransferSearch = ref39(true);
    const isTransferCustomItem = ref39(false);
    const transferTitle = ref39("");
    const searchValue = ref39("");
    watchEffect10(() => {
      if (props.isCustomItem) {
        for (let index3 = 0; index3 < props.list.length; index3++) {
          if (props.list[index3].conversationID.indexOf("@TIM#SYSTEM") > -1) {
            props.list.splice(index3, 1);
          }
          transferList.value = props.list;
        }
      } else {
        transferList.value = props.list;
      }
      transferTotal.value = props.total ? props.total : props.list.length;
      transferSelectedList.value = props.selectedList && props.selectedList.length > 0 ? props.selectedList : transferSelectedList.value;
      isTransferSearch.value = props.isSearch;
      isTransferCustomItem.value = props.isCustomItem;
      transferTitle.value = props.title;
    });
    const emit = __emit;
    const optional = computed18(
      () => transferList.value.filter((item) => !item.isDisabled)
    );
    const handleInput = (e) => {
      searchValue.value = e.target.value || e.detail.value;
      emit("search", searchValue.value);
    };
    const selected = (item) => {
      if (item.isDisabled) {
        return;
      }
      let list = transferSelectedList.value;
      const index3 = list.indexOf(item);
      if (index3 > -1) {
        return transferSelectedList.value.splice(index3, 1);
      }
      if (props.isRadio) {
        list = [];
      }
      list.push(item);
      transferSelectedList.value = list;
    };
    const selectedAll = () => {
      if (transferSelectedList.value.length === optional.value.length) {
        transferSelectedList.value = [];
      } else {
        transferSelectedList.value = [...optional.value];
      }
    };
    const submit = () => {
      emit("submit", transferSelectedList.value);
      searchValue.value = "";
    };
    const cancel = () => {
      emit("cancel");
      searchValue.value = "";
    };
    const getMore = () => {
      emit("getMore");
    };
    return (_ctx, _cache) => {
      return openBlock51(), createElementBlock50("div", {
        class: normalizeClass36(["transfer", [!unref50(isPC) ? "transfer-h5" : "", unref50(isWeChat) ? "transfer-h5-wechat" : ""]])
      }, [
        !unref50(isPC) ? (openBlock51(), createElementBlock50("header", _hoisted_147, [
          !props.isHiddenBackIcon ? (openBlock51(), createElementBlock50("div", {
            key: 0,
            onClick: cancel
          }, [
            createVNode26(Icon, {
              class: "icon",
              file: unref50(backIcon),
              width: "18px",
              height: "18px"
            }, null, 8, ["file"])
          ])) : createCommentVNode36("", true),
          createElementVNode36("span", _hoisted_231, toDisplayString37(unref50(transferTitle)), 1),
          _cache[0] || (_cache[0] = createElementVNode36("span", { class: "space" }, null, -1))
        ])) : createCommentVNode36("", true),
        createElementVNode36("main", _hoisted_317, [
          createElementVNode36("div", _hoisted_413, [
            createElementVNode36("header", _hoisted_510, [
              unref50(isPC) && unref50(isTransferSearch) ? (openBlock51(), createElementBlock50("input", {
                key: 0,
                type: "text",
                value: unref50(searchValue),
                placeholder: unref50(Wt).t("component.请输入userID"),
                enterkeyhint: "search",
                class: normalizeClass36([unref50(isUniFrameWork) ? "left-uniapp-input" : ""]),
                onKeyup: withKeys2(handleInput, ["enter"])
              }, null, 42, _hoisted_68)) : createCommentVNode36("", true),
              !unref50(isPC) && unref50(isTransferSearch) ? (openBlock51(), createElementBlock50("input", {
                key: 1,
                type: "text",
                placeholder: unref50(Wt).t("component.请输入userID"),
                enterkeyhint: "search",
                value: unref50(searchValue),
                class: normalizeClass36([unref50(isUniFrameWork) ? "left-uniapp-input" : ""]),
                onBlur: handleInput,
                onConfirm: handleInput
              }, null, 42, _hoisted_76)) : createCommentVNode36("", true)
            ]),
            createElementVNode36("main", _hoisted_85, [
              createElementVNode36("ul", _hoisted_95, [
                unref50(optional).length > 1 && !__props.isRadio ? (openBlock51(), createElementBlock50("li", {
                  key: 0,
                  class: "transfer-list-item",
                  onClick: selectedAll
                }, [
                  unref50(transferSelectedList).length === unref50(optional).length ? (openBlock51(), createBlock12(Icon, {
                    key: 0,
                    file: unref50(selectedIcon),
                    width: "18px",
                    height: "18px"
                  }, null, 8, ["file"])) : (openBlock51(), createElementBlock50("i", _hoisted_105)),
                  createElementVNode36("span", _hoisted_1111, toDisplayString37(unref50(Wt).t("component.全选")), 1)
                ])) : createCommentVNode36("", true),
                (openBlock51(true), createElementBlock50(Fragment16, null, renderList13(unref50(transferList), (item) => {
                  return openBlock51(), createElementBlock50("li", {
                    key: item.userID,
                    class: "transfer-list-item",
                    onClick: ($event) => selected(item)
                  }, [
                    unref50(transferSelectedList).indexOf(item) > -1 ? (openBlock51(), createBlock12(Icon, {
                      key: 0,
                      file: unref50(selectedIcon),
                      class: normalizeClass36([item.isDisabled && "disabled"]),
                      width: "18px",
                      height: "18px"
                    }, null, 8, ["file", "class"])) : (openBlock51(), createElementBlock50("i", {
                      key: 1,
                      class: normalizeClass36([item.isDisabled && "disabled", "icon-unselected"])
                    }, null, 2)),
                    !unref50(isTransferCustomItem) ? (openBlock51(), createElementBlock50(Fragment16, { key: 2 }, [
                      createElementVNode36("img", {
                        class: "avatar",
                        src: item.avatar || "https://web.sdk.qcloud.com/component/TUIKit/assets/avatar_21.png",
                        onerror: "this.onerror=null;this.src='https://web.sdk.qcloud.com/component/TUIKit/assets/avatar_21.png'"
                      }, null, 8, _hoisted_1310),
                      createElementVNode36("span", _hoisted_148, toDisplayString37(item.nick || item.userID), 1),
                      item.isDisabled ? (openBlock51(), createElementBlock50("span", _hoisted_153, "（" + toDisplayString37(unref50(Wt).t("component.已在群中")) + "）", 1)) : createCommentVNode36("", true)
                    ], 64)) : renderSlot11(_ctx.$slots, "left", {
                      key: 3,
                      data: item
                    }, void 0, true)
                  ], 8, _hoisted_1211);
                }), 128)),
                unref50(transferTotal) > unref50(transferList).length ? (openBlock51(), createElementBlock50("li", {
                  key: 1,
                  class: "transfer-list-item more",
                  onClick: getMore
                }, toDisplayString37(unref50(Wt).t("component.查看更多")), 1)) : createCommentVNode36("", true)
              ])
            ])
          ]),
          createElementVNode36("div", _hoisted_163, [
            unref50(isPC) ? (openBlock51(), createElementBlock50("header", _hoisted_173, toDisplayString37(unref50(transferTitle)), 1)) : createCommentVNode36("", true),
            __props.resultShow ? (openBlock51(), createElementBlock50("ul", _hoisted_183, [
              unref50(transferSelectedList).length > 0 && unref50(isPC) ? (openBlock51(), createElementBlock50("p", _hoisted_193, toDisplayString37(unref50(Wt).t("component.已选中")) + toDisplayString37(unref50(transferSelectedList).length) + toDisplayString37(unref50(Wt).t("component.人")), 1)) : createCommentVNode36("", true),
              (openBlock51(true), createElementBlock50(Fragment16, null, renderList13(unref50(transferSelectedList), (item, index3) => {
                return openBlock51(), createElementBlock50("li", {
                  key: index3,
                  class: "transfer-list-item space-between"
                }, [
                  createElementVNode36("aside", _hoisted_202, [
                    !unref50(isTransferCustomItem) ? (openBlock51(), createElementBlock50(Fragment16, { key: 0 }, [
                      createElementVNode36("img", {
                        class: "avatar",
                        src: item.avatar || "https://web.sdk.qcloud.com/component/TUIKit/assets/avatar_21.png",
                        onerror: "this.onerror=null;this.src='https://web.sdk.qcloud.com/component/TUIKit/assets/avatar_21.png'"
                      }, null, 8, _hoisted_2110),
                      unref50(isPC) ? (openBlock51(), createElementBlock50("span", _hoisted_2210, toDisplayString37(item.nick || item.userID), 1)) : createCommentVNode36("", true)
                    ], 64)) : renderSlot11(_ctx.$slots, "right", {
                      key: 1,
                      data: item
                    }, void 0, true)
                  ]),
                  unref50(isPC) ? (openBlock51(), createElementBlock50("span", {
                    key: 0,
                    onClick: ($event) => selected(item)
                  }, [
                    createVNode26(Icon, {
                      file: unref50(cancelIcon),
                      width: "18px",
                      height: "18px"
                    }, null, 8, ["file"])
                  ], 8, _hoisted_232)) : createCommentVNode36("", true)
                ]);
              }), 128))
            ])) : createCommentVNode36("", true),
            createElementVNode36("footer", _hoisted_242, [
              createElementVNode36("button", {
                class: "btn btn-cancel",
                onClick: cancel
              }, toDisplayString37(unref50(Wt).t("component.取消")), 1),
              unref50(transferSelectedList).length > 0 ? (openBlock51(), createElementBlock50("button", {
                key: 0,
                class: "btn",
                onClick: submit
              }, toDisplayString37(unref50(Wt).t("component.完成")), 1)) : (openBlock51(), createElementBlock50("button", {
                key: 1,
                class: "btn btn-no",
                onClick: submit
              }, toDisplayString37(unref50(Wt).t("component.完成")), 1))
            ])
          ])
        ])
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/common/Transfer/index.vue.mjs
var Transfer = _export_sfc(_sfc_main52, [["__scopeId", "data-v-6b1d6fb4"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/forward/index.vue.mjs
var _sfc_main53 = defineComponent53({
  __name: "index",
  emits: ["toggleMultipleSelectMode"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    let selectedToForwardMessageIDList = [];
    let isMergeForward = false;
    const isShowForwardPanel = ref40(false);
    const customConversationList = ref40();
    onMounted19(() => {
      Jt.watch(o.CUSTOM, {
        singleForwardMessageID: onSingleForwardMessageIDUpdated,
        multipleForwardMessageID: onMultipleForwardMessageIDUpdated
      });
    });
    onUnmounted14(() => {
      Jt.unwatch(o.CUSTOM, {
        singleForwardMessageID: onSingleForwardMessageIDUpdated,
        multipleForwardMessageID: onMultipleForwardMessageIDUpdated
      });
      clearStoreData();
    });
    function onSingleForwardMessageIDUpdated(messageID) {
      if (typeof messageID !== "undefined") {
        isMergeForward = false;
        selectedToForwardMessageIDList = [messageID];
        openForwardPanel();
      }
    }
    function onMultipleForwardMessageIDUpdated(params) {
      if (!params) {
        return;
      }
      isMergeForward = false;
      const {
        isMergeForward: _isMergeForward,
        messageIDList: selectedMessageIDList
      } = params || {};
      if ((selectedMessageIDList == null ? void 0 : selectedMessageIDList.length) > 0) {
        isMergeForward = _isMergeForward;
        selectedToForwardMessageIDList = selectedMessageIDList;
        openForwardPanel();
      } else {
        Toast({
          message: Wt.t("TUIChat.未选择消息"),
          type: TOAST_TYPE.ERROR
        });
      }
    }
    function clearStoreData() {
      Jt.update(o.CUSTOM, "singleForwardMessageID", void 0);
      Jt.update(o.CUSTOM, "multipleForwardMessageID", void 0);
    }
    function closeForwardPanel() {
      clearStoreData();
      isShowForwardPanel.value = false;
    }
    function openForwardPanel() {
      getTransforRenderDataList();
      isShowForwardPanel.value = true;
    }
    function finishSelected(selectedConvIDWrapperList) {
      if ((selectedConvIDWrapperList == null ? void 0 : selectedConvIDWrapperList.length) === 0)
        return;
      const selectedConversationList = selectedConvIDWrapperList.map((IDWrapper) => Jt.getConversationModel(IDWrapper.userID));
      const unsentMessageQueue = selectedToForwardMessageIDList.map((messageID) => Jt.getMessageModel(messageID)).sort((a, b) => a.time - b.time);
      const forwardPromises = selectedConversationList.map((conversation) => {
        const offlinePushInfoCreateParams = {
          conversation,
          messageType: qt.TYPES.MSG_MERGER
        };
        return Qt.sendForwardMessage(
          [conversation],
          unsentMessageQueue,
          {
            needMerge: isMergeForward,
            offlinePushInfo: OfflinePushInfoManager2.create(offlinePushInfoCreateParams),
            params: {
              needReadReceipt: isEnabledMessageReadReceiptGlobal()
            }
          }
        );
      });
      Promise.allSettled(forwardPromises).then((results) => {
        for (const result of results) {
          const { status } = result;
          if (status === "rejected") {
            const errorMessage = result.reason.code === 80001 ? Wt.t("TUIChat.内容包含敏感词汇") : result.reason.message;
            Toast({
              message: errorMessage,
              type: TOAST_TYPE.ERROR
            });
            break;
          }
        }
      });
      closeForwardPanel();
      emits("toggleMultipleSelectMode", false);
    }
    function getTransforRenderDataList() {
      const conversationList = Jt.getData(o.CONV, "conversationList");
      customConversationList.value = conversationList.map((conversation) => {
        return {
          // To achieve reusability of Transfer, userID is used here instead of ConversationID
          userID: conversation.conversationID,
          nick: conversation.getShowName(),
          avatar: conversation.getAvatar()
        };
      });
    }
    return (_ctx, _cache) => {
      return openBlock52(), createBlock13(Overlay, {
        visible: unref51(isShowForwardPanel),
        useMask: false
      }, {
        default: withCtx11(() => [
          createVNode27(Transfer, {
            title: unref51(Wt).t("TUIChat.转发"),
            isSearch: false,
            isCustomItem: false,
            list: unref51(customConversationList),
            isHiddenBackIcon: unref51(isUniFrameWork),
            onCancel: closeForwardPanel,
            onSubmit: finishSelected
          }, null, 8, ["title", "list", "isHiddenBackIcon"])
        ]),
        _: 1
      }, 8, ["visible"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/index.vue2.mjs
import { defineComponent as defineComponent63, ref as ref50, onMounted as onMounted21, onUnmounted as onUnmounted16, watch as watch19, computed as computed22, createElementBlock as createElementBlock56, openBlock as openBlock62, normalizeClass as normalizeClass44, unref as unref61, createElementVNode as createElementVNode44, createCommentVNode as createCommentVNode42, createVNode as createVNode31, createBlock as createBlock23, Fragment as Fragment20, renderList as renderList17 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/emoji-picker/index.vue2.mjs
import { defineComponent as defineComponent56, ref as ref43, createBlock as createBlock16, openBlock as openBlock55, unref as unref54, withCtx as withCtx13, createVNode as createVNode29 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/face-light.svg.mjs
var faceIconLight = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20opacity='0.795169'%3e%3ccircle%20cx='8'%20cy='8'%20r='7.5'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M5%205C5.55228%205%206%205.44772%206%206C6%206.55228%205.55228%207%205%207C4.44772%207%204%206.55228%204%206C4%205.44772%204.44772%205%205%205Z'%20fill='%23232832'%20style='fill:%23232832;fill:color(display-p3%200.1360%200.1574%200.1949);fill-opacity:1;'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11%205C11.5523%205%2012%205.44772%2012%206C12%206.55228%2011.5523%207%2011%207C10.4477%207%2010%206.55228%2010%206C10%205.44772%2010.4477%205%2011%205Z'%20fill='%23232832'%20style='fill:%23232832;fill:color(display-p3%200.1360%200.1574%200.1949);fill-opacity:1;'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/face-dark.svg.mjs
var faceIconDark = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20opacity='0.795169'%3e%3ccircle%20cx='8'%20cy='8'%20r='7.5'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M5%205C5.55228%205%206%205.44772%206%206C6%206.55228%205.55228%207%205%207C4.44772%207%204%206.55228%204%206C4%205.44772%204.44772%205%205%205Z'%20fill='%23D5E0F2'%20style='fill:%23D5E0F2;'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M11%205C11.5523%205%2012%205.44772%2012%206C12%206.55228%2011.5523%207%2011%207C10.4477%207%2010%206.55228%2010%206C10%205.44772%2010.4477%205%2011%205Z'%20fill='%23D5E0F2'%20style='fill:%23D5E0F2;'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/emoji-picker/emoji-picker-dialog.vue2.mjs
import { defineComponent as defineComponent54, ref as ref41, onMounted as onMounted20, onUnmounted as onUnmounted15, createElementBlock as createElementBlock51, openBlock as openBlock53, normalizeClass as normalizeClass37, unref as unref52, createElementVNode as createElementVNode37, Fragment as Fragment17, renderList as renderList14, createCommentVNode as createCommentVNode37, createBlock as createBlock14 } from "vue";
var _hoisted_149 = ["onClick"];
var _hoisted_233 = ["src"];
var _hoisted_318 = ["src"];
var _hoisted_414 = ["src"];
var _hoisted_511 = { class: "emoji-picker-tab" };
var _hoisted_69 = ["onClick"];
var _hoisted_77 = ["src"];
var _hoisted_86 = ["src"];
var _sfc_main54 = defineComponent54({
  __name: "emoji-picker-dialog",
  emits: ["insertEmoji", "onClose", "sendMessage"],
  setup(__props, { emit: __emit }) {
    var _a3;
    const faceIcon = ChatConfig.getTheme() === "dark" ? faceIconDark : faceIconLight;
    const emits = __emit;
    const currentTabIndex = ref41(0);
    const currentConversation = ref41();
    const emojiPickerDialog = ref41();
    const emojiPickerListRef = ref41();
    const featureConfig = ChatConfig.getFeatureConfig();
    const list = ref41(initEmojiList());
    const currentTabItem = ref41(list == null ? void 0 : list.value[0]);
    const currentEmojiList = ref41((_a3 = list == null ? void 0 : list.value[0]) == null ? void 0 : _a3.list);
    onMounted20(() => {
      Jt.watch(o.CONV, {
        currentConversation: onCurrentConversationUpdate
      });
    });
    onUnmounted15(() => {
      Jt.unwatch(o.CONV, {
        currentConversation: onCurrentConversationUpdate
      });
    });
    const toggleEmojiTab = (index3) => {
      var _a22;
      currentTabIndex.value = index3;
      currentTabItem.value = list == null ? void 0 : list.value[index3];
      currentEmojiList.value = (_a22 = list == null ? void 0 : list.value[index3]) == null ? void 0 : _a22.list;
      if (!isUniFrameWork) {
        (emojiPickerListRef == null ? void 0 : emojiPickerListRef.value) && (emojiPickerListRef.value.scrollTop = 0);
      }
    };
    const select = (item, index3) => {
      var _a22, _b3, _c2;
      const options = {
        emoji: { key: item, name: convertKeyToEmojiName(item) },
        type: (_a22 = currentTabItem == null ? void 0 : currentTabItem.value) == null ? void 0 : _a22.type
      };
      switch ((_b3 = currentTabItem == null ? void 0 : currentTabItem.value) == null ? void 0 : _b3.type) {
        case EMOJI_TYPE.BASIC:
          options.url = ((_c2 = currentTabItem == null ? void 0 : currentTabItem.value) == null ? void 0 : _c2.url) + BASIC_EMOJI_URL_MAPPING[item];
          if (isUniFrameWork) {
            uni.$emit("insert-emoji", options);
          } else {
            emits("insertEmoji", options);
          }
          break;
        case EMOJI_TYPE.BIG:
          sendFaceMessage(index3, currentTabItem.value);
          break;
        case EMOJI_TYPE.CUSTOM:
          sendFaceMessage(index3, currentTabItem.value);
          break;
      }
      isPC && emits("onClose");
    };
    const sendFaceMessage = (index3, listItem) => {
      var _a22, _b3, _c2, _d2, _e2;
      const options = {
        to: ((_b3 = (_a22 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _a22.groupProfile) == null ? void 0 : _b3.groupID) || ((_d2 = (_c2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c2.userProfile) == null ? void 0 : _d2.userID),
        conversationType: (_e2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _e2.type,
        payload: {
          index: listItem.emojiGroupID,
          data: listItem.list[index3]
        },
        needReadReceipt: isEnabledMessageReadReceiptGlobal()
      };
      Qt.sendFaceMessage(options);
    };
    function sendMessage() {
      uni.$emit("send-message-in-emoji-picker");
    }
    function onCurrentConversationUpdate(conversation) {
      currentConversation.value = conversation;
    }
    function initEmojiList() {
      return EMOJI_GROUP_LIST.filter((item) => {
        if (item.type === EMOJI_TYPE.BASIC) {
          return featureConfig.InputEmoji;
        }
        if (item.type === EMOJI_TYPE.BIG) {
          return featureConfig.InputStickers;
        }
      });
    }
    return (_ctx, _cache) => {
      return openBlock53(), createElementBlock51("div", {
        ref_key: "emojiPickerDialog",
        ref: emojiPickerDialog,
        class: normalizeClass37({
          "emoji-picker": true,
          "emoji-picker-h5": !unref52(isPC)
        })
      }, [
        createElementVNode37("ul", {
          ref_key: "emojiPickerListRef",
          ref: emojiPickerListRef,
          class: normalizeClass37(["emoji-picker-list", !unref52(isPC) && "emoji-picker-h5-list"])
        }, [
          (openBlock53(true), createElementBlock51(Fragment17, null, renderList14(unref52(currentEmojiList), (childrenItem, childrenIndex) => {
            return openBlock53(), createElementBlock51("li", {
              key: childrenIndex,
              class: "emoji-picker-list-item",
              onClick: ($event) => select(childrenItem, childrenIndex)
            }, [
              unref52(currentTabItem).type === unref52(EMOJI_TYPE).BASIC ? (openBlock53(), createElementBlock51("img", {
                key: 0,
                class: "emoji",
                src: unref52(currentTabItem).url + unref52(BASIC_EMOJI_URL_MAPPING)[childrenItem]
              }, null, 8, _hoisted_233)) : unref52(currentTabItem).type === unref52(EMOJI_TYPE).BIG ? (openBlock53(), createElementBlock51("img", {
                key: 1,
                class: "emoji-big",
                src: unref52(currentTabItem).url + childrenItem + "@2x.png"
              }, null, 8, _hoisted_318)) : (openBlock53(), createElementBlock51("img", {
                key: 2,
                class: "emoji-custom emoji-big",
                src: unref52(currentTabItem).url + childrenItem
              }, null, 8, _hoisted_414))
            ], 8, _hoisted_149);
          }), 128))
        ], 2),
        createElementVNode37("ul", _hoisted_511, [
          (openBlock53(true), createElementBlock51(Fragment17, null, renderList14(unref52(list), (item, index3) => {
            return openBlock53(), createElementBlock51("li", {
              key: index3,
              class: "emoji-picker-tab-item",
              onClick: ($event) => toggleEmojiTab(index3)
            }, [
              item.type === unref52(EMOJI_TYPE).BASIC ? (openBlock53(), createBlock14(Icon, {
                key: 0,
                class: "icon",
                file: unref52(faceIcon)
              }, null, 8, ["file"])) : item.type === unref52(EMOJI_TYPE).BIG ? (openBlock53(), createElementBlock51("img", {
                key: 1,
                class: "icon-big",
                src: item.url + item.list[0] + "@2x.png"
              }, null, 8, _hoisted_77)) : (openBlock53(), createElementBlock51("img", {
                key: 2,
                class: "icon-custom icon-big",
                src: item.url + item.list[0]
              }, null, 8, _hoisted_86))
            ], 8, _hoisted_69);
          }), 128)),
          unref52(isUniFrameWork) ? (openBlock53(), createElementBlock51("li", {
            key: 0,
            class: "send-btn",
            onClick: sendMessage
          }, " 发送 ")) : createCommentVNode37("", true)
        ])
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/emoji-picker/emoji-picker-dialog.vue.mjs
var EmojiPickerDialog = _export_sfc(_sfc_main54, [["__scopeId", "data-v-c2998cf0"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/toolbar-item-container/index.vue2.mjs
import { defineComponent as defineComponent55, ref as ref42, createElementBlock as createElementBlock52, openBlock as openBlock54, normalizeClass as normalizeClass38, unref as unref53, createElementVNode as createElementVNode38, createCommentVNode as createCommentVNode38, withDirectives as withDirectives4, createVNode as createVNode28, toDisplayString as toDisplayString38, createBlock as createBlock15, renderSlot as renderSlot12, withModifiers as withModifiers12, withCtx as withCtx12, vShow as vShow4 } from "vue";
var _hoisted_150 = {
  key: 0,
  class: normalizeClass38(["toolbar-item-container-uni-title"])
};
var _sfc_main55 = defineComponent55({
  __name: "index",
  props: {
    iconFile: {
      type: String,
      required: true
    },
    title: {
      type: String,
      default: ""
    },
    needDialog: {
      type: Boolean,
      default: true
    },
    iconWidth: {
      type: String,
      default: "20px"
    },
    iconHeight: {
      type: String,
      default: "20px"
    },
    // Whether to display the bottom popup dialog on mobile devices
    // Invalid on PC
    needBottomPopup: {
      type: Boolean,
      default: false
    }
  },
  emits: ["onIconClick", "onDialogClose", "onDialogShow"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isDark = ref42(ChatConfig.getTheme() === "dark");
    const showDialog = ref42(false);
    const toolbarItemRef = ref42();
    const dialogRef = ref42();
    const toggleToolbarItem = () => {
      emits("onIconClick", dialogRef);
      if (isPC) {
        O.listen({
          domRefs: toolbarItemRef.value,
          handler: closeToolbarItem
        });
      }
      if (!props.needDialog) {
        return;
      }
      toggleDialogDisplay(!showDialog.value);
    };
    const closeToolbarItem = () => {
      showDialog.value = false;
      emits("onDialogClose", dialogRef);
    };
    const toggleDialogDisplay = (showStatus) => {
      if (showDialog.value === showStatus) {
        return;
      }
      showDialog.value = showStatus;
      switch (showStatus) {
        case true:
          emits("onDialogShow", dialogRef);
          break;
        case false:
          emits("onDialogClose", dialogRef);
      }
    };
    const onPopupClose = () => {
      showDialog.value = false;
    };
    __expose({
      toggleDialogDisplay
    });
    return (_ctx, _cache) => {
      return openBlock54(), createElementBlock52("div", {
        ref_key: "toolbarItemRef",
        ref: toolbarItemRef,
        class: normalizeClass38([
          "toolbar-item-container",
          !unref53(isPC) && "toolbar-item-container-h5",
          unref53(isUniFrameWork) && "toolbar-item-container-uni"
        ])
      }, [
        createElementVNode38("div", {
          class: normalizeClass38([
            "toolbar-item-container-icon",
            unref53(isUniFrameWork) && "toolbar-item-container-uni-icon"
          ]),
          onClick: toggleToolbarItem
        }, [
          createVNode28(Icon, {
            file: props.iconFile,
            class: "icon",
            width: props.iconWidth,
            height: props.iconHeight
          }, null, 8, ["file", "width", "height"])
        ], 2),
        unref53(isUniFrameWork) ? (openBlock54(), createElementBlock52("div", _hoisted_150, toDisplayString38(props.title), 1)) : createCommentVNode38("", true),
        withDirectives4(createElementVNode38("div", {
          ref_key: "dialogRef",
          ref: dialogRef,
          class: normalizeClass38([
            "toolbar-item-container-dialog",
            unref53(isDark) && "toolbar-item-container-dialog-dark",
            !unref53(isPC) && "toolbar-item-container-h5-dialog",
            unref53(isUniFrameWork) && "toolbar-item-container-uni-dialog"
          ])
        }, [
          props.needBottomPopup && !unref53(isPC) ? (openBlock54(), createBlock15(BottomPopup, {
            key: 0,
            class: "toolbar-bottom-popup",
            show: unref53(showDialog),
            onTouchmove: _cache[0] || (_cache[0] = withModifiers12(() => {
            }, ["stop", "prevent"])),
            onOnClose: onPopupClose
          }, {
            default: withCtx12(() => [
              renderSlot12(_ctx.$slots, "default", {}, void 0, true)
            ]),
            _: 3
          }, 8, ["show"])) : renderSlot12(_ctx.$slots, "default", { key: 1 }, void 0, true)
        ], 2), [
          [vShow4, unref53(showDialog)]
        ])
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/toolbar-item-container/index.vue.mjs
var ToolbarItemContainer = _export_sfc(_sfc_main55, [["__scopeId", "data-v-c89673ca"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/emoji-picker/index.vue2.mjs
var _sfc_main56 = defineComponent56({
  __name: "index",
  emits: ["sendMessage", "toggleComponent", "insertEmoji", "dialogShowInH5", "dialogCloseInH5", "changeToolbarDisplayType"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const faceIcon = ChatConfig.getTheme() === "dark" ? faceIconDark : faceIconLight;
    const emits = __emit;
    const currentConversation = ref43();
    const container = ref43();
    Jt.watch(o.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const onDialogShow = (dialogRef) => {
      if (!isH5) {
        return;
      }
      emits("changeToolbarDisplayType", "emojiPicker");
      emits("dialogShowInH5", dialogRef.value);
    };
    const onDialogClose = (dialogRef) => {
      if (!isH5) {
        return;
      }
      emits("changeToolbarDisplayType", "none");
      emits("dialogCloseInH5", dialogRef.value);
    };
    const insertEmoji = (emojiObj) => {
      emits("insertEmoji", emojiObj);
    };
    const sendMessage = () => {
      emits("sendMessage");
    };
    const onClose = () => {
      var _a3;
      (_a3 = container.value) == null ? void 0 : _a3.toggleDialogDisplay(false);
    };
    __expose({
      closeEmojiPicker: onClose
    });
    return (_ctx, _cache) => {
      return openBlock55(), createBlock16(ToolbarItemContainer, {
        ref_key: "container",
        ref: container,
        iconFile: unref54(faceIcon),
        title: "表情",
        onOnDialogShow: onDialogShow,
        onOnDialogClose: onDialogClose
      }, {
        default: withCtx13(() => [
          createVNode29(EmojiPickerDialog, {
            onInsertEmoji: insertEmoji,
            onSendMessage: sendMessage,
            onOnClose: onClose
          })
        ]),
        _: 1
      }, 8, ["iconFile"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/emoji-picker/index.vue.mjs
var EmojiPicker = _export_sfc(_sfc_main56, [["__scopeId", "data-v-eddc124e"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/image-upload/index.vue2.mjs
import { defineComponent as defineComponent57, ref as ref44, computed as computed19, createBlock as createBlock17, openBlock as openBlock56, unref as unref55, withCtx as withCtx14, createElementBlock as createElementBlock53, createCommentVNode as createCommentVNode39, normalizeClass as normalizeClass39, createElementVNode as createElementVNode39 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/image-light.svg.mjs
var imageIconLight = "data:image/svg+xml,%3csvg%20width='16'%20height='14'%20viewBox='0%200%2016%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209'%20opacity='0.795169'%3e%3ccircle%20id='&%23230;&%23164;&%23173;&%23229;&%23156;&%23134;&%23229;&%23189;&%23162;'%20cx='5.5'%20cy='4.5'%20r='1'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'/%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20x='0.5'%20y='0.5'%20width='15'%20height='13'%20rx='1.75'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'/%3e%3cg%20id='&%23232;&%23183;&%23175;&%23229;&%23190;&%23132;%202'%3e%3cmask%20id='path-3-inside-1_2613_41437'%20fill='white'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M3%2011L5.42403%208.9433C5.50934%208.87092%205.63487%208.87221%205.71867%208.94633L7.88124%2010.8592C7.97058%2010.9382%208.10606%2010.9338%208.19006%2010.8491L13%206'/%3e%3c/mask%3e%3cpath%20d='M2.35303%2010.2375C1.93191%2010.5948%201.88017%2011.2258%202.23748%2011.647C2.59479%2012.0681%203.22584%2012.1198%203.64697%2011.7625L2.35303%2010.2375ZM13.71%206.70423C14.0989%206.31213%2014.0963%205.67897%2013.7042%205.29003C13.3121%204.90109%2012.679%204.90366%2012.29%205.29577L13.71%206.70423ZM7.88124%2010.8592L7.2187%2011.6082L7.88124%2010.8592ZM8.19006%2010.8491L8.90003%2011.5534L8.19006%2010.8491ZM5.42403%208.9433L6.071%209.70582L5.42403%208.9433ZM5.71867%208.94633L6.38121%208.19731L5.71867%208.94633ZM3.64697%2011.7625L6.071%209.70582L4.77706%208.18078L2.35303%2010.2375L3.64697%2011.7625ZM5.05613%209.69536L7.2187%2011.6082L8.54378%2010.1102L6.38121%208.19731L5.05613%209.69536ZM8.90003%2011.5534L13.71%206.70423L12.29%205.29577L7.48009%2010.1449L8.90003%2011.5534ZM7.2187%2011.6082C7.7051%2012.0385%208.44272%2012.0144%208.90003%2011.5534L7.48009%2010.1449C7.76941%209.85322%208.23606%209.83799%208.54378%2010.1102L7.2187%2011.6082ZM6.071%209.70582C5.77716%209.95513%205.34477%209.95068%205.05613%209.69536L6.38121%208.19731C5.92497%207.79374%205.24152%207.78671%204.77706%208.18078L6.071%209.70582Z'%20fill='%23232832'%20style='fill:%23232832;fill:color(display-p3%200.1360%200.1574%200.1949);fill-opacity:1;'%20mask='url(%23path-3-inside-1_2613_41437)'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/image-dark.svg.mjs
var imageIconDark = "data:image/svg+xml,%3csvg%20width='16'%20height='14'%20viewBox='0%200%2016%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209'%20opacity='0.795169'%3e%3ccircle%20id='&%23230;&%23164;&%23173;&%23229;&%23156;&%23134;&%23229;&%23189;&%23162;'%20cx='5.5'%20cy='4.5'%20r='1'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'/%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20x='0.5'%20y='0.5'%20width='15'%20height='13'%20rx='1.75'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'/%3e%3cg%20id='&%23232;&%23183;&%23175;&%23229;&%23190;&%23132;%202'%3e%3cmask%20id='path-3-inside-1_2613_41437'%20fill='white'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M3%2011L5.42403%208.9433C5.50934%208.87092%205.63487%208.87221%205.71867%208.94633L7.88124%2010.8592C7.97058%2010.9382%208.10606%2010.9338%208.19006%2010.8491L13%206'/%3e%3c/mask%3e%3cpath%20d='M2.35303%2010.2375C1.93191%2010.5948%201.88017%2011.2258%202.23748%2011.647C2.59479%2012.0681%203.22584%2012.1198%203.64697%2011.7625L2.35303%2010.2375ZM13.71%206.70423C14.0989%206.31213%2014.0963%205.67897%2013.7042%205.29003C13.3121%204.90109%2012.679%204.90366%2012.29%205.29577L13.71%206.70423ZM7.88124%2010.8592L7.2187%2011.6082L7.88124%2010.8592ZM8.19006%2010.8491L8.90003%2011.5534L8.19006%2010.8491ZM5.42403%208.9433L6.071%209.70582L5.42403%208.9433ZM5.71867%208.94633L6.38121%208.19731L5.71867%208.94633ZM3.64697%2011.7625L6.071%209.70582L4.77706%208.18078L2.35303%2010.2375L3.64697%2011.7625ZM5.05613%209.69536L7.2187%2011.6082L8.54378%2010.1102L6.38121%208.19731L5.05613%209.69536ZM8.90003%2011.5534L13.71%206.70423L12.29%205.29577L7.48009%2010.1449L8.90003%2011.5534ZM7.2187%2011.6082C7.7051%2012.0385%208.44272%2012.0144%208.90003%2011.5534L7.48009%2010.1449C7.76941%209.85322%208.23606%209.83799%208.54378%2010.1102L7.2187%2011.6082ZM6.071%209.70582C5.77716%209.95513%205.34477%209.95068%205.05613%209.69536L6.38121%208.19731C5.92497%207.79374%205.24152%207.78671%204.77706%208.18078L6.071%209.70582Z'%20fill='%23D5E0F2'%20style='fill:%23D5E0F2;'%20mask='url(%23path-3-inside-1_2613_41437)'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/image-uni.png.mjs
var imageUniIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGgAAABQCAYAAAD1NTBhAAAKrWlDQ1BJQ0MgUHJvZmlsZQAASImVlwdQU1kXgO976SGhJUQ6oTdBOgGkhNACCEgHGyEJEEqIgQAiKiqLK7iiiIigougqRcG1ALJWRLEtCopdN8gioKyLBRsq/wOG4O4////Pf2bOnO+dd+6559659815AJAVOSJRKqwIQJowUxzq60mPjoml4wYBGsgDGlADthxuhogZEhIIEJmxf5f3dwE0aW9bTOb69/f/VZR4/AwuAFAIwvG8DG4awicQfcEViTMBQO1F/PrZmaJJ7kCYKkYKRPj+JCdO88gkx08xGkzFhIeyEKYCgCdxOOJEAEh0xE/P4iYieUgeCFsJeQIhwiKE3dLS0nkIH0XYBIlBfKTJ/Iz47/Ik/i1nvCwnh5Mo4+m1TAneS5AhSuWs+D+3439LWqpkZg4jRElJYr9QxCoje3Y/JT1AxsL4oOAZFvCm4qc4SeIXMcPcDFbsDPM4XgGysalBgTOcIPBhy/JkssNnmJ/hHTbD4vRQ2VwJYhZzhjni2XklKREyfxKfLcufmxQeNcNZgsigGc5ICQuYjWHJ/GJJqKx+vtDXc3ZeH9na0zK+W6+ALRubmRTuJ1s7Z7Z+vpA5mzMjWlYbj+/lPRsTIYsXZXrK5hKlhsji+am+Mn9GVphsbCZyIGfHhsj2MJnjHzLDgAXSQSqiYkAHgciTFwCZ/JzMyYWw0kUrxILEpEw6E7lhfDpbyLWcS7exsrEFYPK+Th+Ht7SpewjRrs361hMBcBVOTEycnvUFfAbghC4AROmsz7gHAHnk3F/ZypWIs6Z9U3cJA4hAAVCRL4E20AcmwALYAAfgAjyAN/AHwSAcxIClgAuSQBpSeTbIA2tBISgGW8B2UAmqwX5QC46AY6AFnAYXwGVwHdwCveARkIIB8BKMgvdgHIIgHESGKJAapAMZQuaQDcSA3CBvKBAKhWKgOCgREkISKA9aDxVDpVAltA+qg36BTkEXoKtQN/QA6oOGoTfQZxgFk2AqrAUbwfNgBsyEA+BweAmcCC+Hc+ECeDNcAdfAh+Fm+AJ8He6FpfBLeAwFUHIoGkoXZYFioFioYFQsKgElRq1GFaHKUTWoRlQbqhN1GyVFjaA+obFoCpqOtkC7oP3QEWguejl6NXoTuhJdi25Gd6Bvo/vQo+hvGDJGE2OOccawMdGYREw2phBTjjmIOYm5hOnFDGDeY7FYGtYY64j1w8Zgk7ErsZuwu7FN2PPYbmw/dgyHw6nhzHGuuGAcB5eJK8TtxB3GncP14AZwH/FyeB28Dd4HH4sX4tfhy/H1+LP4HvwgfpygSDAkOBOCCTzCCkIJ4QChjXCTMEAYJyoRjYmuxHBiMnEtsYLYSLxEfEx8KycnpyfnJLdQTiCXL1chd1Tuilyf3CeSMsmMxCItJklIm0mHSOdJD0hvyWSyEdmDHEvOJG8m15Evkp+SP8pT5C3l2fI8+TXyVfLN8j3yrxQICoYKTIWlCrkK5QrHFW4qjCgSFI0UWYocxdWKVYqnFO8pjilRlKyVgpXSlDYp1StdVRpSxikbKXsr85QLlPcrX1Tup6Ao+hQWhUtZTzlAuUQZoGKpxlQ2NZlaTD1C7aKOqiir2KlEquSoVKmcUZHSUDQjGpuWSiuhHaPdpX2eozWHOYc/Z+Ocxjk9cz6oaqh6qPJVi1SbVHtVP6vR1bzVUtS2qrWoPVFHq5upL1TPVt+jfkl9RIOq4aLB1SjSOKbxUBPWNNMM1VypuV/zhuaYlraWr5ZIa6fWRa0RbZq2h3aydpn2We1hHYqOm45Ap0znnM4LugqdSU+lV9A76KO6mrp+uhLdfbpduuN6xnoReuv0mvSe6BP1GfoJ+mX67fqjBjoGCwzyDBoMHhoSDBmGSYY7DDsNPxgZG0UZbTBqMRoyVjVmG+caNxg/NiGbuJssN6kxuWOKNWWYppjuNr1lBpvZmyWZVZndNIfNHcwF5rvNu+di5jrNFc6tmXvPgmTBtMiyaLDos6RZBlqus2yxfDXPYF7svK3zOud9s7K3SrU6YPXIWtna33qddZv1GxszG65Nlc0dW7Ktj+0a21bb13bmdny7PXb37Sn2C+w32Lfbf3VwdBA7NDoMOxo4xjnucrzHoDJCGJsYV5wwTp5Oa5xOO31ydnDOdD7m/JeLhUuKS73L0Hzj+fz5B+b3u+q5clz3uUrd6G5xbnvdpO667hz3GvdnHvoePI+DHoNMU2Yy8zDzlaeVp9jzpOcHljNrFeu8F8rL16vIq8tb2TvCu9L7qY+eT6JPg8+or73vSt/zfhi/AL+tfvfYWmwuu4496u/ov8q/I4AUEBZQGfAs0CxQHNi2AF7gv2DbgsdBhkHCoJZgEMwO3hb8JMQ4ZHnIrwuxC0MWVi18HmodmhfaGUYJWxZWH/Y+3DO8JPxRhEmEJKI9UiFycWRd5Icor6jSKGn0vOhV0ddj1GMEMa2xuNjI2IOxY4u8F21fNLDYfnHh4rtLjJfkLLm6VH1p6tIzyxSWcZYdj8PERcXVx33hBHNqOGPx7Phd8aNcFncH9yXPg1fGG+a78kv5gwmuCaUJQ4muidsSh5Pck8qTRgQsQaXgdbJfcnXyh5TglEMpE6lRqU1p+LS4tFNCZWGKsCNdOz0nvVtkLioUSZc7L9++fFQcID6YAWUsyWjNpCKN0Q2JieQHSV+WW1ZV1sfsyOzjOUo5wpwbK8xWbFwxmOuT+/NK9EruyvY83by1eX2rmKv2rYZWx69uX6O/pmDNQL5vfu1a4tqUtb+ts1pXuu7d+qj1bQVaBfkF/T/4/tBQKF8oLry3wWVD9Y/oHwU/dm203bhz47ciXtG1Yqvi8uIvm7ibrv1k/VPFTxObEzZ3lTiU7NmC3SLccner+9baUqXS3NL+bQu2NZfRy4rK3m1ftv1quV159Q7iDskOaUVgRetOg51bdn6pTKrsrfKsatqluWvjrg+7ebt79njsaazWqi6u/rxXsPf+Pt99zTVGNeX7sfuz9j8/EHmg82fGz3UH1Q8WH/x6SHhIWhta21HnWFdXr1lf0gA3SBqGDy8+fOuI15HWRovGfU20puKj4Kjk6Itf4n65eyzgWPtxxvHGE4Yndp2knCxqhppXNI+2JLVIW2Nau0/5n2pvc2k7+avlr4dO656uOqNypuQs8WzB2YlzuefGzovOj1xIvNDfvqz90cXoi3c6FnZ0XQq4dOWyz+WLnczOc1dcr5y+6nz11DXGtZbrDtebb9jfOPmb/W8nuxy6mm863my95XSrrXt+99ke954Lt71uX77DvnO9N6i3+27E3fv3Ft+T3ufdH3qQ+uD1w6yH44/yH2MeFz1RfFL+VPNpze+mvzdJHaRn+rz6bjwLe/aon9v/8o+MP74MFDwnPy8f1BmsG7IZOj3sM3zrxaIXAy9FL8dHCv9U+nPXK5NXJ/7y+OvGaPTowGvx64k3m96qvT30zu5d+1jI2NP3ae/HPxR9VPtY+4nxqfNz1OfB8ewvuC8VX02/tn0L+PZ4Im1iQsQRc6ZaARSicEICAG8OAUCOAYByC+kfFk3301MCTf8DTBH4Tzzdc0+JAwCNiJlsi1jnATiKqFE+khvRyZYo3APAtrYynel9p/r0ScEifyx7vSbpwbYl+eAfMt3Df1f3Py2YzGoH/mn/BRtaBzaO17uzAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAABooAMABAAAAAEAAABQAAAAAM3KimwAAAXjSURBVHgB7Zy/bxxFFMff3J2JceWIlMQc4kdSJefEBR0YFIGgsJOKH0FZU4BT4TQIRJHzXxBTxQSJnBGOUiW2xA9FEeAyQk680PCj4TCUjpSCGKI77/DehlWW9c7u3t7sz3vT3O28mZ2597n57vxcAZ5w0ph9zhIwXQWYkgB1j5kvE/GAMKWQ5pAF863WYttdhHAuDGNudKfy91kpxZwTx5/pewBBLQxZDyOohTtUug2I4HTEve8EyEb6VeISd3tAmDW5Z5IgVchILYfh7HZTdjGy0UEmVL4wjNl6V8Bv2VWGS1Z6QMJkpSOgqUzAhqw9MF1BaTucdS24fH8PCAFT+AwS3DHw90/msTTMsTsJmdeEK6D0AANSuiYfBgaUDw7KWjAgpWvyYWBA+eCgrAUDUromHwYGlA8OylowIKVr8mGoJVWNgweegokjDTg6fhj27XvELmZz80/4ffMPuLL6JWzdvp1U0aW6rzg5M4sDVn1hZGQEjk+9Ai8dez7wpteuf4OgvoLt7e3AdINu1CpxBOfD986EwiGnv3jsBTst5eGg9oBWQNRyxsYeVZfmsVDaE1Mve2L50u0BbYDoORMma+6Cne/Ukg4eeNq55E+PB7QBOoGtJ26YOMIrHirfaQM0tn+/qozQeOrpcfD3gDZAj/Xw7PFWxemGe+P5GkAbIHZmMh7QBmhrK/7AkwavHPw9oA3Q+sYP/iVEiKUZBg7+HtAG6Nat+IBo6oeDvwe0Afrpl1/h2vVv/UsJiKU8PC+ndpA2QFTEldUvcDI0ulxRWm49ajhkqR4an2gGJ4lu7XS6cOP7dXhoaAiefOLxwIzUci58+hlPlgZ6CTfF6Z7NdsqjsQ3NLtAA1hkjUU/vJnYmbuLziiSxCEFIaEuR3TGcxAAVwfm+dZSwhkc+ljoAa5ddZ3VexT3sNbAaEirTuOPzlG/eBCIZkONUBNMFmHFDcUzeT4KFB9yaaYBiQCDvSCnnl1sXFrwgwq7xNGITT1idDUvXj11rL66fimSRF5eS25a0JuPAofp+3lpsWhJmkqz74AKSsHRXDo9fan1i9uPgS63FVpKQBhAQSZp1Bv/9xsp/50D7AUR5k4Q0UID6lbQgkElBGhxAMSWNemxBYNy2JCANQC8uXi/tNeP0dFVYF3EsP0otT0iBsnh+xQ1E9f11Y9bAo4uYt/9Q6hYUV9LefOudc1UhrxIccjEOXOuA12/MnD4VxeU6W1J5AcWQNDrxjhA2VC/zwPO8rbQhlRBQvF4aSVpXyI2w90WkDalUgHRJWpiMpQmpPIASkLQgUGlBKgGgZCUta0iFBpSWpGUJqbiAUpa0rCAVEFB2kpYFpEIByoOkpQ2pOIByJGlpQioAoHxKWlqQcg0o75KWBqT8AiqIpCUNKYeAiidpSULKFaAiS1pSkPIDqASSlgSkHKyokqT1vi/NveIZ5Ji82SS+aHn54vmlKPWildlMAZGkSblzvNetT7TiqVpUi/LDs07TC6TsJK7kkhb0J+hlqSIDQOXqpQWBCLJFhZQqoLL20oJABNmiQEoP0ABLWj+QUgDEkhYEiGxBLSlRQCxpYWge2FWQkgPEkvbA+xG/+UFKABBLWkQevsm8kLQCYknz9XnPkW5ItZ5zqzKQpMHwXC9nbmirbUeIqzjV01DddlDjbUjG23s1AIo/l9bF0wO4Md3eoD6oIIJ+txCVc30Buj+XZsWcS5Nz9rmBoBqyDeIDYklL5e9TQ4lpY0uoRy+NJS26r/pNKc0KPqBXo96Ge2lRPaUnHS6pmChxYgVv927oLVnSQl2kO8EOwHz1R3O9fahxdC8I8Yx/AbakfbDc+vj9n80b//in2R1LK554bPBrlND6bivHhHpAwkd4lPKyPVCtwb0mgDS9mVjSvB5J5xpXXM2/YBiZuPq5hmGMdmFPE1vSfblDScNEsQaeOMhqpPNTSlgKthyC4wz4UYH+H+w3OQnxbNSNDU7uom7icOqf5Se9kw6fN6soZyv4BpQ1d13+BSg11toI//V/AAAAAElFTkSuQmCC";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/camera-uni.png.mjs
var cameraUniIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGgAAABUCAYAAABupHJ3AAAKrWlDQ1BJQ0MgUHJvZmlsZQAASImVlwdQU1kXgO976SGhJUQ6oTdBOgGkhNACCEgHGyEJEEqIgQAiKiqLK7iiiIigougqRcG1ALJWRLEtCopdN8gioKyLBRsq/wOG4O4////Pf2bOnO+dd+6559659815AJAVOSJRKqwIQJowUxzq60mPjoml4wYBGsgDGlADthxuhogZEhIIEJmxf5f3dwE0aW9bTOb69/f/VZR4/AwuAFAIwvG8DG4awicQfcEViTMBQO1F/PrZmaJJ7kCYKkYKRPj+JCdO88gkx08xGkzFhIeyEKYCgCdxOOJEAEh0xE/P4iYieUgeCFsJeQIhwiKE3dLS0nkIH0XYBIlBfKTJ/Iz47/Ik/i1nvCwnh5Mo4+m1TAneS5AhSuWs+D+3439LWqpkZg4jRElJYr9QxCoje3Y/JT1AxsL4oOAZFvCm4qc4SeIXMcPcDFbsDPM4XgGysalBgTOcIPBhy/JkssNnmJ/hHTbD4vRQ2VwJYhZzhjni2XklKREyfxKfLcufmxQeNcNZgsigGc5ICQuYjWHJ/GJJqKx+vtDXc3ZeH9na0zK+W6+ALRubmRTuJ1s7Z7Z+vpA5mzMjWlYbj+/lPRsTIYsXZXrK5hKlhsji+am+Mn9GVphsbCZyIGfHhsj2MJnjHzLDgAXSQSqiYkAHgciTFwCZ/JzMyYWw0kUrxILEpEw6E7lhfDpbyLWcS7exsrEFYPK+Th+Ht7SpewjRrs361hMBcBVOTEycnvUFfAbghC4AROmsz7gHAHnk3F/ZypWIs6Z9U3cJA4hAAVCRL4E20AcmwALYAAfgAjyAN/AHwSAcxIClgAuSQBpSeTbIA2tBISgGW8B2UAmqwX5QC46AY6AFnAYXwGVwHdwCveARkIIB8BKMgvdgHIIgHESGKJAapAMZQuaQDcSA3CBvKBAKhWKgOCgREkISKA9aDxVDpVAltA+qg36BTkEXoKtQN/QA6oOGoTfQZxgFk2AqrAUbwfNgBsyEA+BweAmcCC+Hc+ECeDNcAdfAh+Fm+AJ8He6FpfBLeAwFUHIoGkoXZYFioFioYFQsKgElRq1GFaHKUTWoRlQbqhN1GyVFjaA+obFoCpqOtkC7oP3QEWguejl6NXoTuhJdi25Gd6Bvo/vQo+hvGDJGE2OOccawMdGYREw2phBTjjmIOYm5hOnFDGDeY7FYGtYY64j1w8Zgk7ErsZuwu7FN2PPYbmw/dgyHw6nhzHGuuGAcB5eJK8TtxB3GncP14AZwH/FyeB28Dd4HH4sX4tfhy/H1+LP4HvwgfpygSDAkOBOCCTzCCkIJ4QChjXCTMEAYJyoRjYmuxHBiMnEtsYLYSLxEfEx8KycnpyfnJLdQTiCXL1chd1Tuilyf3CeSMsmMxCItJklIm0mHSOdJD0hvyWSyEdmDHEvOJG8m15Evkp+SP8pT5C3l2fI8+TXyVfLN8j3yrxQICoYKTIWlCrkK5QrHFW4qjCgSFI0UWYocxdWKVYqnFO8pjilRlKyVgpXSlDYp1StdVRpSxikbKXsr85QLlPcrX1Tup6Ao+hQWhUtZTzlAuUQZoGKpxlQ2NZlaTD1C7aKOqiir2KlEquSoVKmcUZHSUDQjGpuWSiuhHaPdpX2eozWHOYc/Z+Ocxjk9cz6oaqh6qPJVi1SbVHtVP6vR1bzVUtS2qrWoPVFHq5upL1TPVt+jfkl9RIOq4aLB1SjSOKbxUBPWNNMM1VypuV/zhuaYlraWr5ZIa6fWRa0RbZq2h3aydpn2We1hHYqOm45Ap0znnM4LugqdSU+lV9A76KO6mrp+uhLdfbpduuN6xnoReuv0mvSe6BP1GfoJ+mX67fqjBjoGCwzyDBoMHhoSDBmGSYY7DDsNPxgZG0UZbTBqMRoyVjVmG+caNxg/NiGbuJssN6kxuWOKNWWYppjuNr1lBpvZmyWZVZndNIfNHcwF5rvNu+di5jrNFc6tmXvPgmTBtMiyaLDos6RZBlqus2yxfDXPYF7svK3zOud9s7K3SrU6YPXIWtna33qddZv1GxszG65Nlc0dW7Ktj+0a21bb13bmdny7PXb37Sn2C+w32Lfbf3VwdBA7NDoMOxo4xjnucrzHoDJCGJsYV5wwTp5Oa5xOO31ydnDOdD7m/JeLhUuKS73L0Hzj+fz5B+b3u+q5clz3uUrd6G5xbnvdpO667hz3GvdnHvoePI+DHoNMU2Yy8zDzlaeVp9jzpOcHljNrFeu8F8rL16vIq8tb2TvCu9L7qY+eT6JPg8+or73vSt/zfhi/AL+tfvfYWmwuu4496u/ov8q/I4AUEBZQGfAs0CxQHNi2AF7gv2DbgsdBhkHCoJZgEMwO3hb8JMQ4ZHnIrwuxC0MWVi18HmodmhfaGUYJWxZWH/Y+3DO8JPxRhEmEJKI9UiFycWRd5Icor6jSKGn0vOhV0ddj1GMEMa2xuNjI2IOxY4u8F21fNLDYfnHh4rtLjJfkLLm6VH1p6tIzyxSWcZYdj8PERcXVx33hBHNqOGPx7Phd8aNcFncH9yXPg1fGG+a78kv5gwmuCaUJQ4muidsSh5Pck8qTRgQsQaXgdbJfcnXyh5TglEMpE6lRqU1p+LS4tFNCZWGKsCNdOz0nvVtkLioUSZc7L9++fFQcID6YAWUsyWjNpCKN0Q2JieQHSV+WW1ZV1sfsyOzjOUo5wpwbK8xWbFwxmOuT+/NK9EruyvY83by1eX2rmKv2rYZWx69uX6O/pmDNQL5vfu1a4tqUtb+ts1pXuu7d+qj1bQVaBfkF/T/4/tBQKF8oLry3wWVD9Y/oHwU/dm203bhz47ciXtG1Yqvi8uIvm7ibrv1k/VPFTxObEzZ3lTiU7NmC3SLccner+9baUqXS3NL+bQu2NZfRy4rK3m1ftv1quV159Q7iDskOaUVgRetOg51bdn6pTKrsrfKsatqluWvjrg+7ebt79njsaazWqi6u/rxXsPf+Pt99zTVGNeX7sfuz9j8/EHmg82fGz3UH1Q8WH/x6SHhIWhta21HnWFdXr1lf0gA3SBqGDy8+fOuI15HWRovGfU20puKj4Kjk6Itf4n65eyzgWPtxxvHGE4Yndp2knCxqhppXNI+2JLVIW2Nau0/5n2pvc2k7+avlr4dO656uOqNypuQs8WzB2YlzuefGzovOj1xIvNDfvqz90cXoi3c6FnZ0XQq4dOWyz+WLnczOc1dcr5y+6nz11DXGtZbrDtebb9jfOPmb/W8nuxy6mm863my95XSrrXt+99ke954Lt71uX77DvnO9N6i3+27E3fv3Ft+T3ufdH3qQ+uD1w6yH44/yH2MeFz1RfFL+VPNpze+mvzdJHaRn+rz6bjwLe/aon9v/8o+MP74MFDwnPy8f1BmsG7IZOj3sM3zrxaIXAy9FL8dHCv9U+nPXK5NXJ/7y+OvGaPTowGvx64k3m96qvT30zu5d+1jI2NP3ae/HPxR9VPtY+4nxqfNz1OfB8ewvuC8VX02/tn0L+PZ4Im1iQsQRc6ZaARSicEICAG8OAUCOAYByC+kfFk3301MCTf8DTBH4Tzzdc0+JAwCNiJlsi1jnATiKqFE+khvRyZYo3APAtrYynel9p/r0ScEifyx7vSbpwbYl+eAfMt3Df1f3Py2YzGoH/mn/BRtaBzaO17uzAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAABooAMABAAAAAEAAABUAAAAADhKLKwAAAf8SURBVHgB7V1dbttGEJ6l5Ebpk25Q5wSxTxClF4jzVsQBTKUoIPclukGUE0R+SooCDQ24Rd+inCBKLmDnBHFvIKANwiQUpzOUKROyuFxH5M7KJgGBS+7PzM7HWc7OzlIKhA/f721+UdBvANxDgE1hds7IqxNUeLIRw9MgeHEqyZOSJL778/6eiuMhgGpL8pFPGyeAXvcoeD7KL1NtjhhArDmRgg/Vdq+M1nESY3z3r+D3kzJau2wb3mUrlFWewHlZVlvVtqPanmo8q5ZGfusiAD30ex1iiX/rcnTOeLbOrwhAoOCJ9Z6uSlCIZ+sAraH2pNCKaJF1gNZSe1KIBLTIKkAP/J5Pfe2k/V3DM2nR/o5Nvq2Z2b7/y1akvDfuznlMxW7X7LaiQTwhvRrgMIhsdntvdrv7e6aQrlKuMg36iSaiTcB7oBQPCZ1VmHS47hhBBYjR+6omsnOAfL/fjrzwMWAizKsqUIexZtbIBwgw/PPl88OU0QQgdrt8VfCGLjbTjPosJwEC6XQD4S47ahOAdru9DzU4coAsozwDqbXdYNPXU+AvK1Tfk5MAKUw7huiz5yl8LMdGTVkrAQV3yMxWW9pCdaakBDpW5kGSPVx32jVAjiNYA1QD5LgEHGev6Th/OezhBFGNFCDFCeA/EXgnIbQmo2A4SSvMXE088cbb5I7ZpmWOO+s411MPuz2aE63DwRE26oA4HR8FL8bfwvED8qgraPTXCaw1AGgGzH/QGmY15FsAytbhCbqiBTjXtcptgBCelg1MFiRO0xL8gDTqyeJ9V66dBIj9UIjT+1W58BeFz++rhqPOYvfMbITDj9jatgUOg/U3eY03MCRDAkeL4Elfu6VBNKSRATCQFIprQ547GuQAOPxgJA8I8SL5kGRpu6FBiKOj4Lf7WcaK0rwCPIVwJ/ZofoPs8I03OV5gVo8sP/BOeYcCmebjDbzxOsjMkYra5nyafgR02uO05CE+UWWD4CPc7JoKId2uEsEnEp5qK2qAJqP0I4N5fjBQuEV5BBz6kQph91EvuMx2kiaG/a+qJT65FdegCOEWv6Tnss1JJBrjfXpCHoR+ThGj26RVw434Ju37Ofc65FXkiS0Fzh/n5du4L/sOorHeDByOmQiPVwWHBUrDIWlGeMyaWCTgxJIUfh+JAUSD0qmJxcYBj2UHtLD3gNtkDSkCqQnhkIbJSVG5qvLFAKJneVDUqVm0UeMVC7So7GXzuU2lGq+KNCkIgtQHeFkSpZQXAYi1Jxv7tawn/M4pW3MW6aSaxLQW87LXklokAhAZXeOsAJalp2QQVKE5i7QSkIjW4v3staQWiQCEMOVlg9yDh50yDIJcAgsZbDgUDXVUZbxQzcqldYB4eCvys9HQNrDS+wyRCKCfubyQnK1B2TcWrANUNLz5vt+mYWfvgoSqvqFwr+hdRFr9umo2Ftu3DxDE7xeZyF5/gdZO9tpeWiWuIz29+ESfX36udYAUxQ/oukGrnB1dfpV5McAdXfuk2ae6/CryrANEY722kxQIcruKjpq0qRRu6cpxcIouv4o86wAZuHY2q+ioYZta2i0IJ4btlFbMOkDFnKdLBsUlyy+hp53Mh8onqm3RQYC0/F67TOsAFZmyko5JWdrLnz3rAIUQtpezMr97Ok/ZT2hpc/SPbZasA/Sd0ltpNBnUzpOqFBDR1lpptPx89QGaIt7SCZmemLEuv9I8pbS0EeKtSukvady6BlEwh3ae04BwJPUu4OCSJTI6v6W8qw8QTQZ3znt8MTVz7cPhxZxq7yACkS6MU9B6GqrgUECDVLvo43gRqGEVndW1OQV9LNwD/1faGXEN3kFnQurohJV4GxAPdGVKzUM4KPJwKBX3S6Vp2JiABhFntPW/aD7UhM8DXjsy7Mc3F2MatNZjInzrwxt3SgYgCjiMINQKhd9FU/ocSpUgcdtMowjdZC+RwPAmCBCRNtAiHnZ4G0oVIHGb3HbR0MZC4o1efJY4hDSIu1qsRVyKl8fL1qRUc4qW3pn+w0c9K8ErTGvZIQgQsUNPpknwID/lyf6dMgwHMgh4/5GJ5iSBJGg/PiILlHhsNj/NGyQwgzlIwneyGw5gQMPOXrYj+jR/xlId0orp0AQYbouNGA4RljCts30R393AAph64TNiqptlLC99JmB/x+/3v6ftJ1S/k6zCKtjkYXNWj6JvkN4x9IE8GiLe/gs3R5fdgBx5n15SOBa1KXuIa9C8+xRqdfTHi6fza8EEv3cI4IEgC3PSsu+gORuUIIEkgsneE0i7BA533x0NSsFQatSMb3RN30lptVXP/M7hoZZ8cv6qbZVZ3x0NSnuFuGO6fyetsup5tsWF9x+5BQ73yz2AiCl68Sf/LVT1kMdawzQi2kXHNFkgrh3uDXELEmIznCAbFG1XWaimvWRgZp+gRnI3pZaftopYpvMApZJJgFIwxnh6YOIBSOtlz8kyB+0KB3QfmJTvtQEoZZjPKVgq5s+RqfccrZqdgLKGcHBKM/kea/wDeop2fPNCodvaku1jml5LgFLmr8PZSSPhOgjetI81QKaSEipXAyQkeFOyNUCmkhIqVwMkJHhTsjVAppISKlcDJCR4U7I1QKaSEirHAI2FaNdkCyWAxx75Td4WlqsLiEgAwTvw+ENBM4+xCA810RwJ0F6lD+zB92xEcObwUN/OkQCDMwX8kbNpner8SP7PDugv09SV+VcuGhzW56DopDGB8y77tf3/AaaN2gxF4Sz5AAAAAElFTkSuQmCC";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/image-upload/index.vue2.mjs
var _sfc_main57 = defineComponent57({
  __name: "index",
  props: {
    // Image source: only valid for uni-app version, web version only supports selecting images from the album.
    // album: Select from album
    // camera: Take a photo using the camera
    imageSourceType: {
      type: String,
      default: "album"
    }
  },
  setup(__props) {
    const props = __props;
    const inputRef = ref44();
    const currentConversation = ref44();
    const theme = ChatConfig.getTheme();
    const IMAGE_TOOLBAR_SHOW_MAP = {
      web_album: {
        icon: theme === "dark" ? imageIconDark : imageIconLight,
        title: "图片"
      },
      uni_album: {
        icon: imageUniIcon,
        title: "图片"
      },
      uni_camera: {
        icon: cameraUniIcon,
        title: "拍照"
      }
    };
    Jt.watch(o.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const imageToolbarForShow = computed19(() => {
      if (isUniFrameWork) {
        return props.imageSourceType === "camera" ? IMAGE_TOOLBAR_SHOW_MAP["uni_camera"] : IMAGE_TOOLBAR_SHOW_MAP["uni_album"];
      } else {
        return IMAGE_TOOLBAR_SHOW_MAP["web_album"];
      }
    });
    const onIconClick = () => {
      var _a3, _b3, _c2, _d2;
      if (isUniFrameWork) {
        if (isWeChat && ((_a3 = i) == null ? void 0 : _a3.chooseMedia)) {
          (_b3 = i) == null ? void 0 : _b3.chooseMedia({
            count: 1,
            mediaType: ["image"],
            sizeType: ["original", "compressed"],
            sourceType: [props.imageSourceType],
            // Use camera or select from album.
            success: function(res) {
              sendImageMessage(res);
            }
          });
        } else {
          (_c2 = i) == null ? void 0 : _c2.chooseImage({
            count: 1,
            sourceType: [props.imageSourceType],
            // Use camera or select from album.
            success: function(res) {
              sendImageMessage(res);
            }
          });
        }
      } else {
        if ((_d2 = inputRef.value) == null ? void 0 : _d2.click) {
          inputRef.value.click();
        }
      }
    };
    const sendImageInWeb = (e) => {
      var _a3, _b3;
      if (((_b3 = (_a3 = e == null ? void 0 : e.target) == null ? void 0 : _a3.files) == null ? void 0 : _b3.length) <= 0) {
        return;
      }
      sendImageMessage(e == null ? void 0 : e.target);
      e.target.value = "";
    };
    const sendImageMessage = (files) => {
      var _a3, _b3, _c2, _d2, _e2;
      if (!files) {
        return;
      }
      const options = {
        to: ((_b3 = (_a3 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _a3.groupProfile) == null ? void 0 : _b3.groupID) || ((_d2 = (_c2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c2.userProfile) == null ? void 0 : _d2.userID),
        conversationType: (_e2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _e2.type,
        payload: {
          file: files
        },
        needReadReceipt: isEnabledMessageReadReceiptGlobal()
      };
      const offlinePushInfoCreateParams = {
        conversation: currentConversation.value,
        payload: options.payload,
        messageType: qt.TYPES.MSG_IMAGE
      };
      const sendMessageOptions = {
        offlinePushInfo: OfflinePushInfoManager2.create(offlinePushInfoCreateParams)
      };
      Qt.sendImageMessage(options, sendMessageOptions);
    };
    return (_ctx, _cache) => {
      return openBlock56(), createBlock17(ToolbarItemContainer, {
        iconFile: unref55(imageToolbarForShow).icon,
        title: unref55(imageToolbarForShow).title,
        iconWidth: unref55(isUniFrameWork) ? "32px" : "20px",
        iconHeight: unref55(isUniFrameWork) ? "25px" : "18px",
        needDialog: false,
        onOnIconClick: onIconClick
      }, {
        default: withCtx14(() => [
          !unref55(isUniFrameWork) ? (openBlock56(), createElementBlock53("div", {
            key: 0,
            class: normalizeClass39(["image-upload", !unref55(isPC) && "image-upload-h5"])
          }, [
            createElementVNode39("input", {
              ref_key: "inputRef",
              ref: inputRef,
              title: "图片",
              type: "file",
              "data-type": "image",
              accept: "image/gif,image/jpeg,image/jpg,image/png,image/bmp,image/webp",
              onChange: sendImageInWeb
            }, null, 544)
          ], 2)) : createCommentVNode39("", true)
        ]),
        _: 1
      }, 8, ["iconFile", "title", "iconWidth", "iconHeight"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/image-upload/index.vue.mjs
var ImageUpload = _export_sfc(_sfc_main57, [["__scopeId", "data-v-f41fc267"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/file-upload/index.vue2.mjs
import { defineComponent as defineComponent58, ref as ref45, createBlock as createBlock18, openBlock as openBlock57, unref as unref56, withCtx as withCtx15, createElementVNode as createElementVNode40, normalizeClass as normalizeClass40 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/file-dark.svg.mjs
var fileIconDark = "data:image/svg+xml,%3csvg%20width='16'%20height='14'%20viewBox='0%200%2016%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%202'%20opacity='0.795169'%3e%3cpath%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20d='M0.5%202.25C0.5%201.2835%201.2835%200.5%202.25%200.5H6.54211C6.62301%200.5%206.70271%200.519631%206.77435%200.557208L8.63621%201.53374C8.85115%201.64647%209.09023%201.70536%209.33293%201.70536H13.75C14.7165%201.70536%2015.5%202.48886%2015.5%203.45536V11.75C15.5%2012.7165%2014.7165%2013.5%2013.75%2013.5H2.25C1.2835%2013.5%200.5%2012.7165%200.5%2011.75V2.25Z'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'%20/%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;_2'%20x='0.5'%20y='3.5'%20width='15'%20height='10'%20rx='1.75'%20stroke='%23D5E0F2'%20style='fill-opacity:1;stroke:%23D5E0F2;'%20/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/file-upload/index.vue2.mjs
var _sfc_main58 = defineComponent58({
  __name: "index",
  setup(__props) {
    const fileIcon = ChatConfig.getTheme() === "dark" ? fileIconDark : fileIconLight;
    const inputRef = ref45();
    const currentConversation = ref45();
    Jt.watch(o.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const onIconClick = () => {
      var _a3, _b3;
      if (isUniFrameWork) {
        return;
      } else {
        ((_a3 = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a3.click) && ((_b3 = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _b3.click());
      }
    };
    const sendFileMessage = (e) => {
      var _a3, _b3, _c2, _d2, _e2, _f2, _g;
      if (((_b3 = (_a3 = e == null ? void 0 : e.target) == null ? void 0 : _a3.files) == null ? void 0 : _b3.length) <= 0) {
        return;
      }
      const options = {
        to: ((_d2 = (_c2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c2.groupProfile) == null ? void 0 : _d2.groupID) || ((_f2 = (_e2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _e2.userProfile) == null ? void 0 : _f2.userID),
        conversationType: (_g = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _g.type,
        payload: {
          file: e == null ? void 0 : e.target
        },
        needReadReceipt: isEnabledMessageReadReceiptGlobal()
      };
      const offlinePushInfoCreateParams = {
        conversation: currentConversation.value,
        payload: options.payload,
        messageType: qt.TYPES.MSG_FILE
      };
      const sendMessageOptions = {
        offlinePushInfo: OfflinePushInfoManager2.create(offlinePushInfoCreateParams)
      };
      Qt.sendFileMessage(options, sendMessageOptions);
      e.target.value = "";
    };
    return (_ctx, _cache) => {
      return openBlock57(), createBlock18(ToolbarItemContainer, {
        iconFile: unref56(fileIcon),
        title: "文件",
        iconWidth: unref56(isUniFrameWork) ? "32px" : "20px",
        iconHeight: unref56(isUniFrameWork) ? "25px" : "18px",
        needDialog: false,
        onOnIconClick: onIconClick
      }, {
        default: withCtx15(() => [
          createElementVNode40("div", {
            class: normalizeClass40(["file-upload", !unref56(isPC) && "file-upload-h5"])
          }, [
            createElementVNode40("input", {
              ref_key: "inputRef",
              ref: inputRef,
              title: "文件",
              type: "file",
              "data-type": "file",
              accept: "*",
              onChange: sendFileMessage
            }, null, 544)
          ], 2)
        ]),
        _: 1
      }, 8, ["iconFile", "iconWidth", "iconHeight"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/file-upload/index.vue.mjs
var FileUpload = _export_sfc(_sfc_main58, [["__scopeId", "data-v-efb1fc25"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/video-upload/index.vue2.mjs
import { defineComponent as defineComponent59, ref as ref46, createBlock as createBlock19, openBlock as openBlock58, unref as unref57, withCtx as withCtx16, createElementVNode as createElementVNode41, normalizeClass as normalizeClass41 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/video-light.svg.mjs
var videoIconLight = "data:image/svg+xml,%3csvg%20width='16'%20height='14'%20viewBox='0%200%2016%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;'%20opacity='0.795169'%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20x='0.5'%20y='0.5'%20width='15'%20height='13'%20rx='1.75'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'%20/%3e%3cpath%20id='&%23228;&%23184;&%23137;&%23232;&%23167;&%23146;&%23229;&%23189;&%23162;'%20d='M10.0282%207L6.5%209.1169L6.5%204.8831L10.0282%207Z'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'%20/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/video-dark.svg.mjs
var videoIconDark = "data:image/svg+xml,%3csvg%20width='16'%20height='14'%20viewBox='0%200%2016%2014'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;'%20opacity='0.795169'%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20x='0.5'%20y='0.5'%20width='15'%20height='13'%20rx='1.75'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'%20/%3e%3cpath%20id='&%23228;&%23184;&%23137;&%23232;&%23167;&%23146;&%23229;&%23189;&%23162;'%20d='M10.0282%207L6.5%209.1169L6.5%204.8831L10.0282%207Z'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'%20/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/video-uni.png.mjs
var videoUniIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAABKCAYAAABjAdCAAAAKrWlDQ1BJQ0MgUHJvZmlsZQAASImVlwdQU1kXgO976SGhJUQ6oTdBOgGkhNACCEgHGyEJEEqIgQAiKiqLK7iiiIigougqRcG1ALJWRLEtCopdN8gioKyLBRsq/wOG4O4////Pf2bOnO+dd+6559659815AJAVOSJRKqwIQJowUxzq60mPjoml4wYBGsgDGlADthxuhogZEhIIEJmxf5f3dwE0aW9bTOb69/f/VZR4/AwuAFAIwvG8DG4awicQfcEViTMBQO1F/PrZmaJJ7kCYKkYKRPj+JCdO88gkx08xGkzFhIeyEKYCgCdxOOJEAEh0xE/P4iYieUgeCFsJeQIhwiKE3dLS0nkIH0XYBIlBfKTJ/Iz47/Ik/i1nvCwnh5Mo4+m1TAneS5AhSuWs+D+3439LWqpkZg4jRElJYr9QxCoje3Y/JT1AxsL4oOAZFvCm4qc4SeIXMcPcDFbsDPM4XgGysalBgTOcIPBhy/JkssNnmJ/hHTbD4vRQ2VwJYhZzhjni2XklKREyfxKfLcufmxQeNcNZgsigGc5ICQuYjWHJ/GJJqKx+vtDXc3ZeH9na0zK+W6+ALRubmRTuJ1s7Z7Z+vpA5mzMjWlYbj+/lPRsTIYsXZXrK5hKlhsji+am+Mn9GVphsbCZyIGfHhsj2MJnjHzLDgAXSQSqiYkAHgciTFwCZ/JzMyYWw0kUrxILEpEw6E7lhfDpbyLWcS7exsrEFYPK+Th+Ht7SpewjRrs361hMBcBVOTEycnvUFfAbghC4AROmsz7gHAHnk3F/ZypWIs6Z9U3cJA4hAAVCRL4E20AcmwALYAAfgAjyAN/AHwSAcxIClgAuSQBpSeTbIA2tBISgGW8B2UAmqwX5QC46AY6AFnAYXwGVwHdwCveARkIIB8BKMgvdgHIIgHESGKJAapAMZQuaQDcSA3CBvKBAKhWKgOCgREkISKA9aDxVDpVAltA+qg36BTkEXoKtQN/QA6oOGoTfQZxgFk2AqrAUbwfNgBsyEA+BweAmcCC+Hc+ECeDNcAdfAh+Fm+AJ8He6FpfBLeAwFUHIoGkoXZYFioFioYFQsKgElRq1GFaHKUTWoRlQbqhN1GyVFjaA+obFoCpqOtkC7oP3QEWguejl6NXoTuhJdi25Gd6Bvo/vQo+hvGDJGE2OOccawMdGYREw2phBTjjmIOYm5hOnFDGDeY7FYGtYY64j1w8Zgk7ErsZuwu7FN2PPYbmw/dgyHw6nhzHGuuGAcB5eJK8TtxB3GncP14AZwH/FyeB28Dd4HH4sX4tfhy/H1+LP4HvwgfpygSDAkOBOCCTzCCkIJ4QChjXCTMEAYJyoRjYmuxHBiMnEtsYLYSLxEfEx8KycnpyfnJLdQTiCXL1chd1Tuilyf3CeSMsmMxCItJklIm0mHSOdJD0hvyWSyEdmDHEvOJG8m15Evkp+SP8pT5C3l2fI8+TXyVfLN8j3yrxQICoYKTIWlCrkK5QrHFW4qjCgSFI0UWYocxdWKVYqnFO8pjilRlKyVgpXSlDYp1StdVRpSxikbKXsr85QLlPcrX1Tup6Ao+hQWhUtZTzlAuUQZoGKpxlQ2NZlaTD1C7aKOqiir2KlEquSoVKmcUZHSUDQjGpuWSiuhHaPdpX2eozWHOYc/Z+Ocxjk9cz6oaqh6qPJVi1SbVHtVP6vR1bzVUtS2qrWoPVFHq5upL1TPVt+jfkl9RIOq4aLB1SjSOKbxUBPWNNMM1VypuV/zhuaYlraWr5ZIa6fWRa0RbZq2h3aydpn2We1hHYqOm45Ap0znnM4LugqdSU+lV9A76KO6mrp+uhLdfbpduuN6xnoReuv0mvSe6BP1GfoJ+mX67fqjBjoGCwzyDBoMHhoSDBmGSYY7DDsNPxgZG0UZbTBqMRoyVjVmG+caNxg/NiGbuJssN6kxuWOKNWWYppjuNr1lBpvZmyWZVZndNIfNHcwF5rvNu+di5jrNFc6tmXvPgmTBtMiyaLDos6RZBlqus2yxfDXPYF7svK3zOud9s7K3SrU6YPXIWtna33qddZv1GxszG65Nlc0dW7Ktj+0a21bb13bmdny7PXb37Sn2C+w32Lfbf3VwdBA7NDoMOxo4xjnucrzHoDJCGJsYV5wwTp5Oa5xOO31ydnDOdD7m/JeLhUuKS73L0Hzj+fz5B+b3u+q5clz3uUrd6G5xbnvdpO667hz3GvdnHvoePI+DHoNMU2Yy8zDzlaeVp9jzpOcHljNrFeu8F8rL16vIq8tb2TvCu9L7qY+eT6JPg8+or73vSt/zfhi/AL+tfvfYWmwuu4496u/ov8q/I4AUEBZQGfAs0CxQHNi2AF7gv2DbgsdBhkHCoJZgEMwO3hb8JMQ4ZHnIrwuxC0MWVi18HmodmhfaGUYJWxZWH/Y+3DO8JPxRhEmEJKI9UiFycWRd5Icor6jSKGn0vOhV0ddj1GMEMa2xuNjI2IOxY4u8F21fNLDYfnHh4rtLjJfkLLm6VH1p6tIzyxSWcZYdj8PERcXVx33hBHNqOGPx7Phd8aNcFncH9yXPg1fGG+a78kv5gwmuCaUJQ4muidsSh5Pck8qTRgQsQaXgdbJfcnXyh5TglEMpE6lRqU1p+LS4tFNCZWGKsCNdOz0nvVtkLioUSZc7L9++fFQcID6YAWUsyWjNpCKN0Q2JieQHSV+WW1ZV1sfsyOzjOUo5wpwbK8xWbFwxmOuT+/NK9EruyvY83by1eX2rmKv2rYZWx69uX6O/pmDNQL5vfu1a4tqUtb+ts1pXuu7d+qj1bQVaBfkF/T/4/tBQKF8oLry3wWVD9Y/oHwU/dm203bhz47ciXtG1Yqvi8uIvm7ibrv1k/VPFTxObEzZ3lTiU7NmC3SLccner+9baUqXS3NL+bQu2NZfRy4rK3m1ftv1quV159Q7iDskOaUVgRetOg51bdn6pTKrsrfKsatqluWvjrg+7ebt79njsaazWqi6u/rxXsPf+Pt99zTVGNeX7sfuz9j8/EHmg82fGz3UH1Q8WH/x6SHhIWhta21HnWFdXr1lf0gA3SBqGDy8+fOuI15HWRovGfU20puKj4Kjk6Itf4n65eyzgWPtxxvHGE4Yndp2knCxqhppXNI+2JLVIW2Nau0/5n2pvc2k7+avlr4dO656uOqNypuQs8WzB2YlzuefGzovOj1xIvNDfvqz90cXoi3c6FnZ0XQq4dOWyz+WLnczOc1dcr5y+6nz11DXGtZbrDtebb9jfOPmb/W8nuxy6mm863my95XSrrXt+99ke954Lt71uX77DvnO9N6i3+27E3fv3Ft+T3ufdH3qQ+uD1w6yH44/yH2MeFz1RfFL+VPNpze+mvzdJHaRn+rz6bjwLe/aon9v/8o+MP74MFDwnPy8f1BmsG7IZOj3sM3zrxaIXAy9FL8dHCv9U+nPXK5NXJ/7y+OvGaPTowGvx64k3m96qvT30zu5d+1jI2NP3ae/HPxR9VPtY+4nxqfNz1OfB8ewvuC8VX02/tn0L+PZ4Im1iQsQRc6ZaARSicEICAG8OAUCOAYByC+kfFk3301MCTf8DTBH4Tzzdc0+JAwCNiJlsi1jnATiKqFE+khvRyZYo3APAtrYynel9p/r0ScEifyx7vSbpwbYl+eAfMt3Df1f3Py2YzGoH/mn/BRtaBzaO17uzAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAABwoAMABAAAAAEAAABKAAAAABbb06wAAATXSURBVHgB7Z1Bb9RGFMffcxYJTg3fINBzaRT1wDHpF0i4IRRak1Zq6IWlN07ZHHsqOSAWVLFGJKiIS/oJSu5Vu+ILJHwCckAKKV4/3hhWjZM16xnPs3H2WYo2Hs+8//j/y4zHMxsb4di2HK7OJwhLUwCLBDBz7PAE79I+APYJMDpDtBNF3b3PwQwcViIM29OD4GCNCNvDNP0c7QB7tAsI61u9+49H56gulRsagIH3Dg//4l+XqpNurhIinOe//MVLc9/Ay3//3qnzTAIjbloeAs3WWZEGarNlsGYuOXXWPQjD1RntNp0RIF8THzmX9lAweIfQ8RBnYkMg0kydrTDgfuDriXXfz4nzJZEW/YSyj8LXQNRrn71vmRIDgi8yCRXupIOYCvVUyrMDCtCzoVWHU4BVO+5ZTwF6NrTqcK2qBVWvnAPpLUuAt3jwSa0k+UUBlvOzstL/z1VDG4iXGXgaKOZ7UAVYGQJ3oeUffroVJwcdIJzORsFZJ4A8fdRHotsxwF424Mm9AAbTAQY9vd886c24lLS7RFiDBObz8joBHBBd+cNiPSwMw4UYz77Oq4SmZx3IdJfZQyf2nEahNvCMYhRF+yeUNWGkA2l3iQe7RRcYnFrgSGVNLOWA6S4J8TdI7Jb1FGAp28sXNst5H1eEvjcLjLabArR1zGP+5ZXVtZiojXB8dFlcRAEW98pbzmvf/byAU8kjbnAzPDovFVcBlrLPrvD16z9eoFaLV/CTebuS+bmdRqH54fRIngPXwtWQWlP/8PH5vDwu6QrQxTX7Mrxqb8C5X+vyJBVgnjMNSXcCaGYKGnJ+p76aTgDj4C0vZxTfzHC5eG7NaeOA2yiUoLN84+YSL2kUmCLjfp/sZhdsTmDS87oBTF0rCsV+dmHSodicv1MXaiOgeWUdUICy/opHV4DiFssKKEBZf8WjK0Bxi2UFFKCsv+LRFaC4xbICClDWX/HoClDcYlkBBSjrr3h0BShusayAApT1Vzy6AhS3WFZAAcr6Kx5dAYpbLCugAGX9FY+uAMUtlhVQgLL+ikdXgOIWywooQFl/xaMrQHGLUwH6bxCv89e79nzLKUDfjubEe/7k992tXvdCQnAjfeJvTj7bZAVo61jJ/E+jbjQA+pafFPKYQ5X+zqUCLAnEpbh5xsBW1A25Na6UbY0K0IWApzLD1sjfXN/gkE6tUQF6guEaxrTGzehB+zCOv3RpjQrQ1XnP5dJBTnT/IrfDdQ5duDUqQM8gyobbjLqdmOAix3nBP2NBKsCyjguUT7vVXnehyCBHAQoA8BVyOMj51C2HAvTltlCcT95yIO0rQCHjfYc1rfEMHMwdueUgSHCjxD94+q6ixhvnwMeHBraXwnbH5N2O7u4rwHGufYbHDbhhtbQLHTrR0E8F2FBww2orwKETDf3kl1/5X2RsqBfO1Q4QXzkXLlkwIKI/S8aY9OJmumunLhO4C8XtusRPgy6vIPBqQvdFXecSpOIf1qPqqkOTdZlfcLvOE0gHMS047PDEd7/OijRQm8zSz9PevVovQelbrPv9/tu52a+eJTB1DhAvN9DMKqvM7z3hZ8RRcmczevhrlcKjtHgQmt2u8lPUmWonfTUrnrq3e45dX8u6cWSPofEbj/vcZ+68gbMbR2dDjuSq/Nf34xBPYE0I6N4AAAAASUVORK5CYII=";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/video-upload/index.vue2.mjs
var _sfc_main59 = defineComponent59({
  __name: "index",
  props: {
    // Video source, only valid for uni-app version, web version only supports selecting videos from files
    // album: Select from files
    // camera: Take a video using the camera
    videoSourceType: {
      type: String,
      default: "album"
    }
  },
  setup(__props) {
    const props = __props;
    const inputRef = ref46();
    const currentConversation = ref46();
    Jt.watch(o.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const handleIcon = () => {
      if (isUniFrameWork) {
        switch (props.videoSourceType) {
          case "album":
            return videoUniIcon;
          case "camera":
            return cameraUniIcon;
          default:
            return videoUniIcon;
        }
      } else {
        const videoIcon = ChatConfig.getTheme() === "dark" ? videoIconDark : videoIconLight;
        return videoIcon;
      }
    };
    const handleTitle = () => {
      if (isUniFrameWork && props.videoSourceType === "camera") {
        return "录制";
      } else {
        return "视频";
      }
    };
    const onIconClick = () => {
      var _a3, _b3, _c2, _d2, _e2;
      if (isUniFrameWork) {
        if (isWeChat && ((_a3 = i) == null ? void 0 : _a3.chooseMedia)) {
          (_b3 = i) == null ? void 0 : _b3.chooseMedia({
            mediaType: ["video"],
            count: 1,
            sourceType: [props.videoSourceType],
            maxDuration: 60,
            success: function(res) {
              sendVideoMessage(res);
            }
          });
        } else {
          (_c2 = i) == null ? void 0 : _c2.chooseVideo({
            count: 1,
            sourceType: [props.videoSourceType],
            compressed: false,
            success: function(res) {
              sendVideoMessage(res);
            }
          });
        }
      } else {
        ((_d2 = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _d2.click) && ((_e2 = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _e2.click());
      }
    };
    const sendVideoInWeb = (e) => {
      var _a3, _b3;
      if (((_b3 = (_a3 = e == null ? void 0 : e.target) == null ? void 0 : _a3.files) == null ? void 0 : _b3.length) <= 0) {
        return;
      }
      sendVideoMessage(e == null ? void 0 : e.target);
      e.target.value = "";
    };
    const sendVideoMessage = (file) => {
      var _a3, _b3, _c2, _d2, _e2;
      if (!file) {
        return;
      }
      const options = {
        to: ((_b3 = (_a3 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _a3.groupProfile) == null ? void 0 : _b3.groupID) || ((_d2 = (_c2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c2.userProfile) == null ? void 0 : _d2.userID),
        conversationType: (_e2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _e2.type,
        payload: {
          file
        },
        needReadReceipt: isEnabledMessageReadReceiptGlobal()
      };
      const offlinePushInfoCreateParams = {
        conversation: currentConversation.value,
        payload: options.payload,
        messageType: qt.TYPES.MSG_VIDEO
      };
      const sendMessageOptions = {
        offlinePushInfo: OfflinePushInfoManager2.create(offlinePushInfoCreateParams)
      };
      Qt.sendVideoMessage(options, sendMessageOptions);
    };
    return (_ctx, _cache) => {
      return openBlock58(), createBlock19(ToolbarItemContainer, {
        iconFile: handleIcon(),
        title: handleTitle(),
        needDialog: false,
        iconWidth: unref57(isUniFrameWork) ? "32px" : "20px",
        iconHeight: unref57(isUniFrameWork) ? props.videoSourceType === "album" ? "20px" : "25px" : "18px",
        onOnIconClick: onIconClick
      }, {
        default: withCtx16(() => [
          createElementVNode41("div", {
            class: normalizeClass41(["video-upload", !unref57(isPC) && "video-upload-h5"])
          }, [
            createElementVNode41("input", {
              ref_key: "inputRef",
              ref: inputRef,
              title: "视频",
              type: "file",
              "data-type": "video",
              accept: "video/*",
              onChange: sendVideoInWeb
            }, null, 544)
          ], 2)
        ]),
        _: 1
      }, 8, ["iconFile", "title", "iconWidth", "iconHeight"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/video-upload/index.vue.mjs
var VideoUpload = _export_sfc(_sfc_main59, [["__scopeId", "data-v-69ead8fb"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/evaluate/index.vue2.mjs
import { defineComponent as defineComponent60, ref as ref47, computed as computed20, createBlock as createBlock20, openBlock as openBlock59, unref as unref58, withCtx as withCtx17, createElementVNode as createElementVNode42, normalizeClass as normalizeClass42, createElementBlock as createElementBlock54, createCommentVNode as createCommentVNode40, toDisplayString as toDisplayString39, withModifiers as withModifiers13, withDirectives as withDirectives5, Fragment as Fragment18, renderList as renderList15, isRef, vModelText, createTextVNode as createTextVNode3 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/evalute-light.svg.mjs
var evaluateIconLight = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%204'%20opacity='0.795169'%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20x='1.5'%20y='14.5'%20width='13'%20height='13'%20rx='1.75'%20transform='rotate(-90%201.5%2014.5)'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'/%3e%3cpath%20id='&%23230;&%23152;&%23159;&%23229;&%23189;&%23162;'%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8.09307%2010.0489C8.0348%2010.0183%207.9652%2010.0183%207.90693%2010.0489L6.00755%2011.0475C5.86083%2011.1246%205.68934%2011%205.71736%2010.8367L6.08011%208.72167C6.09124%208.65679%206.06973%208.59059%206.02259%208.54464L4.48596%207.0468C4.36726%206.93109%204.43276%206.7295%204.59681%206.70566L6.72038%206.39709C6.78552%206.38762%206.84183%206.34671%206.87096%206.28768L7.82065%204.3634C7.89402%204.21475%208.10598%204.21475%208.17935%204.3634L9.12904%206.28768C9.15817%206.34671%209.21448%206.38762%209.27962%206.39709L11.4032%206.70566C11.5672%206.7295%2011.6327%206.93109%2011.514%207.0468L9.97741%208.54464C9.93027%208.59059%209.90876%208.65679%209.91989%208.72167L10.2826%2010.8367C10.3107%2011%2010.1392%2011.1246%209.99245%2011.0475L8.09307%2010.0489Z'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/evalute-dark.svg.mjs
var evaluateIconDark = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%204'%20opacity='0.795169'%3e%3crect%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20x='1.5'%20y='14.5'%20width='13'%20height='13'%20rx='1.75'%20transform='rotate(-90%201.5%2014.5)'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'/%3e%3cpath%20id='&%23230;&%23152;&%23159;&%23229;&%23189;&%23162;'%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M8.09307%2010.0489C8.0348%2010.0183%207.9652%2010.0183%207.90693%2010.0489L6.00755%2011.0475C5.86083%2011.1246%205.68934%2011%205.71736%2010.8367L6.08011%208.72167C6.09124%208.65679%206.06973%208.59059%206.02259%208.54464L4.48596%207.0468C4.36726%206.93109%204.43276%206.7295%204.59681%206.70566L6.72038%206.39709C6.78552%206.38762%206.84183%206.34671%206.87096%206.28768L7.82065%204.3634C7.89402%204.21475%208.10598%204.21475%208.17935%204.3634L9.12904%206.28768C9.15817%206.34671%209.21448%206.38762%209.27962%206.39709L11.4032%206.70566C11.5672%206.7295%2011.6327%206.93109%2011.514%207.0468L9.97741%208.54464C9.93027%208.59059%209.90876%208.65679%209.91989%208.72167L10.2826%2010.8367C10.3107%2011%2010.1392%2011.1246%209.99245%2011.0475L8.09307%2010.0489Z'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/utils/documentLink.mjs
var Link2 = {
  product: {
    label: "产品文档",
    url: "https://cloud.tencent.com/document/product/269/1499#.E7.BE.A4.E7.BB.84.E5.8A.9F.E8.83.BD"
  },
  customMessage: {
    label: "自定义消息",
    url: "https://web.sdk.qcloud.com/im/doc/v3/zh-cn/SDK.html#createCustomMessage"
  },
  complaint: {
    label: "点此投诉",
    url: "https://cloud.tencent.com/apply/p/xc3oaubi98g"
  },
  implement: {
    label: "集成TUICallKit",
    url: "https://cloud.tencent.com/document/product/269/79861"
  },
  purchase: {
    label: "开通腾讯实时音视频服务",
    url: "https://cloud.tencent.com/document/product/1640/79968"
  }
};

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/star.png.mjs
var starIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAABMCAYAAADHl1ErAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAATvSURBVHgB7ZxhUttGFMffW8mJM8lMnS8FGTPIuUDdnoCcoL1B3V4gQw9QzAVa2gsUTtD0BM0RyAmsGaAq6Qf0hY5rW7vdR6zYGGykXUm7sv2b0QBm7JF+/ktP2qcVwIZqE4b/HF6GH65pod/BMhAs4iIMuwjst9nXUIiDZnP7GCzBKmGX4VVf/vDnXo6Gg3/bkggsgIElULrgviyiUXv6rAuWYI0wuSsuPF4h4huwBCuELUlXgh+GV9+CBVghbFm6EjhADyzAuLAU6Urwz8NwHwxjXFiadCU44Bg/LzMqLEO6bhEg9k2nzKgwFCxz9TOdMmPCzs9lUhA6kBHTKTMmzHHVk2IyZUaEUbooKaCIyZQZEcYcpn3mbiplpV98h2Hoc2B9yAEO/PWu572DEik9YTFnPcgJEykrNWF5piuh7JSVmrA805XAwCn1ory0hBWRrgQGvO15XgAlUFrCikhXAi/xWFZKwopMV4Icxn5ZxjB24QkjWQLdn6Fgnj57cXhx8SHzpVZWckkYSRmNeMd9UtuLx7ztuLgnxO11og8mEHAmh7WjOObvHZf141H83nUhyOM4l1pYv99v1GrPfXk06gjADnPgM/n2fbk05Bo2oCqQTAYByUQBgfxig/F4cJZ2d74j7I4UBJ8x3AOBHdmF8CslRQmMpIwzOeZ0m0wR8zPGasFodBPMykSSVK+/eCNPALtgaheyHiRhb4eDmwO8uLw6kRG1oiNjO4jwFmW3WcCGtERsErcN6YiYEOMj2JAK2Rs9Za1m81ge8DfSHkHKOtr1tnqfTivkkG+PZegRrhOJLPr9znnYRtp9ZmUR9870N9KmzMsiHrw02kh7WBax8FpynaUtkkUsvfheR2nLZBGPjlask7THZBGphnfWQVoaWUTq8bBVlpZWFpFpxHUVpWWRRWQeol4laVllEUpj+qsgTUUWodwEqbI0VVmEVteoitJ0ZBHabbYqSdOVReTSl7z86+/f5YD3N2AzQvyx09zWXsdcOt+IbMVbcFNyESa7KIW36LVB/AJyQFtYv39dlc63Tz1Y0ERbmOsO7E/XhNpz6urroS0MHayMMD6MtddVW5io0O0FCGhemIMsl4NpGTCm/+XmkbDK7JJUKYXQuzNCS1iFKmSCHwSB1vpqCatShUzQrZRawqpUIRN0K6WWsCpVyATdSqklrEoVMsFx9NZZN2GV2yUFiI5OpVQWVnCFDCZLETR0KqWysGIqJEby2z/Y8bbatAjg30EB4tx6XXndlYXlWyExopv6hoObdmvm0VctzzshcZMb/gLICRRYvrB8KuRU1K7n9RZNLqD/MeCvBeenkAOCq6+7sjD9CilOGMRfLhM1C017ae14XZrqpytOp1Iqj+nTI/dUDvqySr2Ty5HuLFqa3xRzOETGaI5B1u2Imtufv0TMvvlKwqhCPqkPr7O8Jy9R89DjGJhgP00eGpJ6e1SnCyrtkhkrZEDzslvediFzs+kzd5pbX8mK+r38k+ZkpjrJUq2USsLSVUikWRNdqnJlTGKfVNRXacWpVkolYfJcacmxa1r5PG8rl6qWhU/iRPwDfBT3IMu3YTGqN6Psy273n3MfJUXFv4wHg+MyphKngQrDWKZcruuPcHdbhay2r1QmnCpXyckzVw9pgimPx6fj0X89W0TNM62oztfSFV1N/Nqy6NmwK83/UkAsIDt3h2wAAAAASUVORK5CYII=";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/evaluate/index.vue2.mjs
var _hoisted_151 = ["onClick"];
var _sfc_main60 = defineComponent60({
  __name: "index",
  props: {
    starTotal: {
      type: Number,
      default: 5
    }
  },
  emits: ["onDialogPopupShowOrHide"],
  setup(__props, { emit: __emit }) {
    const evaluateIcon = ChatConfig.getTheme() === "dark" ? evaluateIconDark : evaluateIconLight;
    const props = __props;
    const emits = __emit;
    const container = ref47();
    const starList = ref47(props.starTotal);
    const currentStarIndex = ref47(-1);
    const comment = ref47("");
    const currentConversation = ref47();
    Jt.watch(o.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const isEvaluateValid = computed20(() => comment.value.length || currentStarIndex.value >= 0);
    const onDialogShow = () => {
      emits("onDialogPopupShowOrHide", true);
    };
    const onDialogClose = () => {
      resetEvaluate();
      emits("onDialogPopupShowOrHide", false);
    };
    const openLink = () => {
      var _a3, _b3;
      if (isPC || isH5) {
        window.open((_b3 = (_a3 = Link2) == null ? void 0 : _a3.customMessage) == null ? void 0 : _b3.url);
      }
    };
    const closeDialog = () => {
      var _a3;
      (_a3 = container == null ? void 0 : container.value) == null ? void 0 : _a3.toggleDialogDisplay(false);
    };
    const resetEvaluate = () => {
      currentStarIndex.value = -1;
      comment.value = "";
    };
    const selectStar = (starIndex) => {
      if (currentStarIndex.value === starIndex) {
        currentStarIndex.value = currentStarIndex.value - 1;
      } else {
        currentStarIndex.value = starIndex;
      }
    };
    const submitEvaluate = () => {
      var _a3, _b3, _c2, _d2, _e2, _f2;
      if (currentStarIndex.value < 0 && !comment.value.length) {
        return;
      }
      const payload = {
        data: JSON.stringify({
          businessID: CHAT_MSG_CUSTOM_TYPE.EVALUATE,
          version: 1,
          score: currentStarIndex.value + 1,
          comment: comment.value
        }),
        description: "对本次的服务评价",
        extension: "对本次的服务评价"
      };
      const options = {
        to: ((_b3 = (_a3 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _a3.groupProfile) == null ? void 0 : _b3.groupID) || ((_d2 = (_c2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c2.userProfile) == null ? void 0 : _d2.userID),
        conversationType: (_e2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _e2.type,
        payload,
        needReadReceipt: isEnabledMessageReadReceiptGlobal()
      };
      const offlinePushInfoCreateParams = {
        conversation: currentConversation.value,
        payload: options.payload,
        messageType: qt.TYPES.MSG_CUSTOM
      };
      const sendMessageOptions = {
        offlinePushInfo: OfflinePushInfoManager2.create(offlinePushInfoCreateParams)
      };
      Qt.sendCustomMessage(options, sendMessageOptions);
      (_f2 = container == null ? void 0 : container.value) == null ? void 0 : _f2.toggleDialogDisplay(false);
    };
    return (_ctx, _cache) => {
      return openBlock59(), createBlock20(ToolbarItemContainer, {
        ref_key: "container",
        ref: container,
        iconFile: unref58(evaluateIcon),
        title: "评价",
        needBottomPopup: true,
        iconWidth: unref58(isUniFrameWork) ? "26px" : "20px",
        iconHeight: unref58(isUniFrameWork) ? "26px" : "20px",
        onOnDialogShow: onDialogShow,
        onOnDialogClose: onDialogClose
      }, {
        default: withCtx17(() => [
          createElementVNode42("div", {
            class: normalizeClass42(["evaluate", !unref58(isPC) && "evaluate-h5"])
          }, [
            createElementVNode42("div", {
              class: normalizeClass42(["evaluate-header", !unref58(isPC) && "evaluate-h5-header"])
            }, [
              createElementVNode42("div", {
                class: normalizeClass42([
                  "evaluate-header-content",
                  !unref58(isPC) && "evaluate-h5-header-content"
                ])
              }, toDisplayString39(unref58(Wt).t("Evaluate.请对本次服务进行评价")), 3),
              !unref58(isPC) ? (openBlock59(), createElementBlock54("div", {
                key: 0,
                class: normalizeClass42([
                  "evaluate-header-close",
                  !unref58(isPC) && "evaluate-h5-header-close"
                ]),
                onClick: withModifiers13(closeDialog, ["stop"])
              }, toDisplayString39(unref58(Wt).t("关闭")), 3)) : createCommentVNode40("", true)
            ], 2),
            createElementVNode42("div", {
              class: normalizeClass42(["evaluate-content", !unref58(isPC) && "evaluate-h5-content"])
            }, [
              createElementVNode42("ul", {
                class: normalizeClass42([
                  "evaluate-content-list",
                  !unref58(isPC) && "evaluate-h5-content-list"
                ])
              }, [
                (openBlock59(true), createElementBlock54(Fragment18, null, renderList15(unref58(starList), (item, index3) => {
                  return openBlock59(), createElementBlock54("li", {
                    key: index3,
                    class: normalizeClass42([
                      "evaluate-content-list-item",
                      !unref58(isPC) && "evaluate-h5-content-list-item"
                    ]),
                    onClick: withModifiers13(($event) => selectStar(index3), ["stop"])
                  }, [
                    index3 <= unref58(currentStarIndex) ? (openBlock59(), createBlock20(Icon, {
                      key: 0,
                      file: unref58(starLightIcon),
                      width: unref58(isPC) ? "20px" : "30px",
                      height: unref58(isPC) ? "20px" : "30px"
                    }, null, 8, ["file", "width", "height"])) : (openBlock59(), createBlock20(Icon, {
                      key: 1,
                      file: unref58(starIcon),
                      width: unref58(isPC) ? "20px" : "30px",
                      height: unref58(isPC) ? "20px" : "30px"
                    }, null, 8, ["file", "width", "height"]))
                  ], 10, _hoisted_151);
                }), 128))
              ], 2),
              withDirectives5(createElementVNode42("textarea", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(comment) ? comment.value = $event : null),
                class: normalizeClass42([
                  "evaluate-content-text",
                  !unref58(isPC) && "evaluate-h5-content-text"
                ])
              }, null, 2), [
                [vModelText, unref58(comment)]
              ]),
              createElementVNode42("div", {
                class: normalizeClass42([
                  "evaluate-content-button",
                  !unref58(isPC) && "evaluate-h5-content-button"
                ])
              }, [
                createElementVNode42("button", {
                  class: normalizeClass42(["btn", unref58(isEvaluateValid) ? "btn-valid" : "btn-invalid"]),
                  onClick: submitEvaluate
                }, toDisplayString39(unref58(Wt).t("Evaluate.提交评价")), 3)
              ], 2)
            ], 2),
            createElementVNode42("div", {
              class: normalizeClass42(["evaluate-adv", !unref58(isPC) && "evaluate-h5-adv"])
            }, [
              createTextVNode3(toDisplayString39(unref58(Wt).t("Evaluate.服务评价工具")) + " " + toDisplayString39("(" + unref58(Wt).t("Evaluate.使用")) + " ", 1),
              createElementVNode42("a", {
                onClick: _cache[1] || (_cache[1] = ($event) => openLink(unref58(Link2).customMessage))
              }, toDisplayString39(unref58(Wt).t(`Evaluate.${unref58(Link2).customMessage.label}`)), 1),
              createTextVNode3(" " + toDisplayString39(unref58(Wt).t("Evaluate.搭建") + ")"), 1)
            ], 2)
          ], 2)
        ]),
        _: 1
      }, 8, ["iconFile", "iconWidth", "iconHeight"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/evaluate/index.vue.mjs
var Evaluate = _export_sfc(_sfc_main60, [["__scopeId", "data-v-db4cc488"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/words/index.vue2.mjs
import { defineComponent as defineComponent61, ref as ref48, createBlock as createBlock21, openBlock as openBlock60, unref as unref59, withCtx as withCtx18, createElementVNode as createElementVNode43, normalizeClass as normalizeClass43, createElementBlock as createElementBlock55, createCommentVNode as createCommentVNode41, toDisplayString as toDisplayString40, Fragment as Fragment19, renderList as renderList16 } from "vue";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/words-light.svg.mjs
var wordsIconLight = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%205'%20opacity='0.795169'%3e%3cpath%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20d='M9.60349%2012.4231H9.35784L9.20772%2012.6175L8.01519%2014.1621L6.92003%2012.6321L6.77045%2012.4231H6.51345H3.25C2.2835%2012.4231%201.5%2011.6396%201.5%2010.6731V3.25C1.5%202.2835%202.2835%201.5%203.25%201.5H12.75C13.7165%201.5%2014.5%202.2835%2014.5%203.25V8.80223V10.6731C14.5%2011.6396%2013.7165%2012.4231%2012.75%2012.4231H9.60349Z'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'/%3e%3cpath%20id='&%23232;&%23183;&%23175;&%23229;&%23190;&%23132;%2010'%20d='M9.29061%203.7428L5.97266%206.33122L9.88719%207.13347L6.61672%209.7428'%20stroke='%23232832'%20style='stroke:%23232832;stroke:color(display-p3%200.1360%200.1574%200.1949);stroke-opacity:1;'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/assets/icon/words-dark.svg.mjs
var wordsIconDark = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20id='&%23231;&%23188;&%23150;&%23231;&%23187;&%23132;%209&%23229;&%23164;&%23135;&%23228;&%23187;&%23189;%205'%20opacity='0.795169'%3e%3cpath%20id='&%23231;&%23159;&%23169;&%23229;&%23189;&%23162;'%20d='M9.60349%2012.4231H9.35784L9.20772%2012.6175L8.01519%2014.1621L6.92003%2012.6321L6.77045%2012.4231H6.51345H3.25C2.2835%2012.4231%201.5%2011.6396%201.5%2010.6731V3.25C1.5%202.2835%202.2835%201.5%203.25%201.5H12.75C13.7165%201.5%2014.5%202.2835%2014.5%203.25V8.80223V10.6731C14.5%2011.6396%2013.7165%2012.4231%2012.75%2012.4231H9.60349Z'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'/%3e%3cpath%20id='&%23232;&%23183;&%23175;&%23229;&%23190;&%23132;%2010'%20d='M9.29061%203.7428L5.97266%206.33122L9.88719%207.13347L6.61672%209.7428'%20stroke='%23D5E0F2'%20style='stroke:%23D5E0F2;'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/g%3e%3c/svg%3e";

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/utils/wordsList.mjs
var wordsList = [
  {
    value: "在吗？在吗？在吗？重要的话说三遍。"
  },
  {
    value: "好久没聊天了，快来和我说说话～"
  },
  {
    value: "好的，就这么说定了。"
  },
  {
    value: "感恩的心，感谢有你。"
  },
  {
    value: "糟糕！是心动的感觉！"
  },
  {
    value: "心疼地抱抱自己，我太难了！"
  },
  {
    value: "没关系，别在意，事情过去就过去了。"
  },
  {
    value: "早上好，今天也是让人期待的一天呢！"
  },
  {
    value: "熬夜有什么用，又没人陪你聊天，早点休息吧。"
  }
];

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/words/index.vue2.mjs
var _hoisted_154 = ["onClick"];
var _sfc_main61 = defineComponent61({
  __name: "index",
  emits: ["onDialogPopupShowOrHide"],
  setup(__props, { emit: __emit }) {
    const wordsIcon = ChatConfig.getTheme() === "dark" ? wordsIconDark : wordsIconLight;
    const emits = __emit;
    const currentConversation = ref48();
    const container = ref48();
    Jt.watch(o.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const selectWord = (item) => {
      var _a3, _b3, _c2, _d2, _e2, _f2;
      const options = {
        to: ((_b3 = (_a3 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _a3.groupProfile) == null ? void 0 : _b3.groupID) || ((_d2 = (_c2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c2.userProfile) == null ? void 0 : _d2.userID),
        conversationType: (_e2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _e2.type,
        payload: {
          text: Wt.t(`Words.${item.value}`)
        },
        needReadReceipt: isEnabledMessageReadReceiptGlobal()
      };
      Qt.sendTextMessage(options);
      (_f2 = container == null ? void 0 : container.value) == null ? void 0 : _f2.toggleDialogDisplay(false);
    };
    const closeDialog = () => {
      var _a3;
      (_a3 = container == null ? void 0 : container.value) == null ? void 0 : _a3.toggleDialogDisplay(false);
    };
    const onDialogShow = () => {
      emits("onDialogPopupShowOrHide", true);
    };
    const onDialogClose = () => {
      emits("onDialogPopupShowOrHide", false);
    };
    return (_ctx, _cache) => {
      return openBlock60(), createBlock21(ToolbarItemContainer, {
        ref_key: "container",
        ref: container,
        iconFile: unref59(wordsIcon),
        title: "常用语",
        needBottomPopup: true,
        iconWidth: unref59(isUniFrameWork) ? "26px" : "20px",
        iconHeight: unref59(isUniFrameWork) ? "26px" : "20px",
        onOnDialogShow: onDialogShow,
        onOnDialogClose: onDialogClose
      }, {
        default: withCtx18(() => [
          createElementVNode43("div", {
            class: normalizeClass43(["words", !unref59(isPC) && "words-h5"])
          }, [
            createElementVNode43("div", {
              class: normalizeClass43(["words-header", !unref59(isPC) && "words-h5-header"])
            }, [
              createElementVNode43("span", {
                class: normalizeClass43(["words-header-title", !unref59(isPC) && "words-h5-header-title"])
              }, toDisplayString40(unref59(Wt).t("Words.常用语-快捷回复工具")), 3),
              !unref59(isPC) ? (openBlock60(), createElementBlock55("span", {
                key: 0,
                class: normalizeClass43(["words-header-close", !unref59(isPC) && "words-h5-header-close"]),
                onClick: closeDialog
              }, " 关闭 ", 2)) : createCommentVNode41("", true)
            ], 2),
            createElementVNode43("ul", {
              class: normalizeClass43(["words-list", !unref59(isPC) && "words-h5-list"])
            }, [
              (openBlock60(true), createElementBlock55(Fragment19, null, renderList16(unref59(wordsList), (item, index3) => {
                return openBlock60(), createElementBlock55("li", {
                  key: index3,
                  class: normalizeClass43(["words-list-item", !unref59(isPC) && "words-h5-list-item"]),
                  onClick: ($event) => selectWord(item)
                }, toDisplayString40(unref59(Wt).t(`Words.${item.value}`)), 11, _hoisted_154);
              }), 128))
            ], 2)
          ], 2)
        ]),
        _: 1
      }, 8, ["iconFile", "iconWidth", "iconHeight"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/words/index.vue.mjs
var Words = _export_sfc(_sfc_main61, [["__scopeId", "data-v-53dcf031"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/user-selector/index.vue.mjs
import { defineComponent as defineComponent62, ref as ref49, computed as computed21, watch as watch18, createBlock as createBlock22, openBlock as openBlock61, unref as unref60, withCtx as withCtx19, createVNode as createVNode30 } from "vue";
var _sfc_main62 = defineComponent62({
  __name: "index",
  props: {
    // type: voiceCall/groupCall/...
    type: {
      type: String,
      default: ""
    },
    currentConversation: {
      type: Object,
      default: () => ({})
    },
    isGroup: {
      type: Boolean,
      default: false
    }
  },
  emits: ["submit", "cancel"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const show = ref49(false);
    const groupID = ref49("");
    const memberList2 = ref49([]);
    const searchMemberList = ref49([]);
    const selfUserID = ref49("");
    const titleMap = {
      voiceCall: "发起群语音",
      videoCall: "发起群视频"
    };
    const title = computed21(() => {
      return titleMap[props.type] ? titleMap[props.type] : "";
    });
    Zt.getUserProfile().then((res) => {
      var _a3;
      if ((_a3 = res == null ? void 0 : res.data) == null ? void 0 : _a3.userID) {
        selfUserID.value = res.data.userID;
      }
    });
    watch18(
      () => {
        var _a3;
        return [(_a3 = props == null ? void 0 : props.currentConversation) == null ? void 0 : _a3.conversationID, show.value];
      },
      (newVal, oldVal) => {
        if (newVal && newVal !== oldVal) {
          if (props.isGroup && show.value) {
            groupID.value = props.currentConversation.groupProfile.groupID;
            es.getGroupMemberList({
              groupID: groupID.value
            }).then((res) => {
              var _a3, _b3;
              memberList2.value = (_b3 = (_a3 = res == null ? void 0 : res.data) == null ? void 0 : _a3.memberList) == null ? void 0 : _b3.filter(
                (user) => (user == null ? void 0 : user.userID) !== selfUserID.value
              );
              searchMemberList.value = memberList2.value;
            });
          } else {
            groupID.value = "";
            memberList2.value = [];
            searchMemberList.value = memberList2.value;
          }
        }
      },
      {
        immediate: true
      }
    );
    const search = (searchInfo) => {
      var _a3;
      const results = (_a3 = memberList2.value) == null ? void 0 : _a3.filter(
        (member) => (member == null ? void 0 : member.userID) === searchInfo
      );
      searchMemberList.value = (results == null ? void 0 : results.length) ? results : memberList2.value;
    };
    const submit = (selectedMemberList) => {
      const userIDList = [];
      selectedMemberList == null ? void 0 : selectedMemberList.forEach((user) => {
        (user == null ? void 0 : user.userID) && userIDList.push(user.userID);
      });
      if (props.type === "voiceCall") {
        emits("submit", { userIDList, groupID: groupID.value, type: 1 });
      } else if (props.type === "videoCall") {
        emits("submit", { userIDList, groupID: groupID.value, type: 2 });
      }
      searchMemberList.value = memberList2.value;
      toggleShow(false);
    };
    const cancel = () => {
      searchMemberList.value = memberList2.value;
      emits("cancel");
      toggleShow(false);
    };
    const toggleShow = (showStatus) => {
      show.value = showStatus;
    };
    __expose({
      toggleShow
    });
    return (_ctx, _cache) => {
      return openBlock61(), createBlock22(Dialog, {
        show: unref60(show),
        isH5: !unref60(isPC),
        isHeaderShow: false,
        isFooterShow: false,
        background: false,
        "onUpdate:show": toggleShow
      }, {
        default: withCtx19(() => [
          createVNode30(Transfer, {
            isSearch: true,
            title: unref60(title),
            list: unref60(searchMemberList),
            isH5: !unref60(isPC),
            isRadio: false,
            onSearch: search,
            onSubmit: submit,
            onCancel: cancel
          }, null, 8, ["title", "list", "isH5"])
        ]),
        _: 1
      }, 8, ["show", "isH5"]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/index.vue2.mjs
var _hoisted_155 = {
  key: 0,
  class: normalizeClass44(["message-input-toolbar-list-end"])
};
var _sfc_main63 = defineComponent63({
  __name: "index",
  props: {
    displayType: { default: "none" }
  },
  emits: ["scrollToLatestMessage", "changeToolbarDisplayType", "insertEmoji"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const h5Dialog = ref50();
    const currentConversation = ref50();
    const isGroup2 = ref50(false);
    const selectorShowType = ref50("");
    const userSelectorRef = ref50();
    const emojiPickerRef = ref50();
    const currentUserSelectorExtension = ref50();
    const currentExtensionList = ref50([]);
    const featureConfig = ChatConfig.getFeatureConfig();
    const isRenderedEmojiPicker = ref50(true);
    isRenderedEmojiPicker.value = featureConfig.InputEmoji || featureConfig.InputStickers;
    onMounted21(() => {
      Jt.watch(o.CUSTOM, {
        activeConversation: onActiveConversationUpdate
      });
    });
    onUnmounted16(() => {
      Jt.unwatch(o.CUSTOM, {
        activeConversation: onActiveConversationUpdate
      });
    });
    watch19(() => props.displayType, (newValue) => {
      var _a3;
      if (newValue === "none") {
        (_a3 = emojiPickerRef.value) == null ? void 0 : _a3.closeEmojiPicker();
      } else {
        emits("scrollToLatestMessage");
      }
    });
    const onActiveConversationUpdate = (conversationID) => {
      var _a3;
      if (!conversationID) {
        return;
      }
      if (conversationID !== ((_a3 = currentConversation.value) == null ? void 0 : _a3.conversationID)) {
        getExtensionList();
        currentConversation.value = Jt.getData(o.CONV, "currentConversation");
        isGroup2.value = conversationID.startsWith(qt.TYPES.CONV_GROUP);
      }
    };
    const getExtensionList = () => {
      const chatType = ChatConfig.getChatType();
      const params = { chatType };
      if (chatType === E.TUIChat.TYPE.CUSTOMER_SERVICE) {
        params.filterVoice = true;
        params.filterVideo = true;
        enableSampleTaskStatus("customerService");
      }
      currentExtensionList.value = [
        ...R.getExtensionList(E.TUIChat.EXTENSION.INPUT_MORE.EXT_ID, params)
      ].filter((extension) => {
        var _a3;
        if (((_a3 = extension == null ? void 0 : extension.data) == null ? void 0 : _a3.name) === "search") {
          return featureConfig.MessageSearch;
        }
        return true;
      });
    };
    const extensionListShowInStart = computed22(() => {
      if (isPC) {
        const extensionList = currentExtensionList.value.filter((extension) => {
          var _a3;
          return ((_a3 = extension == null ? void 0 : extension.data) == null ? void 0 : _a3.name) !== "search";
        });
        return extensionList;
      }
      return currentExtensionList.value;
    });
    const extensionListShowInEnd = computed22(() => {
      if (isPC) {
        const searchExtension = currentExtensionList.value.find((extension) => {
          var _a3;
          return ((_a3 = extension == null ? void 0 : extension.data) == null ? void 0 : _a3.name) === "search";
        });
        return searchExtension ? [searchExtension] : [];
      }
      return [];
    });
    const onExtensionClick = (extension) => {
      var _a3, _b3, _c2;
      switch ((_a3 = extension == null ? void 0 : extension.data) == null ? void 0 : _a3.name) {
        case "voiceCall":
          onCallExtensionClicked(extension, 1);
          break;
        case "videoCall":
          onCallExtensionClicked(extension, 2);
          break;
        default:
          (_c2 = extension == null ? void 0 : extension.listener) == null ? void 0 : _c2.onClicked((_b3 = currentConversation.value) == null ? void 0 : _b3._conversation);
          break;
      }
    };
    const onCallExtensionClicked = (extension, callType) => {
      var _a3, _b3, _c2, _d2, _e2, _f2, _g;
      selectorShowType.value = (_a3 = extension == null ? void 0 : extension.data) == null ? void 0 : _a3.name;
      if (((_b3 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _b3.type) === qt.TYPES.CONV_C2C) {
        (_f2 = (_c2 = extension.listener) == null ? void 0 : _c2.onClicked) == null ? void 0 : _f2.call(_c2, {
          userIDList: [(_e2 = (_d2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _d2.conversationID) == null ? void 0 : _e2.slice(3)],
          type: callType
        });
      } else if (isGroup2.value) {
        currentUserSelectorExtension.value = extension;
        ((_g = userSelectorRef == null ? void 0 : userSelectorRef.value) == null ? void 0 : _g.toggleShow) && userSelectorRef.value.toggleShow(true);
      }
    };
    const genExtensionIcon = (extension) => {
      return extension == null ? void 0 : extension.icon;
    };
    const genExtensionText = (extension) => {
      return extension == null ? void 0 : extension.text;
    };
    const onUserSelectorSubmit = (selectedInfo) => {
      var _a3, _b3, _c2;
      (_c2 = (_b3 = (_a3 = currentUserSelectorExtension.value) == null ? void 0 : _a3.listener) == null ? void 0 : _b3.onClicked) == null ? void 0 : _c2.call(_b3, selectedInfo);
      currentUserSelectorExtension.value = void 0;
    };
    const onUserSelectorCancel = () => {
      currentUserSelectorExtension.value = void 0;
    };
    const insertEmoji = (emojiObj) => {
      emits("insertEmoji", emojiObj);
    };
    const dialogShowInH5 = (dialogDom) => {
      var _a3, _b3;
      if (!isH5) {
        return;
      }
      ((_a3 = h5Dialog.value) == null ? void 0 : _a3.appendChild) && ((_b3 = h5Dialog.value) == null ? void 0 : _b3.appendChild(dialogDom));
    };
    const dialogCloseInH5 = (dialogDom) => {
      var _a3, _b3;
      if (!isH5) {
        return;
      }
      if (dialogDom) {
        ((_a3 = h5Dialog.value) == null ? void 0 : _a3.removeChild) && ((_b3 = h5Dialog.value) == null ? void 0 : _b3.removeChild(dialogDom));
      }
    };
    return (_ctx, _cache) => {
      return openBlock62(), createElementBlock56("div", {
        class: normalizeClass44([
          "message-input-toolbar",
          !unref61(isPC) && "message-input-toolbar-h5",
          unref61(isUniFrameWork) && "message-input-toolbar-uni"
        ])
      }, [
        createElementVNode44("div", {
          class: normalizeClass44([
            "message-input-toolbar-list",
            !unref61(isPC) && "message-input-toolbar-h5-list",
            unref61(isUniFrameWork) && "message-input-toolbar-uni-list"
          ])
        }, [
          unref61(isRenderedEmojiPicker) ? (openBlock62(), createBlock23(EmojiPicker, {
            key: 0,
            ref_key: "emojiPickerRef",
            ref: emojiPickerRef,
            onInsertEmoji: insertEmoji,
            onDialogShowInH5: dialogShowInH5,
            onDialogCloseInH5: dialogCloseInH5,
            onChangeToolbarDisplayType: _cache[0] || (_cache[0] = (type) => emits("changeToolbarDisplayType", type))
          }, null, 512)) : createCommentVNode42("", true),
          unref61(featureConfig).InputImage ? (openBlock62(), createBlock23(ImageUpload, {
            key: 1,
            imageSourceType: "album"
          })) : createCommentVNode42("", true),
          unref61(featureConfig).InputFile ? (openBlock62(), createBlock23(FileUpload, { key: 2 })) : createCommentVNode42("", true),
          unref61(featureConfig).InputVideo ? (openBlock62(), createBlock23(VideoUpload, {
            key: 3,
            videoSourceType: "album"
          })) : createCommentVNode42("", true),
          unref61(featureConfig).InputEvaluation ? (openBlock62(), createBlock23(Evaluate, { key: 4 })) : createCommentVNode42("", true),
          unref61(featureConfig).InputQuickReplies ? (openBlock62(), createBlock23(Words, { key: 5 })) : createCommentVNode42("", true),
          unref61(extensionListShowInStart)[0] ? (openBlock62(true), createElementBlock56(Fragment20, { key: 6 }, renderList17(unref61(extensionListShowInStart), (extension) => {
            return openBlock62(), createBlock23(ToolbarItemContainer, {
              key: extension.id,
              iconFile: genExtensionIcon(extension),
              title: genExtensionText(extension),
              iconWidth: unref61(isUniFrameWork) ? "25px" : "20px",
              iconHeight: unref61(isUniFrameWork) ? "25px" : "20px",
              needDialog: false,
              onOnIconClick: ($event) => onExtensionClick(extension)
            }, null, 8, ["iconFile", "title", "iconWidth", "iconHeight", "onOnIconClick"]);
          }), 128)) : createCommentVNode42("", true)
        ], 2),
        unref61(extensionListShowInEnd)[0] && unref61(isPC) ? (openBlock62(), createElementBlock56("div", _hoisted_155, [
          (openBlock62(true), createElementBlock56(Fragment20, null, renderList17(unref61(extensionListShowInEnd), (extension, index3) => {
            return openBlock62(), createBlock23(ToolbarItemContainer, {
              key: index3,
              iconFile: genExtensionIcon(extension),
              title: genExtensionText(extension),
              iconWidth: unref61(isUniFrameWork) ? "25px" : "20px",
              iconHeight: unref61(isUniFrameWork) ? "25px" : "20px",
              needDialog: false,
              onOnIconClick: ($event) => onExtensionClick(extension)
            }, null, 8, ["iconFile", "title", "iconWidth", "iconHeight", "onOnIconClick"]);
          }), 128))
        ])) : createCommentVNode42("", true),
        createVNode31(_sfc_main62, {
          ref_key: "userSelectorRef",
          ref: userSelectorRef,
          type: unref61(selectorShowType),
          currentConversation: unref61(currentConversation),
          isGroup: unref61(isGroup2),
          onSubmit: onUserSelectorSubmit,
          onCancel: onUserSelectorCancel
        }, null, 8, ["type", "currentConversation", "isGroup"]),
        unref61(isH5) ? (openBlock62(), createElementBlock56("div", {
          key: 1,
          ref_key: "h5Dialog",
          ref: h5Dialog,
          class: normalizeClass44(["message-input-toolbar-h5-dialog"])
        }, null, 512)) : createCommentVNode42("", true)
      ], 2);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/message-input-toolbar/index.vue.mjs
var MessageInputToolbar = _export_sfc(_sfc_main63, [["__scopeId", "data-v-fe51a5a7"]]);

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/index.vue2.mjs
var _hoisted_156 = { class: "chat" };
var _sfc_main64 = defineComponent64({
  __name: "index",
  emits: ["closeChat"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const groupID = ref51(void 0);
    const isGroup2 = ref51(false);
    const isNotInGroup = ref51(false);
    const notInGroupReason = ref51();
    const currentConversationID2 = ref51();
    const isMultipleSelectMode = ref51(false);
    const inputToolbarDisplayType = ref51("none");
    const messageInputRef = ref51();
    const messageListRef = ref51();
    const headerExtensionList = ref51([]);
    const featureConfig = ChatConfig.getFeatureConfig();
    onMounted22(() => {
      Jt.watch(o.CONV, {
        currentConversation: onCurrentConversationUpdate
      });
    });
    onUnmounted17(() => {
      Jt.unwatch(o.CONV, {
        currentConversation: onCurrentConversationUpdate
      });
      reset();
    });
    const isInputToolbarShow = computed23(() => {
      return isUniFrameWork ? inputToolbarDisplayType.value !== "none" : true;
    });
    const leaveGroupReasonText = computed23(() => {
      let text = "";
      switch (notInGroupReason.value) {
        case 4:
          text = Wt.t("TUIChat.您已被管理员移出群聊");
          break;
        case 5:
          text = Wt.t("TUIChat.该群聊已被解散");
          break;
        case 8:
          text = Wt.t("TUIChat.您已退出该群聊");
          break;
        default:
          text = Wt.t("TUIChat.您已退出该群聊");
          break;
      }
      return text;
    });
    const reset = () => {
      Xt.switchConversation("");
    };
    const closeChat = (conversationID) => {
      emits("closeChat", conversationID);
      reset();
    };
    const insertEmoji = (emojiObj) => {
      var _a3;
      (_a3 = messageInputRef.value) == null ? void 0 : _a3.insertEmoji(emojiObj);
    };
    const handleEditor = (message, type) => {
      var _a3, _b3, _c2;
      if (!message || !type)
        return;
      switch (type) {
        case "reference":
          break;
        case "reply":
          break;
        case "reedit":
          if ((_a3 = message == null ? void 0 : message.payload) == null ? void 0 : _a3.text) {
            (_c2 = messageInputRef == null ? void 0 : messageInputRef.value) == null ? void 0 : _c2.reEdit((_b3 = message == null ? void 0 : message.payload) == null ? void 0 : _b3.text);
          }
          break;
      }
    };
    const handleGroup = () => {
      headerExtensionList.value[0].listener.onClicked({ groupID: groupID.value });
    };
    function changeToolbarDisplayType(type) {
      inputToolbarDisplayType.value = inputToolbarDisplayType.value === type ? "none" : type;
      if (inputToolbarDisplayType.value !== "none" && isUniFrameWork) {
        uni.$emit("scroll-to-bottom");
      }
    }
    function scrollToLatestMessage() {
      var _a3;
      (_a3 = messageListRef.value) == null ? void 0 : _a3.scrollToLatestMessage();
    }
    function toggleMultipleSelectMode(visible) {
      isMultipleSelectMode.value = visible === void 0 ? !isMultipleSelectMode.value : visible;
    }
    function mergeForwardMessage() {
      var _a3;
      (_a3 = messageListRef.value) == null ? void 0 : _a3.mergeForwardMessage();
    }
    function oneByOneForwardMessage() {
      var _a3;
      (_a3 = messageListRef.value) == null ? void 0 : _a3.oneByOneForwardMessage();
    }
    function updateUIUserNotInGroup(conversation) {
      if ((conversation == null ? void 0 : conversation.operationType) > 0) {
        headerExtensionList.value = [];
        isNotInGroup.value = true;
        notInGroupReason.value = conversation == null ? void 0 : conversation.operationType;
      } else {
        isNotInGroup.value = false;
        notInGroupReason.value = void 0;
      }
    }
    function onCurrentConversationUpdate(conversation) {
      updateUIUserNotInGroup(conversation);
      if (!conversation) {
        return;
      }
      if (currentConversationID2.value === (conversation == null ? void 0 : conversation.conversationID)) {
        return;
      }
      isGroup2.value = false;
      let conversationType = qt.TYPES.CONV_C2C;
      const conversationID = conversation.conversationID;
      if (conversationID.startsWith(qt.TYPES.CONV_GROUP)) {
        conversationType = qt.TYPES.CONV_GROUP;
        isGroup2.value = true;
        groupID.value = conversationID.replace(qt.TYPES.CONV_GROUP, "");
      }
      headerExtensionList.value = [];
      isMultipleSelectMode.value = false;
      ChatConfig.setChatType(conversationType);
      R.notifyEvent(E.TUIChat.EVENT.CHAT_STATE_CHANGED, E.TUIChat.EVENT_SUB_KEY.CHAT_OPENED, { groupID: groupID.value });
      R.callService({
        serviceName: E.TUICustomerServicePlugin.SERVICE.NAME,
        method: E.TUICustomerServicePlugin.SERVICE.METHOD.ACTIVE_CONVERSATION,
        params: { conversationID }
      });
      if (ChatConfig.getChatType() === E.TUIChat.TYPE.ROOM) {
        if (ChatConfig.getFeatureConfig(E.TUIChat.FEATURE.InputVoice) === true) {
          ChatConfig.setTheme("light");
          currentConversationID2.value = "";
          return;
        }
      }
      if (ChatConfig.getChatType() === E.TUIChat.TYPE.GROUP) {
        headerExtensionList.value = R.getExtensionList(E.TUIChat.EXTENSION.CHAT_HEADER.EXT_ID);
      }
      Jt.update(o.CUSTOM, "activeConversation", conversationID);
      currentConversationID2.value = conversationID;
    }
    return (_ctx, _cache) => {
      return openBlock63(), createElementBlock57("div", _hoisted_156, [
        createElementVNode45("div", {
          class: normalizeClass45(["tui-chat", !unref62(isPC) && "tui-chat-h5"])
        }, [
          !unref62(currentConversationID2) ? (openBlock63(), createElementBlock57("div", {
            key: 0,
            class: normalizeClass45(["tui-chat-default", !unref62(isPC) && "tui-chat-h5-default"])
          }, [
            renderSlot13(_ctx.$slots, "default", {}, void 0, true)
          ], 2)) : createCommentVNode43("", true),
          unref62(currentConversationID2) ? (openBlock63(), createElementBlock57("div", {
            key: 1,
            class: normalizeClass45(["tui-chat", !unref62(isPC) && "tui-chat-h5"])
          }, [
            createVNode32(ChatHeader, {
              class: normalizeClass45([
                "tui-chat-header",
                !unref62(isPC) && "tui-chat-H5-header",
                unref62(isUniFrameWork) && "tui-chat-uniapp-header"
              ]),
              isGroup: unref62(isGroup2),
              headerExtensionList: unref62(headerExtensionList),
              onCloseChat: closeChat,
              onOpenGroupManagement: handleGroup
            }, null, 8, ["class", "isGroup", "headerExtensionList"]),
            createVNode32(_sfc_main53, { onToggleMultipleSelectMode: toggleMultipleSelectMode }),
            createVNode32(MessageList, {
              ref_key: "messageListRef",
              ref: messageListRef,
              class: normalizeClass45(["tui-chat-message-list", !unref62(isPC) && "tui-chat-h5-message-list"]),
              isGroup: unref62(isGroup2),
              groupID: unref62(groupID),
              isNotInGroup: unref62(isNotInGroup),
              isMultipleSelectMode: unref62(isMultipleSelectMode),
              onHandleEditor: handleEditor,
              onCloseInputToolBar: _cache[0] || (_cache[0] = () => changeToolbarDisplayType("none")),
              onToggleMultipleSelectMode: toggleMultipleSelectMode
            }, null, 8, ["class", "isGroup", "groupID", "isNotInGroup", "isMultipleSelectMode"]),
            unref62(isNotInGroup) ? (openBlock63(), createElementBlock57("div", {
              key: 0,
              class: normalizeClass45({
                "tui-chat-leave-group": true,
                "tui-chat-leave-group-mobile": unref62(isMobile)
              })
            }, toDisplayString41(unref62(leaveGroupReasonText)), 3)) : unref62(isMultipleSelectMode) ? (openBlock63(), createBlock24(MultipleSelectPanel, {
              key: 1,
              onOneByOneForwardMessage: oneByOneForwardMessage,
              onMergeForwardMessage: mergeForwardMessage,
              onToggleMultipleSelectMode: toggleMultipleSelectMode
            })) : (openBlock63(), createElementBlock57(Fragment21, { key: 2 }, [
              unref62(isInputToolbarShow) ? (openBlock63(), createBlock24(MessageInputToolbar, {
                key: 0,
                class: normalizeClass45([
                  "tui-chat-message-input-toolbar",
                  !unref62(isPC) && "tui-chat-h5-message-input-toolbar",
                  unref62(isUniFrameWork) && "tui-chat-uni-message-input-toolbar"
                ]),
                displayType: unref62(inputToolbarDisplayType),
                onInsertEmoji: insertEmoji,
                onChangeToolbarDisplayType: changeToolbarDisplayType,
                onScrollToLatestMessage: scrollToLatestMessage
              }, null, 8, ["class", "displayType"])) : createCommentVNode43("", true),
              createVNode32(MessageInput, {
                ref_key: "messageInputRef",
                ref: messageInputRef,
                class: normalizeClass45([
                  "tui-chat-message-input",
                  !unref62(isPC) && "tui-chat-h5-message-input",
                  unref62(isUniFrameWork) && "tui-chat-uni-message-input",
                  unref62(isWeChat) && "tui-chat-wx-message-input"
                ]),
                enableAt: unref62(featureConfig).InputMention,
                isMuted: false,
                muteText: unref62(Wt).t("TUIChat.您已被管理员禁言"),
                placeholder: unref62(Wt).t("TUIChat.请输入消息"),
                inputToolbarDisplayType: unref62(inputToolbarDisplayType),
                onChangeToolbarDisplayType: changeToolbarDisplayType
              }, null, 8, ["class", "enableAt", "muteText", "placeholder", "inputToolbarDisplayType"])
            ], 64))
          ], 2)) : createCommentVNode43("", true),
          !unref62(isNotInGroup) && !unref62(isApp) && unref62(isUniFrameWork) && unref62(isGroup2) && unref62(headerExtensionList).length > 0 ? (openBlock63(), createElementBlock57("div", {
            key: 2,
            class: "group-profile",
            onClick: handleGroup
          }, toDisplayString41(unref62(headerExtensionList)[0].text), 1)) : createCommentVNode43("", true)
        ], 2)
      ]);
    };
  }
});

// D:/code/web/node_modules/@tencentcloud/roomkit-web-vue3/es/components/Chat/ChatKit/components/TUIChat/index.vue.mjs
var index2 = _export_sfc(_sfc_main64, [["__scopeId", "data-v-5c1ad570"]]);
export {
  index2 as default
};
//# sourceMappingURL=index.vue-RAB5NQZ4.js.map
