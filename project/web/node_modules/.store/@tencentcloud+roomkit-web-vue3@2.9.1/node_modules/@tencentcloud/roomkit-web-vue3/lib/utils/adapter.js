"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const environment = require("./environment.js");
const clipBoard = (data) => new Promise(async (resolve, reject) => {
  if (!environment.isWeChat) {
    const textString = data.toString();
    try {
      await navigator.clipboard.writeText(`${data}`);
      resolve({ code: 0, data });
    } catch (err) {
      try {
        copyTextByDocumentExecCommand(textString);
        resolve({ code: 0, data });
      } catch (err2) {
        reject({ code: -1, err: err2 });
      }
    }
    return;
  }
  uni.setClipboardData({
    data,
    success() {
      uni.getClipboardData({
        success(data2) {
          resolve({ code: 0, data: data2 });
        },
        fail(err) {
          reject({ code: -1, err });
        }
      });
    },
    fail(err) {
      reject({ code: -1, err });
    }
  });
});
function copyTextByDocumentExecCommand(textString) {
  try {
    const input = document.createElement("input");
    input.id = "copy-input";
    input.readOnly = true;
    input.style.position = "absolute";
    input.style.left = "-1000px";
    input.style.zIndex = "-1000";
    document.body.appendChild(input);
    input.value = textString;
    selectText(input, 0, textString.length);
    if (document.execCommand("copy")) {
      document.execCommand("copy");
    }
    input.blur();
  } catch (err) {
  }
}
function selectText(textbox, startIndex, stopIndex) {
  if (textbox.createTextRange) {
    const range = textbox.createTextRange();
    range.collapse(true);
    range.moveStart("character", startIndex);
    range.moveEnd("character", stopIndex - startIndex);
    range.select();
  } else {
    textbox.setSelectionRange(startIndex, stopIndex);
    textbox.focus();
  }
}
exports.clipBoard = clipBoard;
