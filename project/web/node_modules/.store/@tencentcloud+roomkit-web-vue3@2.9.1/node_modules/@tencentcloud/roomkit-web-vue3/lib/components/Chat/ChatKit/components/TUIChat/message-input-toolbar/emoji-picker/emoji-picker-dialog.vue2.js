"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
require("../../../../adapter-vue.js");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const Icon = require("../../../common/Icon.vue.js");
const faceLight = require("../../../../assets/icon/face-light.svg.js");
const faceDark = require("../../../../assets/icon/face-dark.svg.js");
const constant = require("../../../../constant.js");
const env = require("../../../../utils/env.js");
const utils = require("../../utils/utils.js");
const index = require("../../emoji-config/index.js");
const config = require("../../config.js");
const _hoisted_1 = ["onClick"];
const _hoisted_2 = ["src"];
const _hoisted_3 = ["src"];
const _hoisted_4 = ["src"];
const _hoisted_5 = { class: "emoji-picker-tab" };
const _hoisted_6 = ["onClick"];
const _hoisted_7 = ["src"];
const _hoisted_8 = ["src"];
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "emoji-picker-dialog",
  emits: ["insertEmoji", "onClose", "sendMessage"],
  setup(__props, { emit: __emit }) {
    var _a;
    const faceIcon = config.default.getTheme() === "dark" ? faceDark.default : faceLight.default;
    const emits = __emit;
    const currentTabIndex = Vue.ref(0);
    const currentConversation = Vue.ref();
    const emojiPickerDialog = Vue.ref();
    const emojiPickerListRef = Vue.ref();
    const featureConfig = config.default.getFeatureConfig();
    const list = Vue.ref(initEmojiList());
    const currentTabItem = Vue.ref(list == null ? void 0 : list.value[0]);
    const currentEmojiList = Vue.ref((_a = list == null ? void 0 : list.value[0]) == null ? void 0 : _a.list);
    Vue.onMounted(() => {
      TUIChatEngine.TUIStore.watch(TUIChatEngine.StoreName.CONV, {
        currentConversation: onCurrentConversationUpdate
      });
    });
    Vue.onUnmounted(() => {
      TUIChatEngine.TUIStore.unwatch(TUIChatEngine.StoreName.CONV, {
        currentConversation: onCurrentConversationUpdate
      });
    });
    const toggleEmojiTab = (index2) => {
      var _a2;
      currentTabIndex.value = index2;
      currentTabItem.value = list == null ? void 0 : list.value[index2];
      currentEmojiList.value = (_a2 = list == null ? void 0 : list.value[index2]) == null ? void 0 : _a2.list;
      if (!env.isUniFrameWork) {
        (emojiPickerListRef == null ? void 0 : emojiPickerListRef.value) && (emojiPickerListRef.value.scrollTop = 0);
      }
    };
    const select = (item, index$1) => {
      var _a2, _b, _c;
      const options = {
        emoji: { key: item, name: index.convertKeyToEmojiName(item) },
        type: (_a2 = currentTabItem == null ? void 0 : currentTabItem.value) == null ? void 0 : _a2.type
      };
      switch ((_b = currentTabItem == null ? void 0 : currentTabItem.value) == null ? void 0 : _b.type) {
        case constant.EMOJI_TYPE.BASIC:
          options.url = ((_c = currentTabItem == null ? void 0 : currentTabItem.value) == null ? void 0 : _c.url) + index.BASIC_EMOJI_URL_MAPPING[item];
          if (env.isUniFrameWork) {
            uni.$emit("insert-emoji", options);
          } else {
            emits("insertEmoji", options);
          }
          break;
        case constant.EMOJI_TYPE.BIG:
          sendFaceMessage(index$1, currentTabItem.value);
          break;
        case constant.EMOJI_TYPE.CUSTOM:
          sendFaceMessage(index$1, currentTabItem.value);
          break;
      }
      env.isPC && emits("onClose");
    };
    const sendFaceMessage = (index2, listItem) => {
      var _a2, _b, _c, _d, _e;
      const options = {
        to: ((_b = (_a2 = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _a2.groupProfile) == null ? void 0 : _b.groupID) || ((_d = (_c = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _c.userProfile) == null ? void 0 : _d.userID),
        conversationType: (_e = currentConversation == null ? void 0 : currentConversation.value) == null ? void 0 : _e.type,
        payload: {
          index: listItem.emojiGroupID,
          data: listItem.list[index2]
        },
        needReadReceipt: utils.isEnabledMessageReadReceiptGlobal()
      };
      TUIChatEngine.TUIChatService.sendFaceMessage(options);
    };
    function sendMessage() {
      uni.$emit("send-message-in-emoji-picker");
    }
    function onCurrentConversationUpdate(conversation) {
      currentConversation.value = conversation;
    }
    function initEmojiList() {
      return index.EMOJI_GROUP_LIST.filter((item) => {
        if (item.type === constant.EMOJI_TYPE.BASIC) {
          return featureConfig.InputEmoji;
        }
        if (item.type === constant.EMOJI_TYPE.BIG) {
          return featureConfig.InputStickers;
        }
      });
    }
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock("div", {
        ref_key: "emojiPickerDialog",
        ref: emojiPickerDialog,
        class: Vue.normalizeClass({
          "emoji-picker": true,
          "emoji-picker-h5": !Vue.unref(env.isPC)
        })
      }, [
        Vue.createElementVNode("ul", {
          ref_key: "emojiPickerListRef",
          ref: emojiPickerListRef,
          class: Vue.normalizeClass(["emoji-picker-list", !Vue.unref(env.isPC) && "emoji-picker-h5-list"])
        }, [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(currentEmojiList), (childrenItem, childrenIndex) => {
            return Vue.openBlock(), Vue.createElementBlock("li", {
              key: childrenIndex,
              class: "emoji-picker-list-item",
              onClick: ($event) => select(childrenItem, childrenIndex)
            }, [
              Vue.unref(currentTabItem).type === Vue.unref(constant.EMOJI_TYPE).BASIC ? (Vue.openBlock(), Vue.createElementBlock("img", {
                key: 0,
                class: "emoji",
                src: Vue.unref(currentTabItem).url + Vue.unref(index.BASIC_EMOJI_URL_MAPPING)[childrenItem]
              }, null, 8, _hoisted_2)) : Vue.unref(currentTabItem).type === Vue.unref(constant.EMOJI_TYPE).BIG ? (Vue.openBlock(), Vue.createElementBlock("img", {
                key: 1,
                class: "emoji-big",
                src: Vue.unref(currentTabItem).url + childrenItem + "@2x.png"
              }, null, 8, _hoisted_3)) : (Vue.openBlock(), Vue.createElementBlock("img", {
                key: 2,
                class: "emoji-custom emoji-big",
                src: Vue.unref(currentTabItem).url + childrenItem
              }, null, 8, _hoisted_4))
            ], 8, _hoisted_1);
          }), 128))
        ], 2),
        Vue.createElementVNode("ul", _hoisted_5, [
          (Vue.openBlock(true), Vue.createElementBlock(Vue.Fragment, null, Vue.renderList(Vue.unref(list), (item, index2) => {
            return Vue.openBlock(), Vue.createElementBlock("li", {
              key: index2,
              class: "emoji-picker-tab-item",
              onClick: ($event) => toggleEmojiTab(index2)
            }, [
              item.type === Vue.unref(constant.EMOJI_TYPE).BASIC ? (Vue.openBlock(), Vue.createBlock(Icon.default, {
                key: 0,
                class: "icon",
                file: Vue.unref(faceIcon)
              }, null, 8, ["file"])) : item.type === Vue.unref(constant.EMOJI_TYPE).BIG ? (Vue.openBlock(), Vue.createElementBlock("img", {
                key: 1,
                class: "icon-big",
                src: item.url + item.list[0] + "@2x.png"
              }, null, 8, _hoisted_7)) : (Vue.openBlock(), Vue.createElementBlock("img", {
                key: 2,
                class: "icon-custom icon-big",
                src: item.url + item.list[0]
              }, null, 8, _hoisted_8))
            ], 8, _hoisted_6);
          }), 128)),
          Vue.unref(env.isUniFrameWork) ? (Vue.openBlock(), Vue.createElementBlock("li", {
            key: 0,
            class: "send-btn",
            onClick: sendMessage
          }, " 发送 ")) : Vue.createCommentVNode("", true)
        ])
      ], 2);
    };
  }
});
exports.default = _sfc_main;
