"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
require("../../../../../adapter-vue.js");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const convertContent = require("./convert-content.vue.js");
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  setup(__props) {
    const props = __props;
    const convertVisible = Vue.ref(false);
    const hasConvertError = Vue.ref(false);
    const convertWrapperRef = Vue.ref();
    let isSingleConvert = true;
    Vue.onMounted(() => {
      TUIChatEngine.TUIStore.watch(TUIChatEngine.StoreName.CHAT, {
        voiceToTextInfo: onMessageConvertUpdated
      });
    });
    Vue.onUnmounted(() => {
      TUIChatEngine.TUIStore.unwatch(TUIChatEngine.StoreName.CHAT, {
        voiceToTextInfo: onMessageConvertUpdated
      });
    });
    function toggleErrorStatus(hasError) {
      hasConvertError.value = hasError;
    }
    function onMessageConvertUpdated(info) {
      if (info === void 0) return;
      isSingleConvert = false;
      const convertInfoList = info.get(props.message.conversationID) || [];
      for (let i = 0; i < convertInfoList.length; ++i) {
        const { messageID, visible } = convertInfoList[i];
        if (messageID === props.message.ID && visible !== void 0) {
          if (convertInfoList.length === 1 && visible) {
            isSingleConvert = true;
          }
          hasConvertError.value = false;
          convertVisible.value = visible;
          break;
        }
      }
    }
    return (_ctx, _cache) => {
      return Vue.unref(convertVisible) ? (Vue.openBlock(), Vue.createElementBlock("div", {
        key: 0,
        ref_key: "convertWrapperRef",
        ref: convertWrapperRef,
        class: Vue.normalizeClass({
          "message-convert": true,
          "reverse": props.message.flow === "out",
          "error": Vue.unref(hasConvertError)
        })
      }, [
        Vue.createVNode(convertContent.default, {
          message: props.message,
          contentVisible: Vue.unref(convertVisible),
          isSingleConvert: Vue.unref(isSingleConvert),
          convertWrapperRef: Vue.unref(convertWrapperRef),
          onToggleErrorStatus: toggleErrorStatus
        }, null, 8, ["message", "contentVisible", "isSingleConvert", "convertWrapperRef"])
      ], 2)) : Vue.createCommentVNode("", true);
    };
  }
});
exports.default = _sfc_main;
