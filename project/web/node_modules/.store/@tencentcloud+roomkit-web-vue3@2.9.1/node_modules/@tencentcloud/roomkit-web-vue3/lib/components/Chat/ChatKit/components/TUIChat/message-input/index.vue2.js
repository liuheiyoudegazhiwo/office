"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
require("../../../adapter-vue.js");
const messageInputEditor = require("./message-input-editor.vue.js");
const index = require("./message-input-at/index.vue.js");
const messageInputButton = require("./message-input-button.vue.js");
const index$1 = require("./message-input-quote/index.vue.js");
const sendMessage = require("../utils/sendMessage.js");
const index$2 = require("../emoji-config/index.js");
const env = require("../../../utils/env.js");
const _hoisted_1 = { class: "message-input-wrapper" };
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "index",
  props: {
    placeholder: {
      type: String,
      default: "this is placeholder"
    },
    isMuted: {
      type: Boolean,
      default: true
    },
    muteText: {
      type: String,
      default: ""
    },
    enableInput: {
      type: Boolean,
      default: true
    },
    enableAt: {
      type: Boolean,
      default: true
    },
    enableDragUpload: {
      type: Boolean,
      default: true
    },
    enableTyping: {
      type: Boolean,
      default: true
    }
  },
  emits: ["sendMessage", "resetReplyOrReference", "onTyping"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const editor = Vue.ref();
    const messageInputAtRef = Vue.ref();
    const currentConversation = Vue.ref();
    TUIChatEngine.TUIStore.watch(TUIChatEngine.StoreName.CONV, {
      currentConversation: (conversation) => {
        currentConversation.value = conversation;
      }
    });
    const onTyping = (inputContentEmpty, inputBlur) => {
      sendMessage.sendTyping(inputContentEmpty, inputBlur);
    };
    const onAt = (show) => {
      var _a;
      (_a = messageInputAtRef.value) == null ? void 0 : _a.toggleAtList(show);
    };
    const sendMessage$1 = async () => {
      var _a, _b;
      const _editorContentList = (_a = editor.value) == null ? void 0 : _a.getEditorContent();
      if (!_editorContentList || !currentConversation.value) return;
      const editorContentList = _editorContentList.map((editor2) => {
        if (editor2.type === "text") {
          editor2.payload.text = index$2.transformTextWithEmojiNamesToKeys(editor2.payload.text);
        }
        return editor2;
      });
      await sendMessage.sendMessages(
        editorContentList,
        currentConversation.value
      );
      emit("sendMessage");
      (_b = editor.value) == null ? void 0 : _b.resetEditor();
    };
    const insertEmoji = (emoji) => {
      var _a;
      (_a = editor.value) == null ? void 0 : _a.addEmoji(emoji);
    };
    const onAtListOpen = () => {
      var _a;
      if (env.isH5) {
        (_a = editor.value) == null ? void 0 : _a.blur();
      }
    };
    const insertAt = (atInfo) => {
      var _a, _b;
      ((_a = editor == null ? void 0 : editor.value) == null ? void 0 : _a.insertAt) && ((_b = editor == null ? void 0 : editor.value) == null ? void 0 : _b.insertAt(atInfo));
    };
    const reEdit = (content) => {
      var _a, _b;
      (_a = editor.value) == null ? void 0 : _a.resetEditor();
      (_b = editor.value) == null ? void 0 : _b.setEditorContent(content);
    };
    __expose({
      insertEmoji,
      reEdit
    });
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock("div", _hoisted_1, [
        Vue.createElementVNode("div", {
          class: Vue.normalizeClass(["message-input-container", !Vue.unref(env.isPC) && "message-input-container-h5"])
        }, [
          Vue.createVNode(messageInputEditor.default, {
            ref_key: "editor",
            ref: editor,
            placeholder: props.placeholder,
            isMuted: props.isMuted,
            muteText: props.muteText,
            enableInput: props.enableInput,
            enableAt: props.enableAt,
            enableTyping: props.enableTyping,
            enableDragUpload: props.enableDragUpload,
            onSendMessage: sendMessage$1,
            onOnTyping: onTyping,
            onOnAt: onAt
          }, null, 8, ["placeholder", "isMuted", "muteText", "enableInput", "enableAt", "enableTyping", "enableDragUpload"]),
          !props.isMuted ? (Vue.openBlock(), Vue.createBlock(messageInputButton.default, {
            key: 0,
            onSendMessage: sendMessage$1
          })) : Vue.createCommentVNode("", true),
          props.enableAt ? (Vue.openBlock(), Vue.createBlock(index.default, {
            key: 1,
            ref_key: "messageInputAtRef",
            ref: messageInputAtRef,
            onInsertAt: insertAt,
            onOnAtListOpen: onAtListOpen
          }, null, 512)) : Vue.createCommentVNode("", true)
        ], 2),
        Vue.createVNode(index$1.default)
      ]);
    };
  }
});
exports.default = _sfc_main;
