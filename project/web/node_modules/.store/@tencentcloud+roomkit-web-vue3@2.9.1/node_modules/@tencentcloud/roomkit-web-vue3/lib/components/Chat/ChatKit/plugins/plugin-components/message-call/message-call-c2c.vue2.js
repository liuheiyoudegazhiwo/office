"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
const TUICore = require("@tencentcloud/tui-core");
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
require("../../../adapter-vue.js");
const typeCheck = require("../../../utils/type-check.js");
const Icon = require("../../../components/common/Icon.vue.js");
const callVideo = require("../../../assets/icon/call-video.svg.js");
const callVoice = require("../../../assets/icon/call-voice.svg.js");
const index = require("../../../components/TUIChat/offlinePushInfoManager/index.js");
const _const = require("../../../components/TUIChat/offlinePushInfoManager/const.js");
const _hoisted_1 = { class: "call-content" };
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "message-call-c2c",
  props: {
    message: {
      type: Object,
      default: () => ({})
    },
    signalingInfo: {
      type: Object,
      default: () => ({})
    },
    customContent: {
      type: Object,
      default: () => ({})
    }
  },
  setup(__props) {
    const props = __props;
    const TYPES = Vue.ref(TUIChatEngine.TYPES);
    const isCallMessage = Vue.computed(() => props.signalingInfo != null);
    const callInfo = Vue.computed(() => {
      var _a, _b;
      const callType = (_b = typeCheck.JSONToObject((_a = props.signalingInfo) == null ? void 0 : _a.data)) == null ? void 0 : _b.call_type;
      switch (callType) {
        case 1:
          return {
            type: 1,
            icon: callVoice.default
          };
        case 2:
          return {
            type: 2,
            icon: callVideo.default
          };
      }
      return {
        type: 0,
        icon: ""
      };
    });
    const conversationType = Vue.computed(() => {
      var _a;
      return (_a = props.message) == null ? void 0 : _a.conversationType;
    });
    const custom = Vue.computed(() => {
      var _a;
      return (_a = props.customContent) == null ? void 0 : _a.custom;
    });
    const callAgain = () => {
      var _a, _b, _c, _d;
      if (conversationType.value === TUIChatEngine.TYPES.CONV_C2C) {
        const userID = ((_a = props.message) == null ? void 0 : _a.flow) === "out" ? (_b = props.message) == null ? void 0 : _b.to : (_c = props.message) == null ? void 0 : _c.from;
        TUICore.callService({
          serviceName: TUICore.TUIConstants.TUICalling.SERVICE.NAME,
          method: TUICore.TUIConstants.TUICalling.SERVICE.METHOD.START_CALL,
          params: {
            userIDList: [userID],
            type: (_d = callInfo == null ? void 0 : callInfo.value) == null ? void 0 : _d.type,
            callParams: {
              offlinePushInfo: index.default.getOfflinePushInfo(_const.PUSH_SCENE.CALL)
            }
          }
        });
      }
    };
    return (_ctx, _cache) => {
      return Vue.unref(isCallMessage) && Vue.unref(conversationType) === Vue.unref(TYPES).CONV_C2C ? (Vue.openBlock(), Vue.createElementBlock("div", {
        key: 0,
        class: Vue.normalizeClass(["call", ["call-" + Vue.unref(conversationType), __props.message.flow === "out" && "call-reverse"]]),
        onClick: callAgain
      }, [
        Vue.createElementVNode("div", {
          class: Vue.normalizeClass(["icon", __props.message.flow === "out" && Vue.unref(callInfo).type === 2 && "icon-reverse"])
        }, [
          Vue.createVNode(Icon.default, {
            file: Vue.unref(callInfo).icon
          }, null, 8, ["file"])
        ], 2),
        Vue.createElementVNode("span", _hoisted_1, Vue.toDisplayString(Vue.unref(custom)), 1)
      ], 2)) : Vue.createCommentVNode("", true);
    };
  }
});
exports.default = _sfc_main;
