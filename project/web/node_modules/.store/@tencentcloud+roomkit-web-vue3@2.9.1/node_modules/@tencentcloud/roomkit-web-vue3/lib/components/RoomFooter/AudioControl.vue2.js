"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
const pinia = require("pinia");
const Message = require("../common/base/Message/Message.js");
const index$1 = require("../common/base/Dialog/index.js");
const room = require("../../stores/room.js");
const message = require("../../constants/message.js");
const index = require("../../locales/index.js");
const TUIRoomEngine = require("@tencentcloud/tuiroom-engine-js");
const useRoomEngine = require("../../hooks/useRoomEngine.js");
const environment = require("../../utils/environment.js");
const Button = require("../common/base/Button.vue.js");
const AudioMediaControl = require("../common/AudioMediaControl.vue.js");
const basic = require("../../stores/basic.js");
const index$2 = require("../common/base/MessageBox/index.js");
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "AudioControl",
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const roomEngine = useRoomEngine.default();
    const roomStore = room.useRoomStore();
    const basicStore = basic.useBasicStore();
    const {
      isAudience,
      localUser,
      isLocalAudioIconDisable,
      isMicrophoneDisableForAllUser,
      userVolumeObj
    } = pinia.storeToRefs(roomStore);
    const emits = __emit;
    const hasMore = Vue.computed(() => !environment.isMobile);
    const { t } = index.useI18n();
    const dialogContent = Vue.ref("");
    function handleAudioMediaClick() {
      emits("click");
      toggleMuteAudio();
    }
    async function toggleMuteAudio() {
      var _a, _b, _c, _d;
      if (isLocalAudioIconDisable.value) {
        let warningMessage = "";
        if (isAudience.value) {
          warningMessage = message.WARNING_MESSAGE.UNMUTE_LOCAL_MIC_FAIL_AUDIENCE;
        } else if (isMicrophoneDisableForAllUser.value) {
          warningMessage = message.WARNING_MESSAGE.UNMUTE_LOCAL_MIC_FAIL_MUTE_ALL;
        }
        Message.default({
          type: "warning",
          message: t(warningMessage),
          duration: message.MESSAGE_DURATION.NORMAL
        });
        return;
      }
      if (localUser.value.hasAudioStream) {
        await ((_a = roomEngine.instance) == null ? void 0 : _a.muteLocalAudio());
        if (roomStore.isMicrophoneDisableForAllUser) {
          roomStore.setCanControlSelfAudio(false);
        }
      } else {
        const microphoneList = await ((_b = roomEngine.instance) == null ? void 0 : _b.getMicDevicesList());
        const hasMicrophoneDevice = microphoneList.length > 0;
        if (!hasMicrophoneDevice && !environment.isWeChat) {
          index$2.default({
            title: t("Note"),
            message: t("Microphone not detected on current device"),
            confirmButtonText: t("Sure")
          });
          return;
        }
        await ((_c = roomEngine.instance) == null ? void 0 : _c.unmuteLocalAudio());
        if (!basicStore.isOpenMic) {
          (_d = roomEngine.instance) == null ? void 0 : _d.openLocalMicrophone();
          basicStore.setIsOpenMic(true);
        }
      }
    }
    const showRequestOpenMicDialog = Vue.ref(false);
    const requestOpenMicRequestId = Vue.ref("");
    async function onRequestReceived(eventInfo) {
      const { userId, requestAction, requestId } = eventInfo.request;
      if (requestAction === TUIRoomEngine.TUIRequestAction.kRequestToOpenRemoteMicrophone) {
        const userRole = roomStore.getUserRole(userId) === TUIRoomEngine.TUIRole.kRoomOwner ? t("RoomOwner") : t("Admin");
        dialogContent.value = t("Sb invites you to turn on the microphone", {
          role: userRole
        });
        requestOpenMicRequestId.value = requestId;
        showRequestOpenMicDialog.value = true;
      }
    }
    async function handleAccept() {
      var _a;
      roomStore.setCanControlSelfAudio(true);
      await ((_a = roomEngine.instance) == null ? void 0 : _a.responseRemoteRequest({
        requestId: requestOpenMicRequestId.value,
        agree: true
      }));
      requestOpenMicRequestId.value = "";
      showRequestOpenMicDialog.value = false;
    }
    async function handleReject() {
      var _a;
      await ((_a = roomEngine.instance) == null ? void 0 : _a.responseRemoteRequest({
        requestId: requestOpenMicRequestId.value,
        agree: false
      }));
      requestOpenMicRequestId.value = "";
      showRequestOpenMicDialog.value = false;
    }
    async function onRequestCancelled(eventInfo) {
      const { requestId } = eventInfo;
      if (requestOpenMicRequestId.value === requestId) {
        showRequestOpenMicDialog.value = false;
      }
    }
    TUIRoomEngine.once("ready", () => {
      var _a, _b;
      (_a = roomEngine.instance) == null ? void 0 : _a.on(TUIRoomEngine.TUIRoomEvents.onRequestReceived, onRequestReceived);
      (_b = roomEngine.instance) == null ? void 0 : _b.on(TUIRoomEngine.TUIRoomEvents.onRequestCancelled, onRequestCancelled);
    });
    Vue.onUnmounted(() => {
      var _a, _b;
      (_a = roomEngine.instance) == null ? void 0 : _a.off(TUIRoomEngine.TUIRoomEvents.onRequestReceived, onRequestReceived);
      (_b = roomEngine.instance) == null ? void 0 : _b.off(
        TUIRoomEngine.TUIRoomEvents.onRequestCancelled,
        onRequestCancelled
      );
    });
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock("div", null, [
        Vue.createVNode(AudioMediaControl.default, {
          "has-more": hasMore.value,
          "is-muted": !Vue.unref(localUser).hasAudioStream,
          "is-disabled": Vue.unref(isLocalAudioIconDisable),
          "audio-volume": Vue.unref(userVolumeObj)[Vue.unref(localUser).userId],
          onClick: handleAudioMediaClick
        }, null, 8, ["has-more", "is-muted", "is-disabled", "audio-volume"]),
        Vue.createVNode(Vue.unref(index$1.default), {
          modelValue: showRequestOpenMicDialog.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showRequestOpenMicDialog.value = $event),
          title: Vue.unref(t)("Tips"),
          modal: true,
          "show-close": false,
          "close-on-click-modal": false,
          width: "500px",
          "append-to-room-container": true,
          "confirm-button": Vue.unref(t)("Turn on the microphone"),
          "cancel-button": Vue.unref(t)("Keep it closed"),
          onConfirm: handleAccept,
          onCancel: handleReject
        }, {
          footer: Vue.withCtx(() => [
            Vue.createVNode(Button.default, {
              class: "agree-button",
              size: "default",
              onClick: handleAccept
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(t)("Turn on the microphone")), 1)
              ]),
              _: 1
            }),
            Vue.createVNode(Button.default, {
              class: "cancel-button",
              size: "default",
              type: "primary",
              onClick: handleReject
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(t)("Keep it closed")), 1)
              ]),
              _: 1
            })
          ]),
          default: Vue.withCtx(() => [
            Vue.createElementVNode("span", null, Vue.toDisplayString(dialogContent.value), 1)
          ]),
          _: 1
        }, 8, ["modelValue", "title", "confirm-button", "cancel-button"])
      ]);
    };
  }
});
exports.default = _sfc_main;
