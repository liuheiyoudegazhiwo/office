var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import mitt from "mitt";
import { isElectron, isMobile } from "../../utils/environment.mjs";
import { findLastIndex } from "../../utils/utils.mjs";
var AI_TASK = /* @__PURE__ */ ((AI_TASK2) => {
  AI_TASK2["TRANSCRIPTION_TASK"] = "transcription";
  return AI_TASK2;
})(AI_TASK || {});
const ASR_EVENT_CODE = 1e4;
class AITask {
  constructor(service) {
    __publicField(this, "emitter", mitt());
    __publicField(this, "trtc");
    __publicField(this, "service");
    __publicField(this, "subtitleMessages", {});
    __publicField(this, "transcribedMessageList", []);
    __publicField(this, "subtitleTimeout", {});
    this.service = service;
    if (isElectron || isMobile) return;
    this.bindCtx();
    this.bindEvent();
  }
  bindCtx() {
    this.handleMount = this.handleMount.bind(this);
    this.handleUnmount = this.handleUnmount.bind(this);
    this.handleAIMessage = this.handleAIMessage.bind(this);
  }
  on(eventType, callback) {
    this.emitter.on(eventType, callback);
  }
  off(eventType, callback) {
    this.emitter.off(eventType, callback);
  }
  emit(eventType, data) {
    this.emitter.emit(eventType, data);
  }
  dispose() {
    this.service.lifeCycleManager.off("mount", this.handleMount);
    this.service.lifeCycleManager.off("unmount", this.handleUnmount);
  }
  handleMount() {
    var _a, _b, _c, _d;
    if (typeof ((_a = this.service.roomEngine.instance) == null ? void 0 : _a.getTRTCCloud) === "undefined" || typeof ((_c = (_b = this.service.roomEngine.instance) == null ? void 0 : _b.getTRTCCloud()) == null ? void 0 : _c._trtc) === "undefined") {
      return;
    }
    this.trtc = (_d = this.service.roomEngine.instance) == null ? void 0 : _d.getTRTCCloud()._trtc;
    this.trtc.on("custom-message", this.handleAIMessage);
  }
  handleUnmount() {
    var _a;
    this.subtitleMessages = {};
    this.transcribedMessageList = [];
    (_a = this.trtc) == null ? void 0 : _a.off("custom-message", this.handleAIMessage);
  }
  bindEvent() {
    this.service.lifeCycleManager.on("mount", this.handleMount);
    this.service.lifeCycleManager.on("unmount", this.handleUnmount);
  }
  resetSubtitleTimeout(id, fn) {
    if (this.subtitleTimeout[id]) {
      clearTimeout(this.subtitleTimeout[id]);
    }
    this.subtitleTimeout[id] = setTimeout(fn, 3e3);
  }
  handleAIMessage(event) {
    if (event.cmdId !== 1) return;
    const data = new TextDecoder().decode(event.data);
    const jsonData = JSON.parse(data);
    this.handleMessage(jsonData);
    this.emit("transcription", {
      subtitleMessages: this.subtitleMessages,
      transcribedMessageList: this.transcribedMessageList
    });
  }
  handleMessage(data) {
    if (data.type !== ASR_EVENT_CODE) return;
    const { sender, payload } = data;
    const { end } = payload;
    const createSubtitleMsg = () => {
      return {
        sender,
        text: payload.text,
        translationText: payload.translation_text,
        startMsTs: data.start_ms_ts,
        end
      };
    };
    const updateMsg = (msg) => {
      msg.text = payload.text;
      msg.translationText = payload.translation_text;
      msg.end = end;
    };
    const appendMsg = (msg, target) => {
      if (Array.isArray(target)) {
        target.push(msg);
      } else if (typeof target === "object") {
        const recordTarget = target;
        recordTarget[msg.sender] = msg;
      } else {
        throw new Error("Invalid target type");
      }
    };
    const existingSubtitle = this.subtitleMessages[sender];
    if (existingSubtitle) {
      updateMsg(existingSubtitle);
    } else {
      appendMsg(createSubtitleMsg(), this.subtitleMessages);
    }
    const transcriptionIndex = findLastIndex(
      this.transcribedMessageList,
      (msg) => msg.sender === sender && !msg.end
    );
    if (transcriptionIndex !== -1) {
      updateMsg(this.transcribedMessageList[transcriptionIndex]);
    } else {
      appendMsg(createSubtitleMsg(), this.transcribedMessageList);
    }
    this.resetSubtitleTimeout(sender, () => {
      if (!end) return;
      delete this.subtitleMessages[sender];
      this.emit("transcription", {
        subtitleMessages: this.subtitleMessages,
        transcribedMessageList: this.transcribedMessageList
      });
    });
  }
}
export {
  AITask,
  AI_TASK
};
