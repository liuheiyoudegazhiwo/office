"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const TUIChatEngine = require("@tencentcloud/chat-uikit-engine");
const index = require("../../common/Toast/index.js");
const env = require("../../../utils/env.js");
const type = require("../../common/Toast/type.js");
const _CopyManager = class _CopyManager {
  constructor() {
    __publicField(this, "savedSelection");
    this.savedSelection = null;
  }
  static getInstance() {
    if (!_CopyManager.instance) {
      _CopyManager.instance = new _CopyManager();
    }
    return _CopyManager.instance;
  }
  saveCurrentSelection() {
    const selection = window.getSelection();
    if (env.isH5 || !selection) {
      return;
    }
    this.savedSelection = {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
  restoreSelection() {
    const selection = window.getSelection();
    if (env.isH5 || !selection || !this.savedSelection) {
      return;
    }
    const { anchorNode, anchorOffset, focusNode, focusOffset } = this.savedSelection;
    if (!anchorNode || !focusNode) {
      return;
    }
    const range = document.createRange();
    const isForwardSelection = anchorNode === focusNode ? anchorOffset <= focusOffset : anchorNode.compareDocumentPosition(focusNode) & Node.DOCUMENT_POSITION_FOLLOWING;
    if (isForwardSelection) {
      range.setStart(anchorNode, anchorOffset);
      range.setEnd(focusNode, focusOffset);
    } else {
      range.setStart(focusNode, focusOffset);
      range.setEnd(anchorNode, anchorOffset);
    }
    selection.removeAllRanges();
    selection.addRange(range);
  }
  async copySelection(defaultContent) {
    this.restoreSelection();
    const selection = window.getSelection();
    if (env.isH5 || !selection || selection.rangeCount === 0) {
      await this.copyTextOrHtml(defaultContent, "text");
      return;
    }
    const range = selection.getRangeAt(0);
    const fragment = range.cloneContents();
    const tempContainer = document.createElement("div");
    tempContainer.appendChild(fragment);
    const content = tempContainer.innerHTML || defaultContent;
    const type2 = tempContainer.innerHTML ? "html" : "text";
    await this.copyTextOrHtml(content, type2);
    this.savedSelection = null;
  }
  async copyTextOrHtml(content, type$1) {
    const mimeType = type$1 === "html" ? "text/html" : "text/plain";
    if (navigator.clipboard) {
      try {
        const contentBlob = new Blob([content], { type: mimeType });
        const clipboardItem = new ClipboardItem({ [mimeType]: contentBlob });
        await navigator.clipboard.write([clipboardItem]);
        return;
      } catch (err) {
      }
    }
    let tempElement;
    if (type$1 === "html") {
      tempElement = document.createElement("div");
      tempElement.style.position = "fixed";
      tempElement.style.opacity = "0";
      tempElement.contentEditable = "true";
      tempElement.innerHTML = content;
      document.body.appendChild(tempElement);
      const range = document.createRange();
      range.selectNodeContents(tempElement);
      const selection = window.getSelection();
      selection == null ? void 0 : selection.removeAllRanges();
      selection == null ? void 0 : selection.addRange(range);
      tempElement.focus();
    } else {
      tempElement = document.createElement("textarea");
      tempElement.value = content;
      tempElement.style.position = "fixed";
      document.body.appendChild(tempElement);
      tempElement.focus();
      tempElement.select();
    }
    try {
      document.execCommand("copy");
    } catch (err) {
      index.Toast({
        message: TUIChatEngine.TUITranslateService.t("TUIChat.此机型暂不支持复制"),
        type: type.default.ERROR
      });
      console.warn("use document.execCommand copy failed:", err);
    } finally {
      document.body.removeChild(tempElement);
    }
  }
};
__publicField(_CopyManager, "instance");
let CopyManager = _CopyManager;
const CopyManager$1 = CopyManager.getInstance();
exports.default = CopyManager$1;
