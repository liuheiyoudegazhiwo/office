import { defineComponent, ref, onMounted, onUnmounted, computed, withDirectives, createElementBlock, openBlock, normalizeClass, unref, createElementVNode, toDisplayString, vShow } from "vue";
import "../../../../../adapter-vue.mjs";
import TUIChatEngine, { TUIStore, StoreName, TUITranslateService } from "@tencentcloud/chat-uikit-engine";
import ChatConfig from "../../../config.mjs";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    message: { default: () => ({}) }
  },
  emits: ["openReadUserPanel"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const props = __props;
    const ReadStatus = ChatConfig.getFeatureConfig("ReadStatus");
    const TYPES = TUIChatEngine.TYPES;
    const isDisplayMessageReadReceipt = ref(TUIStore.getData(StoreName.USER, "displayMessageReadReceipt"));
    onMounted(() => {
      TUIStore.watch(StoreName.USER, {
        displayMessageReadReceipt: onDisplayMessageReadReceiptUpdate
      });
    });
    onUnmounted(() => {
      TUIStore.unwatch(StoreName.USER, {
        displayMessageReadReceipt: onDisplayMessageReadReceiptUpdate
      });
    });
    const isShowReadStatus = computed(() => {
      if (!ReadStatus) {
        return false;
      }
      if (!isDisplayMessageReadReceipt.value) {
        return false;
      }
      const {
        ID,
        type,
        flow,
        status,
        hasRiskContent,
        conversationID,
        conversationType,
        needReadReceipt = false
      } = props.message;
      if (hasRiskContent) {
        return false;
      }
      const { groupProfile } = TUIStore.getConversationModel(conversationID) || {};
      if ((groupProfile == null ? void 0 : groupProfile.type) === TYPES.GRP_AVCHATROOM || (groupProfile == null ? void 0 : groupProfile.type) === TYPES.GRP_COMMUNITY) {
        return false;
      }
      if (type === TYPES.MSG_CUSTOM) {
        const message = TUIStore.getMessageModel(ID);
        if ((message == null ? void 0 : message.getSignalingInfo()) !== null) {
          return false;
        }
      }
      if (flow !== "out" || status !== "success") {
        return false;
      }
      if (conversationType === "GROUP") {
        return needReadReceipt;
      } else if (conversationType === "C2C") {
        return true;
      }
      return false;
    });
    const readState = computed(() => {
      const { conversationType, needReadReceipt = false, isPeerRead = false } = props.message;
      const { readCount = 0, unreadCount = 0, isPeerRead: isReceiptPeerRead = false } = props.message.readReceiptInfo;
      if (conversationType === "C2C") {
        if (needReadReceipt) {
          return isReceiptPeerRead ? 0 : 1;
        } else {
          return isPeerRead ? 0 : 1;
        }
      } else if (conversationType === "GROUP") {
        if (needReadReceipt) {
          if (readCount === 0) {
            return 1;
          } else if (unreadCount === 0) {
            return 2;
          } else {
            return 4;
          }
        } else {
          return 3;
        }
      }
      return 1;
    });
    const readStatusText = computed(() => {
      const { readCount = 0 } = props.message.readReceiptInfo;
      switch (readState.value) {
        case 0:
          return TUITranslateService.t("TUIChat.已读");
        case 1:
          return TUITranslateService.t("TUIChat.未读");
        case 2:
          return TUITranslateService.t("TUIChat.全部已读");
        case 4:
          return `${readCount}${TUITranslateService.t("TUIChat.人已读")}`;
        default:
          return "";
      }
    });
    const isUseUnreadStyle = computed(() => {
      const { conversationType } = props.message;
      if (conversationType === "C2C") {
        return readState.value !== 0;
      } else if (conversationType === "GROUP") {
        return readState.value !== 2;
      }
      return false;
    });
    const isHoverFingerPointer = computed(() => {
      return props.message.needReadReceipt && props.message.conversationType === "GROUP" && (readState.value === 4 || readState.value === 1);
    });
    function openReadUserPanel() {
      if (isHoverFingerPointer.value) {
        emits("openReadUserPanel");
      }
    }
    function onDisplayMessageReadReceiptUpdate(isDisplay) {
      isDisplayMessageReadReceipt.value = isDisplay;
    }
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass({
          "message-label": true,
          "unread": unref(isUseUnreadStyle),
          "finger-point": unref(isHoverFingerPointer)
        }),
        onClick: openReadUserPanel
      }, [
        createElementVNode("span", null, toDisplayString(unref(readStatusText)), 1)
      ], 2)), [
        [vShow, unref(isShowReadStatus)]
      ]);
    };
  }
});
export {
  _sfc_main as default
};
