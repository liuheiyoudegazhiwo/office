"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Vue = require("vue");
const pinia = require("pinia");
const index$1 = require("../common/base/Dialog/index.js");
const VideoMediaControl = require("../common/VideoMediaControl.vue.js");
const room = require("../../stores/room.js");
const message = require("../../constants/message.js");
const index = require("../../locales/index.js");
const useRoomEngine = require("../../hooks/useRoomEngine.js");
const useDeviceManager = require("../../hooks/useDeviceManager.js");
const TUIRoomEngine = require("@tencentcloud/tuiroom-engine-js");
const environment = require("../../utils/environment.js");
const basic = require("../../stores/basic.js");
const Button = require("../common/base/Button.vue.js");
const Message = require("../common/base/Message/Message.js");
const index$2 = require("../common/base/MessageBox/index.js");
const _sfc_main = /* @__PURE__ */ Vue.defineComponent({
  __name: "VideoControl",
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const roomEngine = useRoomEngine.default();
    const { deviceManager } = useDeviceManager.default();
    const roomStore = room.useRoomStore();
    const basicStore = basic.useBasicStore();
    const dialogContent = Vue.ref("");
    const emits = __emit;
    const {
      isCameraDisableForAllUser,
      isAudience,
      localUser,
      isLocalVideoIconDisable
    } = pinia.storeToRefs(roomStore);
    const { t } = index.useI18n();
    const hasMore = Vue.computed(() => !environment.isMobile);
    const showVideoSettingTab = Vue.ref(false);
    function handleVideoMediaClick() {
      emits("click");
      toggleMuteVideo();
    }
    async function toggleMuteVideo() {
      var _a, _b, _c, _d;
      if (isLocalVideoIconDisable.value) {
        let warningMessage = "";
        if (isAudience.value) {
          warningMessage = message.WARNING_MESSAGE.UNMUTE_LOCAL_CAMERA_FAIL_AUDIENCE;
        } else if (isCameraDisableForAllUser.value) {
          warningMessage = message.WARNING_MESSAGE.UNMUTE_LOCAL_CAMERA_FAIL_MUTE_ALL;
        }
        Message.default({
          type: "warning",
          message: t(warningMessage),
          duration: message.MESSAGE_DURATION.NORMAL
        });
        return;
      }
      if (localUser.value.hasVideoStream) {
        await ((_a = roomEngine.instance) == null ? void 0 : _a.closeLocalCamera());
        if (roomStore.isCameraDisableForAllUser) {
          roomStore.setCanControlSelfVideo(false);
        }
      } else {
        const cameraList = await ((_b = deviceManager.instance) == null ? void 0 : _b.getDevicesList({
          type: TUIRoomEngine.TUIMediaDeviceType.kMediaDeviceTypeVideoCamera
        }));
        const hasCameraDevice = cameraList && cameraList.length > 0;
        if (!hasCameraDevice && !environment.isWeChat) {
          index$2.default({
            title: t("Note"),
            message: t("Camera not detected on current device"),
            confirmButtonText: t("Sure")
          });
          return;
        }
        if (environment.isMobile) {
          await ((_c = roomEngine.instance) == null ? void 0 : _c.openLocalCamera({
            isFrontCamera: basicStore.isFrontCamera
          }));
        } else {
          await ((_d = roomEngine.instance) == null ? void 0 : _d.openLocalCamera());
        }
      }
      showVideoSettingTab.value = false;
    }
    const showRequestOpenCameraDialog = Vue.ref(false);
    const requestOpenCameraRequestId = Vue.ref("");
    async function onRequestReceived(eventInfo) {
      const { userId, requestAction, requestId } = eventInfo.request;
      if (requestAction === TUIRoomEngine.TUIRequestAction.kRequestToOpenRemoteCamera) {
        const userRole = roomStore.getUserRole(userId) === TUIRoomEngine.TUIRole.kRoomOwner ? t("RoomOwner") : t("Admin");
        dialogContent.value = t("Sb invites you to turn on the camera", {
          role: userRole
        });
        requestOpenCameraRequestId.value = requestId;
        showRequestOpenCameraDialog.value = true;
      }
    }
    async function handleAccept() {
      var _a;
      roomStore.setCanControlSelfVideo(true);
      await ((_a = roomEngine.instance) == null ? void 0 : _a.responseRemoteRequest({
        requestId: requestOpenCameraRequestId.value,
        agree: true
      }));
      requestOpenCameraRequestId.value = "";
      showRequestOpenCameraDialog.value = false;
    }
    async function handleReject() {
      var _a;
      await ((_a = roomEngine.instance) == null ? void 0 : _a.responseRemoteRequest({
        requestId: requestOpenCameraRequestId.value,
        agree: false
      }));
      requestOpenCameraRequestId.value = "";
      showRequestOpenCameraDialog.value = false;
    }
    async function onRequestCancelled(eventInfo) {
      const { requestId } = eventInfo;
      if (requestOpenCameraRequestId.value === requestId) {
        showRequestOpenCameraDialog.value = false;
      }
    }
    TUIRoomEngine.once("ready", () => {
      var _a, _b;
      (_a = roomEngine.instance) == null ? void 0 : _a.on(TUIRoomEngine.TUIRoomEvents.onRequestReceived, onRequestReceived);
      (_b = roomEngine.instance) == null ? void 0 : _b.on(TUIRoomEngine.TUIRoomEvents.onRequestCancelled, onRequestCancelled);
    });
    Vue.onUnmounted(() => {
      var _a, _b;
      (_a = roomEngine.instance) == null ? void 0 : _a.off(TUIRoomEngine.TUIRoomEvents.onRequestReceived, onRequestReceived);
      (_b = roomEngine.instance) == null ? void 0 : _b.off(
        TUIRoomEngine.TUIRoomEvents.onRequestCancelled,
        onRequestCancelled
      );
    });
    return (_ctx, _cache) => {
      return Vue.openBlock(), Vue.createElementBlock("div", null, [
        Vue.createVNode(VideoMediaControl.default, {
          "has-more": hasMore.value,
          "is-muted": !Vue.unref(localUser).hasVideoStream,
          "is-disabled": Vue.unref(isLocalVideoIconDisable),
          onClick: handleVideoMediaClick
        }, null, 8, ["has-more", "is-muted", "is-disabled"]),
        Vue.createVNode(Vue.unref(index$1.default), {
          modelValue: showRequestOpenCameraDialog.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => showRequestOpenCameraDialog.value = $event),
          title: Vue.unref(t)("Tips"),
          modal: true,
          "show-close": false,
          "close-on-click-modal": false,
          width: "500px",
          "append-to-room-container": true,
          "confirm-button": Vue.unref(t)("Turn on the camera"),
          "cancel-button": Vue.unref(t)("Keep it closed"),
          onConfirm: handleAccept,
          onCancel: handleReject
        }, {
          footer: Vue.withCtx(() => [
            Vue.createVNode(Button.default, {
              class: "cancel-button",
              size: "default",
              onClick: handleAccept
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(t)("Turn on the camera")), 1)
              ]),
              _: 1
            }),
            Vue.createVNode(Button.default, {
              class: "cancel-button",
              size: "default",
              type: "primary",
              onClick: handleReject
            }, {
              default: Vue.withCtx(() => [
                Vue.createTextVNode(Vue.toDisplayString(Vue.unref(t)("Keep it closed")), 1)
              ]),
              _: 1
            })
          ]),
          default: Vue.withCtx(() => [
            Vue.createElementVNode("span", null, Vue.toDisplayString(dialogContent.value), 1)
          ]),
          _: 1
        }, 8, ["modelValue", "title", "confirm-button", "cancel-button"])
      ]);
    };
  }
});
exports.default = _sfc_main;
